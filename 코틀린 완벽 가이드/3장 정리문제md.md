

# 3장 정리문제

1. ﻿﻿﻿식이 본문인 함수란 무엇인가? 블록이 본문인 함수 대신 식이 본문인 함수를 쓰면 어떤 경우 에 더 좋을까?

2. ﻿﻿﻿디폴트 파라미터와 함수 오버로딩 중 어느 쪽을 써야 할지 어떻게 결정할 수 있을까?

3. ﻿﻿﻿이름 붙은 인자를 사용할 경우의 장단점은 무엇인가?

4. ﻿﻿﻿인자 개수가 가변적인 함수를 정의하는 방법은 무엇인가? 코틀린과 자바에서 vararg 함수는 어떻게 다른가?

5. ﻿﻿﻿Unit과 Nothing 타입을 어디에 사용하는가? 이들을 자바의 void와 비교해 설명하라. Nothing 이나 Uit이 타입인 함수를 정의해 사용할 수 있는가?

6. ﻿﻿﻿return 0과 같은 코드의 의미를 설명해보라. 이런 코드가 올바르지만 불필요한 중복이 있는 것으로 여겨지는 이유는 무엇인가?

7. ﻿﻿﻿return 문을 사용하지 않는 함수를 정의할 수 있는가?

8. ﻿﻿﻿지역 함수란 무엇인가? 이런 함수를 자바에서는 어떻게 흉내 낼 수 있을까?

9. ﻿﻿﻿공개(public)와 비공개(privale) 최상위 함수는 어떤 차이가 있는가?

10. ﻿﻿﻿패키지를 사용해 코드를 어떻게 여러 그룹으로 나눌 수 있는가? 자바와 코틀린 패키지의 가장 핵심적인 차이는 무엇인지 설명하라.

11. ﻿﻿﻿임포트 별명이란 무엇인가? 자바의 정적 임포트와 비슷한 임포트를 코틀린에서는 어떻게 처 리하는가?

12. ﻿﻿﻿1f 문/식은 어떤 일을 하는가? 각각을 자바의 1f 문 및 3항 조건 연산자(?:)와 비교해보라.

13. ﻿﻿﻿﻿when 문을 처리하는 알고리즘을 설명하라. 자바 switch와 코틀린 when은 어떤 차이가 있는가?
14. 자바 for (int 1 = 0; 1< 100; 1+t)와 같이 수를 세는 루프를 코틀린에서는 어떻게 구현하 는가?
15. 코틀린이 제공하는 루프 문에는 어떤 것이 있는가? while과 do.. While의 차이는 무엇인가? 코틀린 for 루프를 사용해야 하는 이유는 무엇인가?
16. ﻿﻿﻿﻿break와 continue를 사용해 루프의 제어 흐름을 어떻게 변경할 수 있는가?
17. ﻿﻿﻿﻿예외 처리 과정을 전체적으로 설명하라. 자바와의 차이점은 무엇인가? 자바와 코틀린에서 try 문이 어떻게 다른지 설명하라.



# 답안 

1.    식이 본문인 함수란 무엇인가? 블록이 본문인 함수 대신 식이 본문인 함수를 쓰면 어떤 경우 에 더 좋을까?

      1. 본문이 중괄호로 둘러싸인 함수를 블록이 본문이 함수라 부르고, 등호와 식으로 이뤄진 함수를 식이 본문이 함수라고 부른다.

         ```kotlin
         fun circleArea2(radius: Double) = PI*radius*radius // 반환값이 Double로 추론됨
         // 다음도 가능
         fun readInt(default: Int) = try {
           readLine()!!.toInt()
         } catch (e: NumberFormatException) {
           default
         }
         ```

         컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 함수 반환 타입으로 정해준다. (타입 추론)

         이러한 함수는 단일 표현식으로 이루어지며, 반환 값이 함수의 유일한 결과입니다.

         식이 본문인 함수는 코드의 길이를 줄이고 가독성을 높이는 데 도움이 됩니다. 일반적으로 함수의 본문이 단일 표현식으로 간단한 계산을 수행하는 경우에 사용됩니다.

2.    디폴트 파라미터와 함수 오버로딩 중 어느 쪽을 써야 할지 어떻게 결정할 수 있을까?

      * > 디폴트 파라미터(Default Parameter)라고 합니다. 따라서 함수를 호출할 때 해당 파라미터에 대한 값을 지정하지 않으면 기본값이 사용됩니다.
        >
        > 함수 오버로딩(Function Overloading)은 함수의 이름은 동일하고 파라미터의 개수 또는 타입이 다른 버전을 여러 개 선언하는 것을 말합니다.
        >
        > 디폴트 파라미터와 함수 오버로딩은 둘 다 함수의 재사용성을 높이는 방법입니다. 그러나 둘 사이에는 차이점이 있습니다.
        >
        > 디폴트 파라미터는 함수를 선언할 때 모든 가능한 경우의 수를 고려하여 파라미터 기본값을 설정하는 것입니다. 이 방식은 코드의 가독성과 유지보수성을 향상시킬 수 있습니다. 그러나 디폴트 파라미터를 오용하면 코드가 더 복잡해질 수 있습니다.
        >
        > 반면, 함수 오버로딩은 다양한 파라미터를 가진 여러 개의 함수를 선언하여 호출하는 측에서는 간편하게 사용할 수 있습니다. 그러나 함수 오버로딩은 함수의 이름이 같기 때문에 호출하는 측에서는 어떤 함수가 호출되는지 명확하지 않을 수 있습니다.
        >
        > 따라서, 함수를 디폴트 파라미터로 구현할지, 함수 오버로딩으로 구현할지 결정하는 데는 몇 가지 고려 사항이 있습니다.
        >
        > - 함수의 목적과 의도: 함수의 목적이 파라미터의 기본값을 사용하는 것이라면 디폴트 파라미터를 사용하는 것이 더 적합합니다. 하지만 함수의 목적이 호출하는 측에서 다양한 파라미터를 선택할 수 있도록 하는 것이라면 함수 오버로딩을 고려해야 합니다.
        > - 코드의 가독성: 함수의 목적을 이해하고 파라미터를 이해하기 쉽게 만드는 것이 중요합니다. 따라서 코드의 가독성을 높이는 데 기여하는 것이 더 적합한 방식을 선택해야 합니다.
        > - 코드의 유지보수성: 코드의 복잡성을 줄이고 유지보수성을 높이는 것이 중요합니다. 따라서 코드의 변화나 확장이 발생할 때 코드를 수정하기 쉽게 만드는 것이 더 적합한 방식을 선택해야 합니다.

      1. 파라미터 개수와 타입을 기준으로 호출 할 수 있는 모든 함수를 찾는다.
      2. 덜 구체적인 함수를 제외 시킨다.덜 구체적인 함수가 모두 제외 될때까지 이 단계를 반복한다.
      3. 후보가 하나로 압축되면 함수를 호출하고 후보가 2개 이상일 경우 오류가 발생한다.

      * ```kotlin
        fun mul(a: Int, b: Int) = a*b            // 1
        fun mul(a: Int, b: Int, c: Int) = a*b*c  // 2
        fun mul(s: String, n: Int) = s.repeat(n) // 3
        fun mul(o: Any, n: Int) = Array(n) { o } // 4
        
        mul(1, 2)   // Int가 Any의 하위타입이므로 1과 4중에 1을 선택
        // mul(1, 2L) // error: none of the following functions can be called with the arguments supplied
                    // 오류: (Int, Long) 타입을 받을 수 있는 함수가 없음
        mul(1L, 2)  // Long, Int 타입을 받을 수 있는 함수는 4번뿐이므로 4를 선택
        mul("0", 3) // String이 Any의 하위타입이기 때문에 3과 4중에 3을 선택
        
        ---------------------------------------------------------------------------------
        
        fun mul2(a: Int, b: Int = 1) = a*b           // 1
        fun mul2(a: Int, b: Long = 1L) = a*b         // 2
        fun mul2(a: Int, b: Int, c: Int = 1) = a*b*c // 3
        
        //mul2(10)         // error: overload resolution ambiguity
                         // 오류: 1과 2 사이에 어느 쪽을 호출할지 결정할 수 없음
        mul2(10, 20)     // 인자가 더 적기 때문에 1과 3 중에 1을 선택
        mul2(10, 20, 30) // 적용 가능한 함수가 3번뿐이어서 3을 선택
        ```

3.    이름 붙은 인자를 사용할 경우의 장단점은 무엇인가?



### 3. 이름 붙은 인자를 사용할 경우 장단점은 무엇인가?

장점으로는 사용할 경우 어떤 인자에 어떤 인자가 쓰이는지 가시성이 좋아지고, 모든 인자를 이름 붙은 인자로 사용할 경우 함수의 인자의 순서에 영향을 받지 않는다.

단점으로는 가독성과 안전성의 향상에는 비용이 따르기 때문에 이름 붙은 인자도 예외가 아니다. 또한 인자가 많아 지게되면 코드가 길어지고 장황스러워 지고, 인수 이름을 변경하면 함수를 호출하는 이름도 바뀌어야 합니다.

------

### 4. 인자 개수가 가변적인 함수를 정의하는 방법은 무엇인가? kotlin과 java에서 vararg 함수는 어떻게 다른가?

```kotlin
fun printSorted(vararg items: Int) {
  items.sort()
  println(items.contentToString())
}

printSorted(6, 1, *intArrayOf(3, 8), 2) // 6,1,3,8,2 순서로 원소가 들어있는 배열이 전달되고, [1, 2, 3, 6, 8]이 반환됨

printSorted(items = intArrayOf(1, 2, 3)) // vararg의 이름을 지정할 때는 배열을 그냥 넘기면 됨
```

코틀린의 varargs는 자바의 vargs와 동일하지만 구문은 약간 다르다. 세 개의 점이 있는 대신 파라미터에 코틀린에서는 vararg를 사용 한다.

Kotlin과 Java의 또 다른 차이점은 Java에서는 배열을 그대로 전달하지만 Kotlin에서는 배열을 명시적으로 풀어야 한다.

------

### 5. Unit과 Nothing 타입은 어디서 사용하는가? void와 비교해서 설명하라. Nothing이나 Unit인 함수를 정의해 사용할 수 있는가?

### Unit

Unit의 가장 큰 이유는 제네릭이다.

모든 함수는 값을 반환해야 한다. 코틀린은 자바에서처럼 특별한 형태의 보이드를 갖는 대신 클래스로 표현하기로 결정했다. 클래스를 사용하는 이유는 형식 시스템을 형식 계층의 일부로 만들어 보다 일관되게 만들 수 있기 때문이다.

예를 들어, `Worker<T>` 라는 일반 인터페이스가 있다고 하자. 이 인터페이스의 doWork() 함수는 값 T를 반환해야 한다.

```kotlin
interface Worker<T> {
    fun doWork(): T
}
```

그러나 Worker 인터페이스를 확장하는 LogWorker 클래스에서 값을 반환할 필요가 없는 작업(예: 로그 작업)에 이 인터페이스를 사용할 수도 있다.

```kotlin
class LogWorker : Worker<Unit> {
    override fun doWork() {
        // Do the logging
    }
}
```

이것은 원래 값을 반환하도록 설계된 기존 인터페이스를 사용할 수 있는 Unit의 마법이다. doWork() 함수가 반환할 것이 없는 목적을 위해 단위 값을 반환하도록 한다. 따라서 일반 매개 변수를 반환하는 함수를 재정의할 때 유용하다.

또한 doWork() 함수에 대한 Unit return type 언급은 생략했고 Return 구문을 작성할 필요도 없다.

### Nothing

#### Nothing은 return value가 절대 존재 하지 않는 다는걸 명시적으로 표현한다.

```kotlin
fun error(message: Any): Nothing = throw IllegalStateException(message.toString())
```

또한 Any?가 모든 타입의 슈퍼타입이듯이 Nothing은 모든 타입의 서브타입이다. 따라서 다음과 같이 작성이 될 수 있다.

```kotlin
val user: User = request.user ?: error("User not found")

fun getUser(request: Request): User {
    return request.user ?: error("User not found")
}
```

#### Nothing은 Null Object 패턴이다.

```kotlin
fun deleteFiles(files: List<File>? = null) {
    if (files != null) files.forEach { it.delete() }
}
```

이 함수의 설계상의 문제는 `List<File>`이 비어 있는지 null인지 또는 요소가 있는지 여부를 전달하지 않는다는 것 이다. 또한 사용하기 전에 리스트가 null인지 확인해야 한다.

이 문제를 해결하기 위해 Null Object 패턴을 사용한다. Null Object 패턴 패턴에서는 객체의 부재를 전달하기 위해 null 참조를 사용하는 대신 인터페이스를 구현하지만 메서드 본문은 비워두는 객체를 사용한다.

따라서 Nothing을 쓴다면 다음과 같이 깔끔하게 작성이 가능하다.

```kotlin
// This function is already defined in the Kotlin standard library
fun emptyList() = object : List<Nothing> {
    override fun iterator(): Iterator<Nothing> = EmptyIterator
    ...
}

fun deleteFiles(files: List<File> = emptyList()) {
    files.forEach { it.delete() }
}
```

### Void

```kotlin
interface Worker<T> {
    T doWork();
}

class LogWorker implements Worker<Void> {
    @Override public Void doWork() {
        // Do the logging
        return null;
    }
}
```

Void를 사용할 때, 우리는 Void를 반환 유형으로 사용해야 하고(넘길 수 없음) 반환문을 작성해야 하는 반면, Unit의 경우에는 둘 다 건너뛸 수 있다. 이것은 코틀린 코드에서 보이드를 사용하지 않는 또 다른 이유이다.

---

### 6. return 0과 같은 코드의 의미를 설명해보라. 이런 코드가 올바르지만 불필요한 중복이 있는 것으로 여겨지는 이유는 무엇인가?

코틀린에서 `return 0`은 함수의 반환 값으로 0을 반환하는 것을 의미합니다. 일반적으로 이는 함수가 정상적으로 실행되었음을 나타내는 경우가 많습니다.

그러나 코틀린에서는 반환 값이 없는 함수의 경우 `Unit`이라는 타입을 반환합니다. 따라서 반환 값을 명시적으로 지정하지 않아도 됩니다.

즉, 함수의 반환 값이 `Unit`인 경우에는 `return` 키워드를 사용하지 않아도 됩니다. 이 경우 함수의 마지막 표현식이 암묵적으로 반환 값이 됩니다.

따라서, `return 0`과 같은 코드는 올바르게 동작하지만, 반환 값이 없는 함수에서 불필요한 중복 코드를 생성할 수 있습니다. 이는 코드의 가독성을 떨어뜨리고, 유지 보수성을 낮출 수 있습니다.

그러므로, 반환 값이 없는 함수에서 `return` 키워드를 사용하지 않고 함수의 마지막 표현식이 암묵적으로 반환 값이 되도록 작성하는 것이 좋습니다. 이는 코드를 더욱 간결하고 가독성이 좋도록 만들어주며, 코드의 유지 보수성도 높일 수 있습니다.

---

### 7. return 문을 사용하지 않는 함수를 정의할 수 있는가?

코틀린에서는 반환 값이 없는 함수를 정의할 수 있습니다. 이러한 함수는 주로 부수 효과(side effect)를 가지는 작업을 수행하는 데 사용됩니다.

반환 값이 없는 함수를 정의하는 방법은 간단합니다. 함수의 반환 타입을 `Unit`으로 선언하면 됩니다. 예를 들어, 다음과 같이 함수를 선언할 수 있습니다.

```kotlin
fun printMessage(message: String): Unit {
    println(message)
}
```

위 예제에서 `printMessage()` 함수는 문자열을 인자로 받아서 그 문자열을 출력하는 함수입니다. 함수의 반환 값은 `Unit`입니다.

코틀린에서는 반환 값이 없는 함수에서 `return` 키워드를 사용하지 않아도 됩니다. 이 경우 함수의 마지막 표현식이 암묵적으로 반환 값이 됩니다. 따라서, 위의 `printMessage()` 함수를 다음과 같이 작성할 수도 있습니다.

```kotlin
fun printMessage(message: String) {
    println(message)
}
```

위의 예제에서 `Unit`을 반환 타입으로 명시하지 않았습니다. 이 경우 코틀린 컴파일러는 자동으로 반환 타입을 `Unit`으로 지정합니다.

따라서, 반환 값이 없는 함수를 정의할 때는 반환 타입으로 `Unit`을 명시하거나 생략할 수 있습니다. `return` 문을 사용하지 않아도 되므로 코드가 간결해지고 가독성이 향상됩니다.

---

### 8. 지역 함수란 무엇인가? 이런 함수를 자바에서는 어떻게 흉내 낼 수 있을까?

코틀린에서 지역 함수(Local Function)는 다른 함수 내부에 선언된 함수입니다. 지역 함수는 외부 함수 내에서만 호출 가능하며, 외부 함수의 변수와 매개 변수에 접근할 수 있습니다.

지역 함수는 외부 함수의 코드를 더욱 모듈화하고 가독성을 향상시키는 데 도움이 됩니다. 지역 함수를 사용하면 반복되는 코드를 피하고, 코드의 재사용성을 높일 수 있습니다.

코틀린에서 지역 함수를 선언하는 방법은 매우 간단합니다. 다른 함수 내부에 함수를 선언하면 됩니다. 예를 들어, 다음과 같이 외부 함수 내부에 지역 함수를 선언할 수 있습니다.

```kotlin
fun outerFunction() {
    fun innerFunction() {
        // 지역 함수 코드
    }
    
    // 외부 함수 코드
}
```

자바에서는 지역 함수를 직접 지원하지 않습니다. 그러나 익명 내부 클래스(Anonymous Inner Class)를 사용하여 비슷한 효과를 얻을 수 있습니다. 익명 내부 클래스는 다른 클래스 내부에서 선언되며, 클래스 내부에서 사용되는 인스턴스를 만듭니다.

익명 내부 클래스를 사용하여 지역 함수를 흉내 내는 방법은 다음과 같습니다.

```kotlin
javaCopy code
public class OuterClass {
    public void outerFunction() {
        class InnerClass {
            public void innerFunction() {
                // 지역 함수 코드
            }
        }

        InnerClass inner = new InnerClass();
        inner.innerFunction();

        // 외부 함수 코드
    }
}
```

위 예제에서 `OuterClass`는 `outerFunction()`이라는 외부 함수를 가지고 있습니다. 이 함수 내부에서 `InnerClass`라는 지역 클래스를 정의하고, `innerFunction()`이라는 지역 함수를 선언합니다. 그리고 `innerFunction()`을 호출합니다.

이러한 방식으로 익명 내부 클래스를 사용하여 지역 함수를 구현할 수 있지만, 코틀린의 지역 함수처럼 간결하지는 않습니다. 그러나 자바에서는 이 방법을 사용하여 외부 함수 내에서 지역 함수를 구현할 수 있습니다.

---

### 9. 공개(public)와 비공개(privale) 최상위 함수는 어떤 차이가 있는가?

공개 최상위 함수는 프로젝트 어디서에도 호출이 가능하지만, 비공개 최상위 함수는 파일 내에서만 호출이 가능하다.

1. 접근 범위

공개(public) 최상위 함수는 모든 패키지에서 접근 가능합니다. 즉, 다른 패키지에서도 함수를 사용할 수 있습니다. 반면, 비공개(private) 최상위 함수는 같은 파일 내에서만 접근 가능합니다. 다른 파일에서는 함수를 사용할 수 없습니다.

2. 모듈성

공개(public) 최상위 함수는 모듈성을 제공합니다. 즉, 다른 모듈에서도 함수를 사용할 수 있으므로 모듈 간의 재사용성을 높일 수 있습니다. 반면, 비공개(private) 최상위 함수는 모듈성을 제공하지 않습니다. 같은 파일 내에서만 사용할 수 있으므로 재사용성이 낮습니다.

3. 이름 충돌

공개(public) 최상위 함수는 다른 모듈에서도 사용할 수 있기 때문에, 이름 충돌이 발생할 수 있습니다. 따라서, 공개 함수의 이름은 충돌을 피하기 위해 고유한 이름으로 지정하는 것이 좋습니다. 반면, 비공개(private) 최상위 함수는 같은 파일 내에서만 사용되므로 이름 충돌 문제가 발생하지 않습니다.

따라서, 공개(public) 최상위 함수는 모듈 간의 재사용성을 높이는 데 유용하며, 비공개(private) 최상위 함수는 모듈성을 제공하지 않고 이름 충돌 문제를 피할 수 있습니다. 이러한 차이점을 고려하여 최상위 함수의 접근 범위를 결정하는 것이 좋습니다.

---

### 10. 패키지를 사용해 코드를 어떻게 여러 그룹으로 나눌 수 있는가? 자바와 코틀린 패키지의 가장 핵심적인 차이는 무엇인지 설명하라.

코틀린에서 패키지는 코드를 그룹화하고, 코드의 이름 공간(namespace)을 관리하는 데 사용됩니다. 코틀린에서 패키지를 사용하여 코드를 여러 그룹으로 나누는 방법은 다음과 같습니다.

1. 패키지 선언

패키지를 선언하려면 파일의 맨 위에 `package` 키워드를 사용하여 패키지 이름을 선언합니다. 예를 들어, 다음과 같이 선언할 수 있습니다.

```kotlin
package com.example.myproject
```

1. 패키지 내부에 코드 작성

패키지 내부에 코드를 작성하면 해당 코드는 패키지의 일부가 됩니다. 예를 들어, 다음과 같이 패키지 내부에 함수를 작성할 수 있습니다.

```kotlin
package com.example.myproject

fun myFunction() {
    // 함수 코드
}
```

코틀린에서 패키지의 가장 핵심적인 차이점은 이름 충돌을 방지하기 위해 **기본적으로 모든 패키지가 기본적으로 비공개(private)이며**, 공개(public) 패키지를 선언해야 다른 모듈에서 패키지를 사용할 수 있다는 점입니다. 이것은 자바와 다릅니다. 자바에서는 모든 패키지가 기본적으로 공개(public)이며, 다른 모듈에서 패키지를 사용하려면 `import` 문을 사용해야 합니다.



따라서, 코틀린에서는 모듈성을 제공하는 더 나은 패키지 시스템을 제공합니다. 모든 패키지가 기본적으로 비공개(private)이므로, 코드의 접근 범위를 더욱 세밀하게 제어할 수 있습니다. 그리고 공개(public) 패키지를 사용하여 다른 모듈에서 패키지를 사용할 수 있도록 설정할 수 있습니다. 이러한 패키지 시스템은 모듈 간의 코드 재사용성을 높이고, 이름 충돌 문제를 방지하는 데 도움이 됩니다.

---

### 11. 임포트 별명이란 무엇인가? 자바의 정적 임포트와 비슷한 임포트를 코틀린에서는 어떻게 처 리하는가?

코틀린에서 임포트 별명(Alias Import)은 다른 이름으로 임포트하는 것을 말합니다. 즉, 다른 이름으로 임포트하여 코드에서 별명으로 사용할 수 있습니다.

임포트 별명은 다음과 같이 선언할 수 있습니다.

```kotlin
import foo.Bar as Baz
```

위의 예제에서는 `foo` 패키지의 `Bar` 클래스를 `Baz`라는 이름으로 임포트합니다. 이제 `Baz`를 사용하여 `Bar` 클래스에 접근할 수 있습니다.

```kotlin
val myBar = Baz()
```

코틀린에서는 정적 임포트(Static Import)를 지원하지 않습니다. 대신, 패키지 수준 함수와 프로퍼티를 더욱 편리하게 사용할 수 있는 최상위 함수(Top-Level Function)와 최상위 프로퍼티(Top-Level Property)를 제공합니다.

최상위 함수와 프로퍼티를 사용하려면, 해당 함수나 프로퍼티가 선언된 패키지를 임포트하면 됩니다. 예를 들어, 다음과 같이 `kotlin.math` 패키지를 임포트하면 `kotlin.math.PI`와 같은 최상위 프로퍼티를 직접 사용할 수 있습니다.

```kotlin
import kotlin.math.PI

val circumference = 2 * PI * radius
```

위의 예제에서는 `kotlin.math.PI`를 `PI`로 축약하여 사용하였습니다.

따라서, 코틀린에서는 임포트 별명(Alias Import)을 사용하여 다른 이름으로 임포트하는 것을 지원합니다. 또한, 최상위 함수와 프로퍼티를 사용하여 정적 임포트를 대체할 수 있습니다.

---

### 12. if 문/식은 어떤 일을 하는가? 각각을 자바의 1f 문 및 3항 조건 연산자(?:)와 비교해보라.

코틀린에서 `if`는 조건 분기를 수행하는 데 사용됩니다. `if`는 두 가지 방식으로 사용할 수 있습니다.

1. `if` 문

`if` 문은 조건이 참인 경우에만 실행할 코드 블록을 실행합니다. 다음은 `if` 문의 예입니다.

```kotlin
if (x > y) {
    println("x is greater than y")
}
```

위의 코드에서는 `x`가 `y`보다 큰 경우에만 "x is greater than y"를 출력합니다.

1. `if` 식

`if` 식은 표현식(expression)이므로 값을 반환합니다. 즉, `if` 식은 값을 반환하는 조건 분기를 수행합니다. `if` 식의 형식은 다음과 같습니다.

```kotlin
kotlinCopy code
val max = if (x > y) x else y
```

위의 코드에서는 `x`가 `y`보다 큰 경우 `x`를 반환하고, 그렇지 않으면 `y`를 반환합니다. 따라서, `max`에는 두 값 중 큰 값이 할당됩니다.

자바에서는 `if` 문과 `?:`(삼항 조건 연산자)를 사용하여 조건 분기를 수행합니다. `if` 문은 코틀린의 `if` 문과 거의 동일합니다. 하지만 `?:` 연산자는 코틀린의 `if` 식과 유사하지만, 더욱 제한적입니다. `?:` 연산자는 `if` 문보다 덜 유연하며, 단순한 값을 반환할 때만 사용할 수 있습니다.

따라서, 코틀린의 `if`는 조건 분기를 수행하면서 값도 반환할 수 있는 더욱 강력한 기능을 제공합니다.

------

### 13. 코틀린 when vs 자바 switch

자바의 경우 조건에 해당되는 모든 케이스를 실행을 시키므로 break를 걸어야 하지만(이런 경우를 폴스루라고 한다.) 

코틀린은 조건에 해당되는 경우만 실행시키고 빠져 나간다.

여러 대안 중 하나를 선택한다는 점에서 자바 switch문과 비슷하다.

차이점 : when에서 임의의 조건식을 추가할 수 있지만 switch는 주어진 식의 여러가지 값 중 하나만 선택할 수 있다는 점

자바의 switch는 폴스루(fall-through)라는 의미를 제공한다. 어떤 조건을 만족할 때 프로그램이 해당 조건에 대응하는 문을 실행하고 명시적으로 break를 만날 때까지 그 이후의 모든 가지를 실행. 코틀린 when은 when 조건을 만족하는 가지만 실행하고 절대 폴스루를 하지 않는다.

```kotlin
fun numberDescription(n: Int): String = when {
  n == 0 -> "Zero"
  n == 1 || n == 2 || n == 3 -> "Small"
  n in 4..9 -> "Medium"
  n in 10..100 -> "Large"
  n !in Int.MIN_VALUE until 0 -> "Negative"
  else -> "Huge"
}
// n 값을 대상으로 하는 동등성, in, !in 뿐이니 아래처럼 사용 가능
fun numberDescription2(n: Int, max: Int = 100): String = when (n) {
  0 -> "Zero"
  1, 2, 3 -> "Small"
  in 4..9 -> "Medium"
  in 10..max -> "Large"
  !in Int.MIN_VALUE until 0 -> "Negative"
  else -> "Huge"
}
```

when 문을 실행하는 방법

* 대상 식을 평가한다. 계산한 값을 subj라고 하자

* 최초로 참인 조건을 찾을 때까지 각 가자의 조건을 코드에 나온 순서대로 평가한다. 이때 in/!in 가지는 subj가 왼쪽 피연산자인 식으로  취급하고 임의의 식 e 는 subj = e 로 취급한다.
* 참인 조건을 찾으면 그 가지의 문장을 실행한다. else가지가 있는 경우 참인 조건이 없으면 else를 실행한다.

* 한가지 안에 여러 조건을 콤마로 분리해 쓸 수 있다. `1, 2, 3 -> "Small"`. 각각의 조건을 OR 연산한것처럼 취급한다.



---

### 14﻿. ﻿자바 for (int 1 = 0; 1< 100; 1+t)와 같이 수를 세는 루프를 코틀린에서는 어떻게 구현하 는가?

코틀린에서는 `for` 루프를 다음과 같이 구현할 수 있습니다.

```kotlin
for (i in 0 until 100 step 1) {
    // 루프 본문
}
```

위의 예제에서는 `0`부터 `99`까지의 숫자를 세면서 루프를 실행합니다. `until` 함수는 범위(range)를 생성하는 함수로, 두 번째 인자로 전달된 값을 포함하지 않습니다. `step` 키워드는 루프에서 증가하는 값의 간격을 지정합니다. 기본적으로 `1`로 설정되며, 생략할 수 있습니다.

만약 루프에서 인덱스 값을 사용하지 않는 경우, 루프 변수 대신 `_`를 사용할 수 있습니다.

```kotlin
for (_ in 0 until 100) {
    // 루프 본문
}
```

또한, `downTo` 키워드를 사용하여 감소하는 루프를 만들 수도 있습니다.

```kotlin
for (i in 99 downTo 0 step 1) {
    // 루프 본문
}
```

위의 예제에서는 `99`부터 `0`까지 거꾸로 숫자를 세면서 루프를 실행합니다. `downTo` 함수는 감소하는 범위를 생성하는 함수입니다.

따라서, 코틀린에서는 `for` 루프를 자바와 유사하게 구현할 수 있지만, 더욱 간결하고 유연한 문법을 제공합니다.

---

### 15. 코틀린이 제공하는 루프 문에는 어떤 것이 있는가? while과 do.. While의 차이는 무엇인가? 코틀린 for 루프를 사용해야 하는 이유는 무엇인가?

1. `for` 루프

`for` 루프는 컬렉션(collection)이나 범위(range)를 반복하는 데 사용됩니다. `for` 루프의 문법은 다음과 같습니다.

```kotlin
for (item in collection) {
    // 루프 본문
}
```

`for` 루프는 반복할 컬렉션 또는 범위와 각 요소에 대한 변수를 선언합니다. 루프에서는 각 요소를 `item` 변수에 할당하여 루프 본문을 실행합니다.

1. `while` 루프

`while` 루프는 조건이 참인 동안 반복하는 데 사용됩니다. `while` 루프의 문법은 다음과 같습니다.

```kotlin
while (condition) {
    // 루프 본문
}
```

`while` 루프는 조건이 `true`인 동안 루프 본문을 반복 실행합니다.

1. `do..while` 루프

`do..while` 루프는 `while` 루프와 비슷하지만, 조건이 참인 경우 루프 본문을 먼저 한 번 실행하고 조건을 검사합니다. `do..while` 루프의 문법은 다음과 같습니다.

```kotlin
do {
    // 루프 본문
} while (condition)
```

`do..while` 루프는 루프 본문을 먼저 한 번 실행한 후 조건을 검사합니다. 조건이 `true`인 동안 루프 본문을 반복 실행합니다.

`while`과 `do..while` 루프의 차이는 루프 본문을 실행하는 시점입니다. `while` 루프는 조건이 `true`일 때 루프 본문을 실행하지 않지만, `do..while` 루프는 루프 본문을 최소한 한 번 실행합니다.



코틀린에서는 `for` 루프를 사용하는 것이 자바에 비해 더욱 간결하고 안전한 방법입니다.

 `for` 루프를 사용하면 인덱스 변수를 직접 관리하지 않아도 되므로, 잘못된 인덱스 값에 의한 오류를 방지할 수 있습니다. 

또한, `for` 루프는 범위나 컬렉션을 반복할 때 더욱 편리합니다.

따라서, 코틀린에서는 `for` 루프를 우선적으로 사용하는 것이 좋습니다. 

---

### 16. ﻿﻿﻿﻿break와 continue를 사용해 루프의 제어 흐름을 어떻게 변경할 수 있는가?



------

### 17. 예외 처리 과정을 전체적으로 설명하라. 자바와의 차이점은 무엇인가? try문이 어떻게 다른지 설명하라.

- 프로그램은 예외를 잡아내는 핸들러를 찾는다. 예외와 일치하는 핸들러가 있다면 예외 핸들러가 처리한다.
- 현재 함수 내부에서 핸들러를 찾을 수 없으면 함수 실행이 종료되고 함수가 스택에서 제거 된다. 그리고 호출한 쪽에서 핸들러 검색을 수행한다. 이런 경우를 호출자에게 전파했다고 말한다.
- 프로그램 진입접에 이를 때까지 예외를 잡아내지 못하면 현재 스레드가 종료된다.

코틀린은 `catch (FooException || BarException e) `와 같은 구문을 사용할 수 없다. 또한 자바는 try-catch문에서 도달 할 수 없는 죽은 코드를 허용하지 않지만 코틀린은 허용하며, 코틀린에서는 검사 예외와 비검사 예외를 구분하지 않는다.

그리고 코틀린에서는 try도 식으로 쓸 수 있다.

```kotlin
fun readInt(default: Int) = try {...}
```

