# 디자인 패턴의 아름다움

[CHAPTER 1 개요](#chapter-1-개요)
[1.1 코드 설계를 배우는 이유](#11-코드-설계를-배우는-이유)
[1.2 코드 품질 평가 방법](#12-코드-품질-평가-방법)
[1.3 고품질 코드를 작성하는 방법](#13-고품질-코드를-작성하는-방법)
[1.4 과도한 설계를 피하는 방법](#14-과도한-설계를-피하는-방법)

[CHAPTER 2 객체지향 프로그래밍 패러다임](#chapter-2-객체지향-프로그래밍-패러다임)
[2.1 객체지향이란 무엇인가?](#21-객체지향이란-무엇인가)
[2.2 캡슐화, 추상화, 상속, 다형성이 등장한 이유](#22-캡슐화-추상화-상속-다형성이-등장한-이유)
[2.3 객체지향 분석, 객체지향 설계, 객체지향 프로그래밍을 수행하는 방법](#23-객체지향-분석-객체지향-설계-객체지향-프로그래밍을-수행하는-방법)
[2.4 객체지향 프로그래밍, 절차적 프로그래밍, 함수형 프로그래밍의 차이](#24-객체지향-프로그래밍-절차적-프로그래밍-함수형-프로그래밍의-차이)
[2.5 객체지향 프로그래밍처럼 보이지만 실제로는 절차적 프로그래밍](#25-객체지향-프로그래밍처럼-보이지만-실제로는-절차적-프로그래밍)
[2.6 빈약한 도메인 모델에 기반한 전통적인 개발 방식은 OOP를 위반하는가?](#26-빈약한-도메인-모델에-기반한-전통적인-개발-방식은-oop를-위반하는가)
[2.7 추상 클래스와 인터페이스](#27-추상-클래스와-인터페이스)
[2.8 인터페이스 기반 프로그래밍: 모든 클래스에 대해 인터페이스를 정의해야 할까?](#28-인터페이스-기반-프로그래밍-모든-클래스에-대해-인터페이스를-정의해야-할까)
[2.9 상속보다 합성](#29-상속보다-합성)

[CHAPTER 3 설계 원칙](#chapter-3-설계-원칙)
[3.1 단일 책임 원칙](#31-단일-책임-원칙)
[3.2 개방 폐쇄 원칙](#32-개방-폐쇄-원칙)
[3.3 리스코프 치환 원칙](#33-리스코프-치환-원칙)
[3.4 인터페이스 분리 원칙](#34-인터페이스-분리-원칙)
[3.5 의존 역전 원칙](#35-의존-역전-원칙)
[3.6 KISS 원칙과 YAGNI 원칙](#36-kiss-원칙과-yagni-원칙)
[3.7 DRY 원칙](#37-dry-원칙)
[3.8 LoD](#38-lod)

[CHAPTER 4 코딩 규칙](#chapter-4-코딩-규칙)
[4.1 명명과 주석](#41-명명과-주석)
[4.2 코드 스타일](#42-코드-스타일)
[4.3 코딩 팁](#43-코딩-팁)

[CHAPTER 5 리팩터링 기법](#chapter-5-리팩터링-기법)
[5.1 리팩터링의 네 가지 요소: 목적, 대상, 시기, 방법](#51-리팩터링의-네-가지-요소-목적-대상-시기-방법)
[5.2 단위 테스트](#52-단위-테스트)
[5.3 코드 테스트 용이성](#53-코드-테스트-용이성)
[5.4 디커플링](#54-디커플링)
[5.5 리팩터링 예제](#55-리팩터링-예제)

[CHAPTER 6 생성 디자인 패턴](#chapter-6-생성-디자인-패턴)
[6.1 싱글턴 패턴 (1)](#61-싱글턴-패턴-1)
[6.2 싱글턴 패턴 (2)](#62-싱글턴-패턴-2)
[6.3 팩터리 패턴 (1)](#63-팩터리-패턴-1)
[6.4 팩터리 패턴 (2)](#64-팩터리-패턴-2)
[6.5 빌더 패턴](#65-빌더-패턴)
[6.6 프로토타입 패턴](#66-프로토타입-패턴)

[CHAPTER 7 구조 디자인 패턴](#chapter-7-구조-디자인-패턴)
[7.1 프록시 패턴](#71-프록시-패턴)
[7.2 데커레이터 패턴: Java IO 라이브러리의 기본 설계 사상 분석](#72-데커레이터-패턴-java-io-라이브러리의-기본-설계-사상-분석)
[7.3 어댑터 패턴](#73-어댑터-패턴)
[7.4 브리지 패턴](#74-브리지-패턴)
[7.5 퍼사드 패턴](#75-퍼사드-패턴)
[7.6 복합체 패턴](#76-복합체-패턴)
[7.7 플라이웨이트 패턴](#77-플라이웨이트-패턴)

[CHAPTER 8 행동 디자인 패턴](#chapter-8-행동-디자인-패턴)
[8.1 옵서버 패턴](#81-옵서버-패턴)
[8.2 템플릿 메서드 패턴 (1)](#82-템플릿-메서드-패턴-1)
[8.3 템플릿 메서드 패턴 (2)](#83-템플릿-메서드-패턴-2)
[8.4 전략 패턴](#84-전략-패턴)
[8.5 책임 연쇄 패턴](#85-책임-연쇄-패턴)
[8.6 상태 패턴](#86-상태-패턴)
[8.7 반복자 패턴 (1)](#87-반복자-패턴-1)
[8.8 반복자 패턴 (2)](#88-반복자-패턴-2)
[8.9 비지터 패턴](#89-비지터-패턴)
[8.10 메멘토 패턴](#810-메멘토-패턴)
[8.11 커맨드 패턴](#811-커맨드-패턴)
[8.12 인터프리터 패턴](#812-인터프리터-패턴)
[8.13 중재자 패턴](#813-중재자-패턴)



## CHAPTER 1 개요

### 1.1 코드 설계를 배우는 이유

#### 1.1.1 고품질의 코드 작성

너덜너덜해진 코드 : 네이밍 규칙, 불합리한 클래스 설계, 불분명환 계층화 모듈화 되어있는 코드

결국 이런 코드들은 유지보수에 더 어려움을 주게된다. 

#### 1.1.2 복잡한 코드 개발 다루기

소프트웨어 개발시 만나는 어려움

1. 매우 높은 수준의 기술이 필요한 경우 (자율주행, 비디오, 높은성능)
2. 복잡한 비즈니스를 갖춘 대규모 프로젝트 (물류, 금융, ERP)

단순히 기능을 구현하고 사용 가능한 코드를 만드는 것은 복잡하지 않을 수 있지만, 사용하기 쉬운 코드를 작성하는 것은 쉽지 않다.

다음과 같은 질문을 생각해본 적이 있는가?

**계층화와 하위 모듈화 방법은 무엇인가?**

- 계층화
  - 시스템을 논리적으로 구분하여 각 계층이 특정한 책임을 가지도록 함
  - 예: 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층
- 하위 모듈화
  - 복잡한 시스템을 작은 모듈로 나누어 관리
  - 각 모듈은 독립적으로 개발, 테스트, 유지보수 가능

**클래스를 어떻게 나누는 것이 좋은가?**

- 단일 책임 원칙 (SRP)
  - 클래스는 하나의 책임만 가지도록 설계
- 응집도와 결합도
  - 높은 응집력과 낮은 결합도를 유지
  - 클래스가 하나의 주요 기능을 중심으로 모여 있어야 하고, 다른 클래스와의 의존성을 최소화

**각 클래스에는 어떤 속성과 메서드가 있는가?**

- 속성
  - 클래스가 표현하는 객체의 상태를 나타내는 변수들
  - 예: `User` 클래스에는 `name`, `email` 등의 속성
- 메서드
  - 클래스가 수행할 수 있는 행동이나 동작을 정의
  - 예: `User` 클래스에는 `login()`, `logout()` 등의 메서드

**클래스 간의 상호 작용을 설계하는 방법은 무엇인가?**

- 의존성 주입 (Dependency Injection)
  - 클래스 간의 의존성을 줄이기 위해 사용하는 방법
- 메시지 전달
  - 객체는 서로 메시지를 주고받으며 상호 작용
  - 인터페이스를 통해 상호 작용하여 직접적인 의존성을 피함

**상속이나 연관을 사용하는 것이 옳은가?**

- 상속
  - 코드 재사용과 다형성을 제공하지만, 너무 많이 사용하면 클래스 간의 강한 결합을 초래
- 연관
  - 객체 간의 관계를 나타내며, 상속보다는 덜 강한 결합
  - 가능한 한 상속보다는 연관을 통해 객체 간의 관계를 맺는 것이 좋음

**인터페이스나 추상 클래스를 사용하는 것이 옳은가?**

- 인터페이스
  - 구현을 제공하지 않고, 클래스가 따라야 할 계약을 정의
  - 다중 상속이 필요할 때 유용
- 추상 클래스
  - 기본적인 구현을 제공하면서 일부 메서드를 추상 메서드로 정의하여 하위 클래스가 구현하도록 함
  - 공통적인 기능을 공유할 때 유용

**결합도가 높은 코드와 낮은 코드는 무엇인가?**

- 높은 결합도
  - 클래스 간의 의존성이 강하여 변경이 어려운 코드
  - 유지보수와 확장이 어렵음
- 낮은 결합도
  - 클래스 간의 의존성이 적어 변경이 쉬운 코드
  - 유지보수와 확장이 용이함

**디커플링 (Decoupling)을 달성하는 방법은 무엇인가?**

- 인터페이스 사용
  - 클래스 간의 의존성을 인터페이스로 변경하여 결합도를 낮춤
- 디자인 패턴
  - 전략 패턴, 옵저버 패턴 등을 사용하여 객체 간의 의존성을 줄임

**싱글턴 패턴이나 정적 메서드를 사용하는 것이 옳은가?**

- 싱글턴 패턴
  - 애플리케이션 내에서 하나의 인스턴스만 필요할 때 사용
  - 전역 상태를 만들 수 있어 신중하게 사용해야 함
- 정적 메서드
  - 상태를 가지지 않는 유틸리티 메서드에 유용
  - 객체 지향의 장점을 살리지 못하므로 남용하지 않아야 함

**객체를 생성할 때 팩터리 패턴을 사용하는 것이 옳은가?**

- 팩터리 패턴
  - 객체 생성 로직을 별도의 팩터리 클래스로 분리하여 코드의 유연성과 재사용성을 높임
  - 객체 생성의 복잡성을 숨기고, 객체 생성 방식을 변경할 때 유용

**가독성을 유지하면서 확장성을 향상하기 위해 디자인 패턴을 도입하는 방법은 무엇인가?**

- 디자인 패턴
  - 상황에 맞는 디자인 패턴을 적용하여 코드의 구조와 가독성을 향상
  - 예: 전략 패턴, 데코레이터 패턴, 옵저버 패턴 등을 적절하게 사용
- 코드 리뷰
  - 코드의 가독성과 확장성을 보장하기 위해 정기적으로 코드 리뷰를 실시
- 테스트
  - 단위 테스트와 통합 테스트를 통해 코드의 안정성과 확장성을 보장

#### 1.1.4 경력 개발에 필요한 기술

수석 엔지니어로 성장하고 높은 성과와 발전을 달성하길 원한다면 기본적인 능력 향상과 기본적인 지식 습득에 꾸준히 신경을 써야 한다.

프레임워크랑 아키텍처를 잘 설계한다고 해서 코드가 나쁘면 좋은 소프트웨어 엔지니어가 될 수 없다.

기술 리더로 성장하면, 프로젝트 전반적인 개발을 책임지고 진행상황, 효율성, 품질을 책임져야 한다. 

### 1.2 코드 품질 평가 방법

좋은 코드가 무엇인가 평가하려면 다음과 같은 질문에 대한 명확한 인식이 필요하다.

**어떤 코드가 높은 가독성을 가지는 코드인가?**

- **명확한 변수 및 함수 이름**: 변수와 함수의 이름이 그 역할과 목적을 명확하게 나타내는 경우. 예를 들어, `calculateTotalPrice`는 그 함수가 무엇을 하는지 명확히 알려줍니다.
- **일관된 코딩 스타일**: 코드의 스타일과 포맷이 일관된 경우. 들쑥날쑥한 들여쓰기, 불규칙한 줄바꿈 등은 가독성을 떨어뜨립니다. 코드 포맷터와 린터를 사용하여 일관성을 유지합니다.
- **적절한 주석과 문서화**: 코드의 의도와 복잡한 로직을 설명하는 주석이 잘 작성된 경우. 그러나 과도한 주석은 오히려 혼란을 줄 수 있습니다. 주석은 왜 (Why) 특정 방법을 선택했는지를 설명하는 데 집중해야 합니다.
- **단순한 로직**: 복잡한 로직을 단순하고 이해하기 쉽게 작성한 경우. 복잡한 로직을 작은 함수로 나누어 관리하는 것도 좋은 방법입니다. "Keep It Simple, Stupid (KISS)" 원칙을 따릅니다.
- **표준화된 네이밍 규칙**: 프로젝트 전반에 걸쳐 일관된 네이밍 규칙을 사용하는 경우. 예를 들어, camelCase, PascalCase, snake_case 등을 일관되게 사용하는 것입니다.

**어떤 종류의 코드가 확장과 유지 관리에 용이한가?**

- **모듈화된 코드**: 코드가 작은 모듈이나 클래스 단위로 분리되어 있는 경우. 각 모듈은 독립적으로 개발, 테스트, 유지보수될 수 있습니다. 모듈화는 코드의 재사용성과 이해도를 높입니다.
- **단일 책임 원칙 (SRP)**: 각 클래스나 모듈이 하나의 책임만 가지도록 설계된 경우. 이는 코드의 변경 영향을 최소화합니다. 예를 들어, 데이터 접근 로직과 비즈니스 로직을 분리합니다.
- **인터페이스와 추상 클래스 사용**: 구체적인 구현에 의존하지 않고 인터페이스나 추상 클래스를 사용하여 유연성을 높인 경우. 이는 새로운 기능 추가 시 기존 코드를 수정하지 않고도 확장이 가능하게 합니다.
- **의존성 주입 (Dependency Injection)**: 클래스 간의 의존성을 줄이기 위해 의존성 주입을 사용하는 경우. 이는 코드의 테스트 용이성과 유지 보수성을 높입니다. Spring의 IoC 컨테이너가 좋은 예입니다.
- **테스트 커버리지**: 단위 테스트, 통합 테스트 등이 잘 작성되어 있는 경우. 이는 코드 변경 시 기존 기능이 잘 유지되는지 확인할 수 있게 합니다. TDD(Test-Driven Development)를 실천합니다.

**가독성, 확장성, 유지 보수 사이의 관계는 무엇인가?**

- **가독성과 유지 보수**: 높은 가독성은 코드를 이해하기 쉽게 하여 유지 보수성을 높입니다. 이해하기 쉬운 코드는 버그 수정이나 새로운 기능 추가 시 혼란을 줄입니다.
- **확장성과 유지 보수**: 확장성이 높은 코드는 새로운 기능 추가 시 기존 코드를 최소한으로 수정하게 하여 유지 보수를 용이하게 합니다. 모듈화된 코드와 인터페이스 사용은 확장성과 유지 보수성을 높이는 주요 기법입니다.
- **가독성과 확장성**: 가독성이 높은 코드 구조는 코드의 확장성을 높이는 데 기여합니다. 명확하게 정의된 인터페이스와 모듈은 코드의 가독성을 높이고, 새로운 기능 추가 시 구조적인 변경을 최소화합니다.

**유지 보수는 정확히 어떤 것을 의미하는가?**

- **버그 수정**: 코드에 존재하는 오류를 발견하고 수정하는 것. 가독성이 높은 코드는 버그를 빠르게 발견하고 수정할 수 있게 합니다.
- **기능 추가**: 새로운 기능을 기존 코드에 추가하는 것. 확장성이 높은 코드는 새로운 기능 추가 시 기존 코드를 최소한으로 수정하게 합니다.
- **코드 리팩토링**: 코드의 내부 구조를 개선하여 유지 보수성과 가독성을 높이는 것. 이는 코드의 기능을 변경하지 않고도 코드를 더 쉽게 이해하고 확장할 수 있게 합니다.
- **성능 최적화**: 코드의 성능을 개선하여 효율성을 높이는 것. 이는 코드의 응답 시간, 메모리 사용량 등을 최적화하는 작업을 포함합니다.
- **문서 업데이트**: 코드의 변경 사항에 따라 관련 문서와 주석을 업데이트하는 것. 이는 개발자가 코드의 변경 사항을 쉽게 이해하고 따라갈 수 있게 합니다.

실제로 코드 품질에 대한 설명에는 '좋음, 나쁨과 같은 비교적 간단하고 일반적인 설명 방법 외에 도 다음과 같이 의미가 풍부하고 전문적이며 상세한 설명 방법이 많이 있다.



#### 1.2.1 유지 보수성

유지보수성이 높다는 의미는 기존 코드 설계를 손상시키거나 새 버그를 발생시키지 않고도 빠르게 코드 수정 및 추가할 수 있는 상태이다.

유지보수가 쉽지 않다는 코드 변경, 추가시 버그가 발생할 위험이 크고 수정에 오래걸리는것을 의미한다. 

코드가 간결하고 가독성, 확작성이 높다면 유지보수도 쉬워지며,

명확하게 계층화 되어있고, 높은 모듈성, 높은 응집도와 낮은 결합도를 가지고 인터페이스 기반 설계 원칙 고수시 유지 보수가 쉬워진다. 



#### 1.2.2 가독성

코드의 가독성을 어떻게 판단할 수 있을까?

* 코드 명명이 의미가 있는지
* 주석이 자세히 기술되어 있는지
* 함수 길이는 적절한지
* 모듈 구분이 명확한지
* 높은 응집도와 낮은 결합도를 가지는지 

#### 1.2.3 확장성

기존 코드를 약간 수정하는것만으로, 전혀 수정하지 않고도 확장을 통해 새로운 기능을 추가하는것.

설계 당시부터 고려되어 확장용 인터페이스가 이미 존재함을 의미. 

확장성이 높으면 새로운 기능 코드를 추가할 때 대량 수정 없이 바로 추가 가능한다. 

유지보수성에 크게 관여한다. 

#### 1.2.4 유연성

코드가 유연하다는 광범위한 표현을 가진다.

1. 기존 코드에 확장을위한 인터페이스가 준비되어 있어 기존 코드 수정 없이 새로운 코드를 추가하기만 하면 됌.
2. 함수를 구현할 때 재사용 가능한 많은 모듈과 클래스 등이 기존 코드에 추상된 형태로 제공됨
3. 클래스를 사용할 때 클래스가 다양한 사용 시나리오에 대응하고 다양한 요구를 충족 가능.

#### 1.2.5 간결성

Keep It Simple, Stupid : KISS

가능한 한 단수하게 유지하라는 간결성을 의미. 

#### 1.2.6 재사용성

반복적인 코드 작성을 최소화하고 기존 코드를 재사용하는것으로 이해 가능. 

상속과 다형성의 목적중 하나가 재사용성을 향상시키는것. 

#### 1.2.7 테스트 용이성

테스트 용이성이 낮으면 품질도 나쁠뿐더러 설계가 문제가 있음을을 보여준다. 

### 1.3 고품질 코드를 작성하는 방법

#### 1.3.5 리팩터링 기법

1. ﻿﻿﻿리팩터링의 목적why, 대상what, 시기when, 방법how
2. ﻿﻿﻿리팩터링에 오류가 없는지 확인하기 위한 기술적 수단: 단위 테스트, 코드 테스트 용이성
3. ﻿﻿﻿두 가지 다른 규모의 리팩터링: 대규모 고수준의 리팩터링과 소규모 저수준 리팩터링

### 1.4 과도한 설계를 피하는 방법

실제로 개발 경험이 많지 않은 초보자들은 디자인 패턴을 처음 배운 학생처럼 되는 경우가 많은 데, 문제를 구체적으로 분석할 줄 모르며, 손에 망치를 들고 어떤 것이 못인지 확인한다. 

어느 것이 올바른 것인지 알지 못한 채 각종 디자인 패턴을 적용해보는 것이다



디자인 패턴의 적용 목적은 디커플링, 즉 더 나은 구조를 사용하며 단일 책임을 위해

큰 코드조각을 작은 클래스로 분할하여 높은 응집도와 낮은 결합도의 특성을 충족하도록 하는것.

* 생성 디자인 패턴은 사용 코드에서 생성 코드를 분리하는것
* 구조 디자인 패턴은 다른 기능 코드를 분리하는것
* 행동 디자인 패턴은 다른 행동 코드를 분리하는것

디커플링의 주요 목적은 코드 복잡성을 처리하는것이다. 



## CHAPTER 2 객체지향 프로그래밍 패러다임

### 2.1 객체지향이란 무엇인가?

#### 2.1.1 객체지향 프로그래밍과 객체지향 프로그래밍 언어

객체지향 프로그래밍은 프로그래밍 패러다임 또는 스타일을 의미한다.

코드를 구성하는 기본 단위로 클래스 또는 객체를 사용하고, 코드 설계와 구현으로 캡슐화, 추상화 상속 다형성의 4가지 특성을 사용한다.

객체지향 프로그래밍 언어는 클래스 또는 객체 문법을 지원하며, 이 문법은 객체지향 프로그래밍의 4가지 특성인 캡슐화, 추상화, 상속, 다형성을 쉽게 구현할 수 있다. 

#### 2.1.2 엄격하게 정의되지 않은 객체지향 프로그래밍 언어

객체지향 프로그래밍과 객체지향 프로그래밍 언어를 나누어 정의할 필요가 없다.

추상화, 상속, 캡슐화, 다형성 4가지를 충족 못한다고 해서 객체지향 언어가 아니라고 할 수 없으며, 충족한다고 객체지향 언어라고 할 수도 없다. 클래스 또는 객체의 문법적 개념을 지원하고 코드 구성의 기본단위라면 객체지향 프로그래밍 언어라고 간주될 수는 있다. 

객체지향은 방법론이다. 

### 2.2 캡슐화, 추상화, 상속, 다형성이 등장한 이유

#### 2.2.1 캡슐화

캡슐화(encapsulation)는 정보 은닉 또는 데이터 액세스 보호라고도 하며, 접근 가능한 인터페이스를 제한하여 클래스가 제공하는 메서드를 통해서만 데이터에 대한 접근을 허가하는것.

클래스의 속성(property, field)에 대해 접근을 제한하지 않으면 유연성을 올리는것 처럼 보이지만 제어할 수 없게된다.

수정 논리가 이곳저곳 흩어지기 때문에 가독성, 유지보수성에 영향을 줄 수 있다. 

#### 2.2.2 추상화

추상화 특성은 인터페이스나 abstract와 같은 문법에 의존하지 않아도 구현할 수 있다. 

클래스의 메서드가 함수라는 문법을 통해 구현되기 때문에, 실제 코드의 구현 내용은 그 자체로 추상화되는 함수의 내부에 포함된다.

함수를 사용할 때, 함수가 내부적으로 어떻게 동작하는지 몰라도 이름, 인자, 반환값, 주석을 통해 확인하면 바로 사용할 수 있기 때문이다.

따라서 추상화는 객체지향의 특이성이 그리 높지 않으며, 이로 인해 객체지향 프로그래밍의 특성으로 간주되지 않는 경우가 있다.

#### 2.2.3 상속

고양이는 포유류의 일종이다 처럼 is-a 관계를 나타내는데 사용된다.

상속의 가장 큰 역할은 코드의 재사용이라고 할 수 있다. 

과도하게 사용할 경우(게층 구조가 깊고 복잡해지면) 코드의 가독성과 유지 관리성이 떨어진다. 수정이 모든 클래스로 전파될 수 있기 때문이다. 그러므로 상속보단 합성이 나을 수 있다. 

#### 2.2.4 다형성

하위클래스를 상위클래스 대신 사용하고 하위 클래스의 메서드를 호출할 수 있는 특성을 의미한다. 



### 2.3 객체지향 분석, 객체지향 설계, 객체지향 프로그래밍을 수행하는 방법

#### 2.3.1 예제 소개와 난이도 분석

마이크로서비스의 인터페이스 호출.

인증기능을 설계하고 구현해야 한다. 



URL, AppID, 비밀번호, 시간값을 암호화하여 토큰을 생성한다.

그리고 인터페이스에 요청시 토큰, AppID, 시간, URL을 마이크로 서비스에 전달한다. 

인증처럼 비즈니스 연관성이 낮은 기능을 개발할 때는 특정 제품에 과도하게 의존하는것을 피하는것이 좋다

ApPID와 비밀번호를 저장하기 위해서 200Keeper, 로컬 파일, 자체 개발한 데이터 저장 방법, MysQL, Redis와 같은 다양한 저장 방식을 유연하게 지원하는 것이 이상적이다. 각 저장 방식에 대한 코드를 구현할 필요는 없지만, 시스템이 충분한 유연성과 확장성을 가지도록 설계하면, 이후 최소한의 코드 변경만으로 저장 방식을 변경할 수 있게 된다.

#### 2.3.3 객체지향 설계 방법

객체지향 설계 프로세스는 다음과 같이 4단계로 구분할 수 있다

1. ﻿﻿﻿책임과 기능을 나누고 어떤 클래스가 있는지 확인한다.
2. ﻿﻿﻿클래스를 정의하고, 클래스의 속성과 메서드를 정의한다.
3. ﻿﻿﻿클래스 간의 상호 작용을 정의한다.
4. ﻿﻿﻿클래스를 연결하고 실행 엔트리 포인트를 제공한다.

이제 앞에서 분석한 인증 기능의 객체지향 설계를 이 4단계를 통해 구현해보자.

- ﻿﻿인터페이스 요청 시 URL, AppID, 비밀번호, 시간값을 생성하고, 암호화 알고리즘을 통해 토큰 을 생성한 후, 생성된 토큰, URL, APpID, 시간값을 마이크로 서비스에 전달한다.
- ﻿﻿마이크로 서비스는 인터페이스 요청을 받으면, 이 요청에서 토큰, AppID, 시간값을 추출한다.
- ﻿﻿마이크로 서비스는 전달된 시간값과 현재의 시간값이 토큰의 유효 시간 범위 내에 있는지 확 인하고, 유효 시간이 만료되었다면 인증에 실패한 것으로 간주해 인터페이스 호출 요청을 거부 한다.
- ﻿﻿토큰이 만료되지 않은 경우 마이크로 서비스는 자체 저장소에서 AppID에 해당하는 비밀번호를 꺼내 동일한 토큰 생성 알고리즘으로 토큰을 생성하고 전달된 토큰과 비교한다. 토큰이 일치하 면 인증에 성공한 것이므로 인터페이스 호출이 허용되고, 그렇지 않으면 인터페이스 호출이 거 부된다.

단일책임으로 요구사항 명세를 분리.

1. ﻿﻿﻿URL, ApPID, 비밀번호, 시간값을 하나의 문자열로 만든다.
2. ﻿﻿﻿암호화 알고리즘을 이용하여 이 문자열을 암호화하여 토큰을 생성한다.
3. ﻿﻿﻿생성한 토큰, AppID, 시간값을 URL에 연결하여 새 URL을 만든다.
4. ﻿﻿﻿﻿URL을 파싱하여 토큰, ApPID, 시간값을 가져온다.
5. ﻿﻿﻿저장소에서 APPID와 연결된 비밀번호를 꺼낸다.
6. ﻿﻿﻿시간값을 기반으로 토큰의 만료 여부를 판단한다.
7. ﻿﻿﻿두 개의 토큰이 일치하는지 확인한다.



1,2,6,7 은 AuthToken클래스

3,4는 url 클래스 

5는 CredentialStorage 클래스로 나눌 수 있다 



**클래스간의 상호작용**

일반화(generalization)는 단순한 상속 관계로 이해될 수 있습니다. 다음 예제는 이를 Java로 표현한 것입니다:

```java
public class A { 
    // ... 
}

public class B extends A { 
    // ... 
}
```

실체화(realization)는 일반적으로 인터페이스와 구현 클래스 간의 관계를 나타냅니다. 다음 예제는 이를 Java로 표현한 것입니다:

```java
public interface A { 
    // ... 
}

public class B implements A { 
    // ... 
}
```

집합(aggregation)은 포함 관계입니다. 클래스 A의 객체에는 클래스 B의 객체가 포함됩니다. 

<u>이때 클래스 B의 객체 수명 주기는 클래스 A 객체의 수명 주기에 종속되지 않을 수 있습니다.</u> 

예를 들면 특정 강의와 학생의 관계와 비슷합니다. 다음의 예제는 이를 Java로 표현한 것입니다:

```java
public class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    // ...
}
```

합성(composition)은 포괄적인 관계입니다. 

<u>클래스 A의 객체는 클래스 B의 객체를 포함하지만, 이번에는 클래스 B의 객체 수명 주기가 클래스 A 객체의 수명 주기에 따라 달라집니다.</u> 

예를 들면 새와 날개의 관계와 같습니다. 다음의 예제는 이를 Java로 표현한 것입니다:

```java
public class A {
    private B b;

    public A() {
        this.b = new B();
    }
    // ...
}
```

연관(association)은 집합과 합성의 두 가지 속성을 모두 가지는 매우 약한 관계입니다. 다음 예제는 이를 Java로 표현한 것입니다:

```java
public class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    // ...
}
```

또는 다음과 같이 표현할 수도 있습니다:

```java
public class A {
    private B b;

    public A() {
        this.b = new B();
    }
    // ...
}
```

의존(dependency)은 연관 관계를 포함하며, 연관 관계보다 더 약한 관계입니다. 클래스 B의 객체가 클래스 A의 객체와 어떤 관계가 있을 경우, 이를 의존 관계라고 합니다. 다음 예제는 이를 Java로 표현한 것입니다:

```java
public class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    // ...
}
```

또는 다음과 같이 표현할 수도 있습니다:

```java
public class A {
    private B b;

    public A() {
        this.b = new B();
    }
    // ...
}
```



### 2.6 빈약한 도메인 모델에 기반한 전통적인 개발 방식은 OOP를 위반하는가?

DDD의 인기 이후 빈약한 도메인 모델을 기반으로 한 전통적 개발 방식이 비판받기 시작하고, 풍성한 도메인 모델에 기반한 DDD 방식이 옹호되기 시작했다.

다음 질문에 대해 생각해보자.

- ﻿﻿빈약한 도메인 모델을 기반으로 하는 전통적인 개발 패턴이 객체지향 프로그래밍을 위반하는 이유는 무엇일까?
- ﻿﻿빈약한 도메인 모델에 기반을 둔 전통적인 개발 방식은 객체지향 프로그래밍을 위반하는데도  왜 여전히 많이 사용되고 있을까?
- ﻿﻿풍성한 도메인 모델을 기반으로 하는 DDD 개발 방식은 언제 사용하는 것이 적합한가?

#### 2.6.1 빈약한 도메인 모델에 기반한 전통적인 개발 방식

비즈니스 논리는 Service 클래스에 집중되어 있으며, Service를 이용해 BO(Businiess Object)를 운영하다.

즉 서비스 계층의 데이터와 비즈니스 논리는 두개의 클래스로 나뉜다. 

데이터만 포함하고, 비즈니스 논리는 포함하지 않는 Bo 같은 클래스를 빈약한 도메인 모델이라고 한다. 

* 빈약한 도메인 모델 데이터를 작업과 분리하고, 객체지향 프로그래밍의 캡슐화 특성을 파괴하는 일반적 절차적 프로그래밍 스타일에 속한다. 

#### 2.6.2 풍성한 도메인 모델에 기반한 DDD 개발 방식

rich domain model이란, 빈약한 도메인 모델에서 데이터와 비즈니스 논리가 별도의 클래스로 분리되는것과 달리,

**데이터와 비즈니스 논리가 하나의 클래스에 포함된다.** 따라서 객체지향 프로그래밍의 캡슐화 특성을 만족하며 전형적인 객체지향 프로그래밍에 속한다. 



DDD는 비즈니스 시스템을 분리하고, 비즈니스 모듈을 분할하고, 비즈니스 도메인 모델과 상호 작용을 정의하는 방법을 설계할 떄 사용된다.

풍성한 도메인 모델으로 하는 DDD 개발 방식에서의 서비스 계층은 Service 클래스와 Domain 클래스로 두 부분으로 구성되며, Domain 클래스는 빈약한 도메인 모델의 BO 클래스에 해당한다. 



### 풍성한 도메인 모델이 비즈니스 논리가 Domain에 옮겨졌는데 여전히 Service가 남아있는 이유는 무엇일까?

Service 클래스는 Domain 클래스와 달리 3가지 책임이 있다

1. 저장소 계층과의 통신을 담당한다. 도메인 모델을 저장소 계층, 인프라 계층, JPA, MyBatis와 같은 프레임워크가 분리하기 위해서.
2. 여러 도메인 모델의 비즈니스 논리를 결합한다. 
3. 기능과 무관한 타 시스템과의 상호 작용을 담당한다. 트랜잭션, 이메일보내기, 메시지, 로깅 등등

### 서비스는 풍성한 도메인으로 바뀌었어도 컨트롤러랑 저장소는 여전히 빈약한 도메인 모델이므로 풍성하게 변환해야 할까?

필요하지 않다. 컨트롤러 계층은 인터페이스를 노출시키는 역할을 하고 저장소 계층은 데이터베이스를 처리하는 역할을 하는데,

이 두 계층에는 많은 비즈니스 논리가 포함되어 있지 않다. 



저장소 계층의 Entity를 예로 들면, 빈약한 도메인 모델로 설계되면 객체지향 프로그래밍의 캡슐화를 위반하고 수정될 위험이 있지만 Entity의 수명주기는 제한되어 있다. 일반적으로 Entity는 서비스 계층에 전달되자마자 Domain 또는 Bo로 변환되어 처리되고 수명주기는 끝나므로 임의로 수정될 여지가 없다.

컨트롤러 계층의 VO는 DTO로 설계되는것이 합리적이다 

#### 2.6.4 빈약한 도메인 모델에 기반한 전통적인 개발 방식이 널리 사용되는 이유

1. 비즈니스는 비교적 단순하여서 굳이 복잡한 풍성한 도메인 모델을 신중하게 설계할 필요가 없다. 
2. 설계하기가 빈약한 도메인모델보다 훨씬 까다롭다. 때문에 미리 비즈니스 논리가 정리되어있어야 하지만 빈약한 도메인 모델은 초기에 데이터만 정의하고 수정해가면 되므로 해당 작업을 정의할 수 있다. 

3. 일반적인 사고방식은 자리잡으면 바꾸기 어렵다. 대부분 프로그래머의 마음에 있으므로 쉽게 바꾸기 어렵다. 

### 2.9 상속보다 합성

#### 2.9.1 상속이 더 이상 사용되지 않는 이유

간단히 말해서 상속의 가장 큰 문제는 상속 계층이 너무 깊고 상속 관계가 너무 복잡하기 때문에, 코드의 가독성과 유지 보수성에 영향을 미친다는 점이다.

특정 특징별로 기능을 분할하다 보면 너무도 많은 상위 클래스가 생기게 된다. 

* AbstractBird (새)
* AbstractFlyableBird, AbstractUnFlyableBirde....
* 날아다닌다 말고도 노래할 수 있다. 알을 낳을 수 있다가 추가된다면 ..?

#### 2.9.2 합성이 상속에 비해 나은 장점

합성, 인터페이스, 위임 이라는 세가지 기술적 방법을 통해 해결할 수 있다.

인터페이스는 특정한 작업의 속성이다

* 날아다닌다, 노래를한다, 알을낳는다 모두 작업 특성이다

인터페이스로 다 구현할 수도 있지만 위임 할 수도 있다.

```java
public class Ostrich implements Teetable, EggLayable {
  private TweetAbillty tweetAblility; // 합성
  private EggLayAbillity eggLayAbility; // 합성
  
  @Override
  public void tweet() {
    tweetAblility.tweet(); // 위임
  }
}
```

상속의 is-a관계는 합성과 인터페이스의 has-a 관계로 대체될 수 있으며

 다형성은 인터페이스를 사용하여 달성될 수 있고,

코드 재사용은 합성과 위임으로 목적을 달성할 수 있다. 



#### 2.9.3 합성을 사용할지 상속을 사용할지 결정하기

상속 단계가 2단계 이하로 비교적 얕아 복잡하지 않다면 상속을 사용할 수 있다.

시스템이 불안정하고 상속 계층이 깊고 복잡하면 상속 대신 합성을 사용하는것이 좋다. 



만약 함수의 입력 매개변수 유형을 변경할 수 없고, 입력 매개변수가 인터페이스가 아닌 경우 상속을 사용해야만 다형성을 지원할 수 있는 케이스도 있다.

```java
public class FeignClient {
    // Feign Client 프레임 코드
    // ...일부 코드 생략.

    public void encode(String url) {
        // 기본 encode() 구현
        System.out.println("Encoding in FeignClient: " + url);
    }
}

public class CustomizedFeignClient extends FeignClient {
    @Override
    public void encode(String url) {
        // CustomizedFeignClient의 고유한 encode() 구현
        // 기본 encode() 구현과 동일하거나 추가 기능을 포함할 수 있음
        System.out.println("Encoding in CustomizedFeignClient: " + url);
    }
}

public class Demo {
    public void demofunction(FeignClient feignClient, String url) {
        // ...일부 코드 생략...
        feignClient.encode(url); // 다형성(polymorphism)을 이용하여 올바른 encode() 메서드 호출
        // ...일부 코드 생략...
    }

    public static void main(String[] args) {
        // CustomizedFeignClient 인스턴스를 생성하고
        FeignClient client = new CustomizedFeignClient();
        // demofunction을 호출하여 encode() 메서드를 실행
        new Demo().demofunction(client, "http://example.com");
    }
}
```







#### 2.9.4 생각해보기

## CHAPTER 3 설계 원칙

### 3.1 단일 책임 원칙

#### 3.1.1 단일 책임 원칙의 정의 및 해석

#### 3.1.2 클래스에 단일 책임이 있는지 판단하는 방법

#### 3.1.3 클래스의 책임이 가능한 한 자세하게 설명되어 있는지 여부

#### 3.1.4 생각해보기

### 3.2 개방 폐쇄 원칙

#### 3.2.1 확장할 때는 개방, 수정할 때는 폐쇄

#### 3.2.2 코드를 수정하는 것은 개방 폐쇄 원칙을 위반하는 것일까?

#### 3.2.3 확장할 때는 개방, 수정할 때는 폐쇄를 달성하는 방법

#### 3.2.4 프로젝트에 개방 폐쇄 원칙을 유연하게 적용하는 방법

#### 3.2.5 생각해보기

### 3.3 리스코프 치환 원칙

#### 3.3.1 리스코프 치환 원칙의 정의

#### 3.3.2 리스코프 치환 원칙과 다형성의 차이점

#### 3.3.3 리스코프 치환 원칙을 위반하는 안티 패턴

#### 3.3.4 생각해보기

### 3.4 인터페이스 분리 원칙

#### 3.4.1 API나 기능의 집합으로서의 인터페이스

#### 3.4.2 단일 API나 기능으로서의 인터페이스

#### 3.4.3 객체지향 프로그래밍에서의 인터페이스

#### 3.4.4 생각해보기

### 3.5 의존 역전 원칙

#### 3.5.1 제어 반전

#### 3.5.2 의존성 주입

#### 3.5.3 의존성 주입 프레임워크

#### 3.5.4 의존 역전 원칙

#### 3.5.5 생각해보기

### 3.6 KISS 원칙과 YAGNI 원칙

#### 3.6.1 KISS 원칙의 정의와 해석

#### 3.6.2 적은 줄 수의 코드가 더 간단하지 않다

#### 3.6.3 복잡한 코드가 반드시 KISS 원칙을 위반하는 것은 아니다

#### 3.6.4 KISS 원칙을 만족하는 코드 작성 방법

#### 3.6.5 YAGNI 원칙과 KISS 원칙의 차이

#### 3.6.6 생각해보기

### 3.7 DRY 원칙

#### 3.7.1 코드 논리의 중복

#### 3.7.2 기능적(의미론적) 중복

#### 3.7.3 코드 실행의 중복

#### 3.7.4 코드 재사용성

#### 3.7.5 생각해보기

### 3.8 LoD

#### 3.8.1 높은 응집도와 낮은 결합도에 대한 생각

#### 3.8.2 LoD의 정의

#### 3.8.3 정의 해석 및 첫 번째 예제 코드

#### 3.8.4 정의 해석 및 두 번째 예제 코드

#### 3.8.5 생각해보기

## CHAPTER 4 코딩 규칙

### 4.1 명명과 주석

#### 4.1.1 긴 이름과 짧은 이름

#### 4.1.2 문맥 정보를 사용한 명명 단순화

#### 4.1.3 비즈니스 용어집을 사용한 명명 통일

#### 4.1.4 명명은 정확하지만 추상적이어야 한다

#### 4.1.5 주석에 반드시 포함되어야 하는 것들

#### 4.1.6 주석이 많다고 좋은 것은 아니다

#### 4.1.7 생각해보기

### 4.2 코드 스타일

#### 4.2.1 클래스, 함수의 적절한 크기

#### 4.2.2 한 줄의 적절한 길이

#### 4.2.3 빈 줄을 활용한 코드 블록 구분

#### 4.2.4 4칸 들여쓰기 혹은 2칸 들여쓰기

#### 4.2.5 여는 중괄호는 어디에 놓여야 할까

#### 4.2.6 클래스의 멤버 순서

#### 4.2.7 생각해보기

### 4.3 코딩 팁

#### 4.3.1 복잡한 코드의 모듈화

#### 4.3.2 함수의 매개변수 관리

#### 4.3.3 함수의 플래그 매개변수 제거

#### 4.3.4 깊은 중첩 코드 제거

#### 4.3.5 설명 변수

#### 4.3.6 생각해보기

## CHAPTER 5 리팩터링 기법

### 5.1 리팩터링의 네 가지 요소: 목적, 대상, 시기, 방법

#### 5.1.1 리팩터링의 목적

#### 5.1.2 리팩터링의 대상

#### 5.1.3 리팩터링의 시기

#### 5.1.4 리팩터링의 방법

#### 5.1.5 생각해보기

### 5.2 단위 테스트

#### 5.2.1 단위 테스트에 대해

#### 5.2.2 단위 테스트 코드를 작성하는 이유

#### 5.2.3 단위 테스트를 설계하는 방법

#### 5.2.4 단위 테스트를 작성하기 어려운 이유

#### 5.2.5 생각해보기

### 5.3 코드 테스트 용이성

#### 5.3.1 테스트 가능한 코드를 작성하는 방법

#### 5.3.2 테스트가 불가능한 코드

#### 5.3.3 생각해보기

### 5.4 디커플링

#### 5.4.1 디커플링이 중요한 이유

#### 5.4.2 코드를 디커플링해야 하는지 판단하기

#### 5.4.3 코드 디커플링 방법

#### 5.4.4 생각해보기

### 5.5 리팩터링 예제

#### 5.5.1 ID 생성기의 요구 사항과 개발 배경

#### 5.5.2 사용 가능한 수준의 코드 구현

#### 5.5.3 코드 품질 문제를 찾는 방법

#### 5.5.4 가독성 향상을 위한 리팩터링

#### 5.5.5 코드 테스트 용이성 향상을 위한 리팩터링

#### 5.5.6 단위 테스트 코드 작성을 위한 리팩터링

#### 5.5.7 예외 처리를 위한 리팩터링

#### 5.5.8 생각해보기

## CHAPTER 6 생성 디자인 패턴

### 6.1 싱글턴 패턴 (1)

#### 6.1.1 싱글턴 패턴의 정의

#### 6.1.2 싱글턴 패턴의 구현

#### 6.1.3 싱글턴 패턴의 적용

#### 6.1.4 싱글턴 패턴의 단점

#### 6.1.5 싱글턴 패턴의 대안

#### 6.1.6 생각해보기

### 6.2 싱글턴 패턴 (2)

#### 6.2.1 싱글턴 패턴의 유일성

#### 6.2.2 스레드 전용 싱글턴 패턴

#### 6.2.3 클러스터 환경에서의 싱글턴 패턴

#### 6.2.4 다중 인스턴스 패턴

#### 6.2.5 생각해보기

### 6.3 팩터리 패턴 (1)

#### 6.3.1 단순 팩터리 패턴

#### 6.3.2 팩터리 메서드 패턴

#### 6.3.3 추상 팩터리 패턴

#### 6.3.4 팩터리 패턴의 적용 대상

#### 6.3.5 생각해보기

### 6.4 팩터리 패턴 (2)

#### 6.4.1 DI 컨테이너와 팩터리 패턴의 차이

#### 6.4.2 DI 컨테이너의 핵심 기능

#### 6.4.3 DI 컨테이너의 설계와 구현

#### 6.4.4 생각해보기

### 6.5 빌더 패턴

#### 6.5.1 생성자를 사용한 객체 생성

#### 6.5.2 setter 메서드를 사용한 멤버 변수 설정

#### 6.5.3 빌더 패턴을 이용한 매개변수 검증

#### 6.5.4 Guava에서 빌더 패턴 적용

#### 6.5.5 빌더 패턴과 팩터리 패턴의 차이

#### 6.5.6 생각해보기

### 6.6 프로토타입 패턴

#### 6.6.1 프로토타입 패턴의 정의

#### 6.6.2 프로토타입 패턴의 적용

#### 6.6.3 프로토타입 패턴의 구현

#### 6.6.4 생각해보기

## CHAPTER 7 구조 디자인 패턴

### 7.1 프록시 패턴

#### 7.1.1 인터페이스 기반의 프록시 패턴

#### 7.1.2 상속 기반의 프록시 패턴

#### 7.1.3 리플렉션 기반의 동적 프록시

#### 7.1.4 프록시 패턴의 활용 방법

#### 7.1.5 생각해보기

### 7.2 데커레이터 패턴: Java IO 라이브러리의 기본 설계 사상 분석

#### 7.2.1 Java IO 라이브러리의 특이한 사용 방법

#### 7.2.2 상속 기반 설계

#### 7.2.3 데커레이터 패턴 기반 설계 계획

#### 7.2.4 생각해보기

### 7.3 어댑터 패턴

#### 7.3.1 클래스 어댑터와 객체 어댑터

#### 7.3.2 어댑터 패턴의 응용

#### 7.3.3 자바 로깅과 어댑터 패턴

#### 7.3.4 래퍼 패턴

#### 7.3.5 생각해보기

### 7.4 브리지 패턴

#### 7.4.1 브리지 패턴의 정의

#### 7.4.2 브리지 패턴으로 폭발적인 상속 해결하기

#### 7.4.3 생각해보기

### 7.5 퍼사드 패턴

#### 7.5.1 퍼사드 패턴과 인터페이스 설계

#### 7.5.2 퍼사드 패턴의 응용: 인터페이스 사용성 개선하기

#### 7.5.3 퍼사드 패턴의 응용: 인터페이스 성능 향상하기

#### 7.5.4 퍼사드 패턴의 응용: 트랜잭션 문제 해결하기

#### 7.5.5 생각해보기

### 7.6 복합체 패턴

#### 7.6.1 복합체 패턴 기반의 디렉터리 트리

#### 7.6.2 복합체 패턴 기반의 휴먼 트리

#### 7.6.3 생각해보기

### 7.7 플라이웨이트 패턴

#### 7.7.1 체스 게임에서 플라이웨이트 패턴 적용

#### 7.7.2 텍스트 편집기에서 플라이웨이트 패턴 적용

#### 7.7.3 Java의 Integer에서 플라이웨이트 패턴 적용

#### 7.7.4 Java의 String에서 플라이웨이트 패턴 적용

#### 7.7.5 플라이웨이트 패턴과 싱글턴 패턴, 캐시, 오브젝트 풀의 차이

#### 7.7.6 생각해보기

## CHAPTER 8 행동 디자인 패턴

### 8.1 옵서버 패턴

#### 8.1.1 옵서버 패턴의 정의

#### 8.1.2 옵서버 패턴의 코드 구현

#### 8.1.3 옵서버 패턴의 의미

#### 8.1.4 옵서버 패턴의 적용

#### 8.1.5 비동기식 비차단 옵서버 패턴

#### 8.1.6 EventBus 프레임워크

#### 8.1.7 EventBus 프레임워크를 처음부터 구현하기

#### 8.1.8 생각해보기

### 8.2 템플릿 메서드 패턴 (1)

#### 8.2.1 템플릿 메서드 패턴의 정의와 구현

#### 8.2.2 템플릿 메서드 패턴의 역할: 재사용

#### 8.2.3 템플릿 메서드 패턴의 역할: 확장

#### 8.2.4 생각해보기

### 8.3 템플릿 메서드 패턴 (2)

#### 8.3.1 콜백의 원리와 구현

#### 8.3.2 JdbcTemplate 클래스

#### 8.3.3 setClickListener() 메서드

#### 8.3.4 addShutdownHook() 메서드

#### 8.3.5 템플릿 메서드 패턴과 콜백의 차이점

#### 8.3.6 생각해보기

### 8.4 전략 패턴

#### 8.4.1 전략 패턴의 정의와 구현

#### 8.4.2 전략 패턴으로 분기 결정 대체

#### 8.4.3 전략 패턴을 통한 파일 내용 정렬

#### 8.4.4 전략 패턴의 오용

#### 8.4.5 생각해보기

### 8.5 책임 연쇄 패턴

#### 8.5.1 책임 연쇄 패턴의 정의와 구현

#### 8.5.2 책임 연쇄 패턴 기반의 민감 단어 필터링

#### 8.5.3 책임 연쇄 패턴 기반의 서블릿 필터

#### 8.5.4 책임 연쇄 패턴과 Spring의 인터셉터

#### 8.5.5 책임 연쇄 패턴과 MyBatis 플러그인

#### 8.5.6 생각해보기

### 8.6 상태 패턴

#### 8.6.1 유한 상태 기계란 무엇인가

#### 8.6.2 분기 판단 방법으로 상태 머신 구현하기

#### 8.6.3 테이블 조회 방법으로 상태 머신 구현하기

#### 8.6.4 상태 패턴으로 상태 머신 구현하기

#### 8.6.5 생각해보기

### 8.7 반복자 패턴 (1)

#### 8.7.1 반복자 패턴의 정의와 구현

#### 8.7.2 컬렉션 순회 방법

#### 8.7.3 반복자의 문제

#### 8.7.4 반복자의 문제 해결

#### 8.7.5 생각해보기

### 8.8 반복자 패턴 (2)

#### 8.8.1 스냅숏 기능을 지원하는 반복자

#### 8.8.2 여러 복사본 기반의 설계 사상

#### 8.8.3 시간값 기반의 설계 사상

#### 8.8.4 생각해보기

### 8.9 비지터 패턴

#### 8.9.1 비지터 패턴의 도출 과정

#### 8.9.2 이중 디스패치

#### 8.9.3 생각해보기

### 8.10 메멘토 패턴

#### 8.10.1 메멘토 패턴의 정의 및 구현

#### 8.10.2 시간과 공간 최적화

#### 8.10.3 생각해보기

### 8.11 커맨드 패턴

#### 8.11.1 커맨드 패턴의 정의

#### 8.11.2 모바일 게임 서버에 커맨드 패턴 적용

#### 8.11.3 커맨드 패턴과 전략 패턴의 차이

#### 8.11.4 생각해보기

### 8.12 인터프리터 패턴

#### 8.12.1 인터프리터 패턴의 정의

#### 8.12.2 인터프리터 패턴으로 표현식 계산하기

#### 8.12.3 인터프리터 패턴으로 규칙 엔진 개발하기

#### 8.12.4 생각해보기

### 8.13 중재자 패턴

#### 8.13.1 중재자 패턴의 정의와 구현

#### 8.13.2 중재자 패턴과 옵서버 패턴의 차이점

#### 8.13.3 생각해보기
