# 목차

[toc]

- [1장. 코틀린이란 무엇이며, 왜 필요한가?](#1장-코틀린이란-무엇이며-왜-필요한가)
  - [코틀린의 주요 특성](#코틀린의-주요-특성)
    - [정적 타입 지정 언어](#정적-타입-지정-언어)
    - [함수형 프로그래밍과 객체지향 프로그래밍](#함수형-프로그래밍과-객체지향-프로그래밍)
  - [코틀린의 철학](#코틀린의-철학)
    - [실용성](#실용성)
    - [간결성](#간결성)
    - [안전성](#안전성)
    - [상호운용성](#상호운용성)
  - [코틀린 도구 사용](#코틀린-도구-사용)
    - [코틀린 코드 컴파일](#코틀린-코드-컴파일)
- [2장. 코틀린 기초](#2장-코틀린-기초)
  - [기본 요소: 함수와 변수](#기본-요소-함수와-변수)
    - [Hello, World!](#hello-world)
    - [함수](#함수)
    - [변수](#변수)
    - [더 쉽게 문자열 형식 지정: 문자열 템플릿](#더-쉽게-문자열-형식-지정-문자열-템플릿)
  - [클래스와 프로퍼티](#클래스와-프로퍼티)
    - [프로퍼티](#프로퍼티)
    - [커스텀 접근자](#커스텀-접근자)
    - [코틀린 소스코드 구조: 디렉터리와 패키지](#코틀린-소스코드-구조-디렉터리와-패키지)
  - [선택의 표현과 처리: enum과 when](#선택의-표현과-처리-enum과-when)
    - [enum 클래스 정의](#enum-클래스-정의)
    - [when으로 enum 클래스 다루기](#when으로-enum-클래스-다루기)
    - [when과 임의의 객체를 함께 사용](#when과-임의의-객체를-함께-사용)
    - [인자 없는 when 사용](#인자-없는-when-사용)
    - [스마트 캐스트: 타입 검사와 타입 캐스트를 조합](#스마트-캐스트-타입-검사와-타입-캐스트를-조합)
    - [리팩토링: if를 when으로 변경](#리팩토링-if를-when으로-변경)
    - [if와 when의 분기에서 블록 사용](#if와-when의-분기에서-블록-사용)
  - [대상을 이터레이션: while과 for 루프](#대상을-이터레이션-while과-for-루프)
    - [while 루프](#while-루프)
    - [숫자에 대한 이터레이션: 범위와 수열](#숫자에-대한-이터레이션-범위와-수열)
    - [맵에 대한 이터레이션](#맵에-대한-이터레이션)
    - [in으로 컬렉션이나 범위의 원소 검사](#in으로-컬렉션이나-범위의-원소-검사)
  - [코틀린의 예외 처리](#코틀린의-예외-처리)
    - [try, catch, finally](#try-catch-finally)
    - [try를 식으로 사용](#try를-식으로-사용)
  - [요약](#요약)
- [3장. 함수 정의와 호출](#3장-함수-정의와-호출)
  - [코틀린에서 컬렉션 만들기](#코틀린에서-컬렉션-만들기)
  - [함수를 호출하기 쉽게 만들기](#함수를-호출하기-쉽게-만들기)
    - [이름 붙인 인자](#이름-붙인-인자)
    - [디폴트 파라미터 값](#디폴트-파라미터-값)
    - [정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티](#정적인-유틸리티-클래스-없애기-최상위-함수와-프로퍼티)
  - [메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티](#메소드를-다른-클래스에-추가-확장-함수와-확장-프로퍼티)
    - [임포트와 확장 함수](#임포트와-확장-함수)
    - [자바에서 확장 함수 호출](#자바에서-확장-함수-호출)
    - [확장 함수로 유틸리티 함수 정의](#확장-함수로-유틸리티-함수-정의)
    - [확장 함수는 오버라이드 할 수 없다](#확장-함수는-오버라이드-할-수-없다)
    - [확장 프로퍼티](#확장-프로퍼티)
  - [컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원](#컬렉션-처리-가변-길이-인자-중위-함수-호출-라이브러리-지원)
    - [자바 컬렉션 API 확장](#자바-컬렉션-api-확장)
    - [가변인자 함수: 인자의 개수가 달라질 수 있는 함수 정의](#가변인자-함수-인자의-개수가-달라질-수-있는-함수-정의)
    - [값의 쌍 다루기: 중위 호출과 구조 분해 선언](#값의-쌍-다루기-중위-호출과-구조-분해-선언)
  - [문자열과 정규식 다루기](#문자열과-정규식-다루기)
    - [문자열 나누기](#문자열-나누기)
    - [정규식과 3중 따옴표로 묶은 문자열](#정규식과-3중-따옴표로-묶은-문자열)
    - [여러 줄 3중 따옴표 문자열](#여러-줄-3중-따옴표-문자열)
  - [코드 다듬기: 로컬 함수와 확장](#코드-다듬기-로컬-함수와-확장)
  - [요약](#요약)
- [4장. 클래스, 객체, 인터페이스](#4장-클래스-객체-인터페이스)
  - [클래스 계층 정의](#클래스-계층-정의)
    - [코틀린 인터페이스](#코틀린-인터페이스)
    - [open, final, abstract 변경자: 기본적으로 final](#open-final-abstract-변경자-기본적으로-final)
    - [가시성 변경자: 기본적으로 공개](#가시성-변경자-기본적으로-공개)
    - [내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스](#내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스)
    - [봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한](#봉인된-클래스-클래스-계층-정의-시-계층-확장-제한)
  - [뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언](#뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언)
    - [클래스 초기화: 주 생성자와 초기화 블록](#클래스-초기화-주-생성자와-초기화-블록)
    - [부 생성자: 상위 클래스를 다른 방식으로 초기화](#부-생성자-상위-클래스를-다른-방식으로-초기화)
    - [인터페이스에 선언된 프로퍼티 구현](#인터페이스에-선언된-프로퍼티-구현)
    - [게터와 세터에서 뒷받침하는 필드에 접근](#게터와-세터에서-뒷받침하는-필드에-접근)
    - [접근자의 가시성 변경](#접근자의-가시성-변경)
  - [컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임](#컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임)
    - [모든 클래스가 정의해야 하는 메소드](#모든-클래스가-정의해야-하는-메소드)
    - [데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성](#데이터-클래스-모든-클래스가-정의해야-하는-메소드-자동-생성)
    - [클래스 위임: by 키워드 사용](#클래스-위임-by-키워드-사용)
  - [object 키워드: 클래스 선언과 인스턴스 생성](#object-키워드-클래스-선언과-인스턴스-생성)
    - [객체 선언: 싱글턴을 쉽게 만들기](#객체-선언-싱글턴을-쉽게-만들기)
    - [동반 객체: 팩터리 메소드와 정적 멤버가 들어갈 장소](#동반-객체-팩터리-메소드와-정적-멤버가-들어갈-장소)
    - [동반 객체를 일반 객체처럼 사용](#동반-객체를-일반-객체처럼-사용)
    - [객체 식: 익명 내부 클래스를 다른 방식으로 작성](#객체-식-익명-내부-클래스를-다른-방식으로-작성)
  - [요약](#요약)
- [5장. 람다로 프로그래밍](#5장-람다로-프로그래밍)
  - [람다 식과 멤버 참조](#람다-식과-멤버-참조)
    - [람다 소개: 코드 블록을 함수 인자로 넘기기](#람다-소개-코드-블록을-함수-인자로-넘기기)
    - [람다와 컬렉션](#람다와-컬렉션)
    - [람다 식의 문법](#람다-식의-문법)
    - [현재 영역에 있는 변수에 접근](#현재-영역에-있는-변수에-접근)
    - [멤버 참조](#멤버-참조)
  - [컬렉션 함수형 API](#컬렉션-함수형-api)
    - [필수적인 함수: filter와 map](#필수적인-함수-filter와-map)
    - [all, any, count, find: 컬렉션에 술어 적용](#all-any-count-find-컬렉션에-술어-적용)
    - [groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경](#groupby-리스트를-여러-그룹으로-이뤄진-맵으로-변경)
    - [flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리](#flatmap과-flatten-중첩된-컬렉션-안의-원소-처리)
  - [지연 계산 lazy 컬렉션 연산](#지연-계산-lazy-컬렉션-연산)
    - [시퀀스 연산 실행: 중간 연산과 최종 연산](#시퀀스-연산-실행-중간-연산과-최종-연산)
    - [시퀀스 만들기](#시퀀스-만들기)
  - [자바 함수형 인터페이스 활용](#자바-함수형-인터페이스-활용)
    - [자바 메소드에 람다를 인자로 전달](#자바-메소드에-람다를-인자로-전달)
    - [SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경](#sam-생성자-람다를-함수형-인터페이스로-명시적으로-변경)
  - [수신 객체 지정 람다: with와 apply](#수신-객체-지정-람다-with와-apply)
    - [with함수](#with함수)
    - [apply함수](#apply함수)
  - [요약](#요약)
- [6장. 코틀린 타입 시스템](#6장-코틀린-타입-시스템)
  - [널 가능성](#널-가능성)
    - [널이 될 수 있는 타입](#널이-될-수-있는-타입)
    - [타입의 의미](#타입의-의미)
    - [안전한 호출 연산자: "?."](#안전한-호출-연산자-)
    - [엘비스 연산자 "?:"](#엘비스-연산자-)
    - [안전한 캐스트: as?](#안전한-캐스트-as)
    - [널 아님 단언: !!](#널-아님-단언-)
    - [let함수](#let함수)
    - [나중에 초기화할 프로퍼티](#나중에-초기화할-프로퍼티)
    - [널이 될 수 있는 타입 확장](#널이-될-수-있는-타입-확장)
    - [타입 파라미터의 널 가능성](#타입-파라미터의-널-가능성)
    - [널 가능성과 자바](#널-가능성과-자바)
  - [코틀린의 기본 타입](#코틀린의-기본-타입)
    - [기본 타입: Int, Boolean 등](#기본-타입-int-boolean-등)
    - [널이 될 수 있는 기본 타입: Int?, Boolean? 등](#널이-될-수-있는-기본-타입-int-boolean-등)
    - [숫자 변환](#숫자-변환)
    - [Any, Any?: 최상위 타입](#any-any-최상위-타입)
    - [Unit 타입: 코틀린의 void](#unit-타입-코틀린의-void)
    - [Nothing 타입: “이 함수는 결코 정상적으로 끝나지 않는다.”](#nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다)
  - [컬렉션과 배열](#컬렉션과-배열)
    - [널 가능성과 컬렉션](#널-가능성과-컬렉션)
    - [읽기 전용과 변경 가능한 컬렉션](#읽기-전용과-변경-가능한-컬렉션)
    - [코틀린 컬렉션과 자바](#코틀린-컬렉션과-자바)
    - [컬렉션을 플랫폼 타입으로 다루기](#컬렉션을-플랫폼-타입으로-다루기)
    - [객체의 배열과 기본 타입의 배열](#객체의-배열과-기본-타입의-배열)
- [7장. 연산자 오버로딩과 기타 관례](#7장-연산자-오버로딩과-기타-관례)
  - [산술 연산자 오버로드](#산술-연산자-오버로드)
    - [이항 산술 연산 오버로딩](#이항-산술-연산-오버로딩)
    - [복합 대입 연산자 오버로딩](#복합-대입-연산자-오버로딩)
    - [단항 연산자 오버로딩](#단항-연산자-오버로딩)
  - [비교 연산자 오버로딩](#비교-연산자-오버로딩)
    - [동등성 연산자: "equals"](#동등성-연산자-equals)
    - [순서 연산자: compareTo](#순서-연산자-compareto)
  - [컬렉션과 범위에 대해 쓸 수 있는 관례](#컬렉션과-범위에-대해-쓸-수-있는-관례)
    - [인덱스로 원소에 접근: get과 set](#인덱스로-원소에-접근-get과-set)
    - [in관례](#in관례)
    - [rangeTo관례](#rangeto관례)
    - [for 루프를 위한 iterator 관례](#for-루프를-위한-iterator-관례)
  - [구조 분해 선언과 component 함수](#구조-분해-선언과-component-함수)
    - [구조 분해 선언과 루프](#구조-분해-선언과-루프)
  - [프로퍼티 접근자 로직 재활용: 위임 프로퍼티](#프로퍼티-접근자-로직-재활용-위임-프로퍼티)
    - [위임 프로퍼티 소개](#위임-프로퍼티-소개)
    - [위임 프로퍼티 사용: by lazy()를 사용한 프로퍼티 초기화 지연](#위임-프로퍼티-사용-by-lazy를-사용한-프로퍼티-초기화-지연)
    - [위임 프로퍼티 구현](#위임-프로퍼티-구현)
    - [위임 프로퍼티 컴파일 규칙](#위임-프로퍼티-컴파일-규칙)
    - [프로퍼티 값을 맵에 저장](#프로퍼티-값을-맵에-저장)
    - [프레임워크에서 위임 프로퍼티 활용](#프레임워크에서-위임-프로퍼티-활용)
  - [요약](#요약)
- [8장. 고차 함수: 파라미터와 반환 값으로 람다 사용](#8장-고차-함수-파라미터와-반환-값으로-람다-사용)
  - [고차 함수 정의](#고차-함수-정의)
    - [함수 타입](#함수-타입)
    - [인자로 받은 함수 호출](#인자로-받은-함수-호출)
    - [자바에서 코틀린 함수 타입 사용](#자바에서-코틀린-함수-타입-사용)
    - [디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터](#디폴트-값을-지정한-함수-타입-파라미터나-널이-될-수-있는-함수-타입-파라미터)
    - [함수를 함수에서 반환](#함수를-함수에서-반환)
    - [람다를 활용한 중복 제거](#람다를-활용한-중복-제거)
  - [인라인 함수: 람다의 부가 비용 없애기](#인라인-함수-람다의-부가-비용-없애기)
    - [인라이닝이 작동하는 방식](#인라이닝이-작동하는-방식)
    - [인라인 함수의 한계](#인라인-함수의-한계)
    - [컬렉션 연산 인라이닝](#컬렉션-연산-인라이닝)
    - [함수를 인라인으로 선언해야 하는 경우](#함수를-인라인으로-선언해야-하는-경우)
    - [자원 관리를 위해 인라인된 람다 사용](#자원-관리를-위해-인라인된-람다-사용)
  - [고차 함수 안에서 흐름 제어](#고차-함수-안에서-흐름-제어)
    - [람다 안의 return문: 람다를 둘러싼 함수로부터 반환](#람다-안의-return문-람다를-둘러싼-함수로부터-반환)
    - [람다로부터 반환: 레이블을 사용한 return](#람다로부터-반환-레이블을-사용한-return)
    - [무명 함수: 기본적으로 로컬 return](#무명-함수-기본적으로-로컬-return)
  - [요약](#요약)
- [9장. 제네릭스](#9장-제네릭스)
  - [제네릭 타입 파라미터](#제네릭-타입-파라미터)
    - [제네릭 함수와 프로퍼티](#제네릭-함수와-프로퍼티)
    - [제네릭 클래스 선언](#제네릭-클래스-선언)
    - [타입 파라미터 제약](#타입-파라미터-제약)
    - [타입 파라미터를 널이 될 수 없는 타입으로 한정](#타입-파라미터를-널이-될-수-없는-타입으로-한정)
  - [실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터](#실행-시-제네릭스의-동작-소거된-타입-파라미터와-실체화된-타입-파라미터)
    - [실행 시점의 제네릭: 타입 검사와 캐스트](#실행-시점의-제네릭-타입-검사와-캐스트)
    - [실체화한 타입 파라미터를 사용한 함수 선언](#실체화한-타입-파라미터를-사용한-함수-선언)
    - [실체화한 타입 파라미터로 클래스 참조 대신](#실체화한-타입-파라미터로-클래스-참조-대신)
    - [실체화한 타입 파라미터의 제약](#실체화한-타입-파라미터의-제약)
  - [변성: 제네릭과 하위 타입](#변성-제네릭과-하위-타입)
    - [변성이 있는 이유: 인자를 함수에 넘기기](#변성이-있는-이유-인자를-함수에-넘기기)
    - [클래스, 타입, 하위 타입](#클래스-타입-하위-타입)
    - [공변성: 하위 타입 관계를 유지](#공변성-하위-타입-관계를-유지)
    - [반공변성: 뒤집힌 하위 타입 관계](#반공변성-뒤집힌-하위-타입-관계)
    - [사용 지점 변성: 타입이 언급되는 지점에서 변성 지정](#사용-지점-변성-타입이-언급되는-지점에서-변성-지정)
    - [스타 프로젝션: 타입 인자 대신 * 사용](#스타-프로젝션-타입-인자-대신--사용)
  - [요약](#요약)
- [10장. 애노테이션과 리플렉션](#10장-애노테이션과-리플렉션)
  - [애노테이션 선언과 적용](#애노테이션-선언과-적용)
    - [애노테이션 대상](#애노테이션-대상)
    - [애노테이션을 활용한 JSON 직렬화 제어](#애노테이션을-활용한-json-직렬화-제어)
    - [애노테이션 선언](#애노테이션-선언)
    - [메타애노테이션: 애노테이션을 처리하는 방법 제어](#메타애노테이션-애노테이션을-처리하는-방법-제어)
    - [애노테이션 파라미터로 클래스 사용](#애노테이션-파라미터로-클래스-사용)
    - [애노테이션 파라미터로 제네릭 클래스 받기](#애노테이션-파라미터로-제네릭-클래스-받기)
  - [리플렉션: 실행 시점에 코틀린 객체 내부 관찰](#리플렉션-실행-시점에-코틀린-객체-내부-관찰)
    - [코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty](#코틀린-리플렉션-api-kclass-kcallable-kfunction-kproperty)
    - [리플렉션을 사용한 객체 직렬화 구현](#리플렉션을-사용한-객체-직렬화-구현)
    - [애노테이션을 활용한 직렬화 제어](#애노테이션을-활용한-직렬화-제어)
    - [JSON 파싱과 객체 역직렬화](#json-파싱과-객체-역직렬화)
    - [최종 역직렬화 단계: callBy(), 리플렉션을 사용해 객체 만들기](#최종-역직렬화-단계-callby-리플렉션을-사용해-객체-만들기)
  - [요약](#요약)
- [11장. DSL 만들기](#11장-dsl-만들기)
  - [API에서 DSL로](#api에서-dsl로)
    - [영역 특화 언어라는 개념](#영역-특화-언어라는-개념)
    - [내부 DSL](#내부-dsl)
    - [DSL의 구조](#dsl의-구조)
    - [내부 DSL로 HTML 만들기](#내부-dsl로-html-만들기)
  - [구조화된 API 구축: DSL에서 수신 객체 지정 DSL 사용](#구조화된-api-구축-dsl에서-수신-객체-지정-dsl-사용)
    - [수신 객체 지정 람다와 확장 함수 타입](#수신-객체-지정-람다와-확장-함수-타입)
    - [수신 객체 지정 람다를 HTML 빌더 안에서 사용](#수신-객체-지정-람다를-html-빌더-안에서-사용)
    - [코틀린 빌더: 추상화와 재사용을 가능하게 하는 도구](#코틀린-빌더-추상화와-재사용을-가능하게-하는-도구)
  - [invoke 관례를 사용한 더 유연한 블록 중첩](#invoke-관례를-사용한-더-유연한-블록-중첩)
    - [invoke 관례: 함수처럼 호출할 수 있는 객체](#invoke-관례-함수처럼-호출할-수-있는-객체)
    - [invoke 관례와 함수형 타입](#invoke-관례와-함수형-타입)
    - [DSL의 invoke 관례: 그레이들에서 의존관계 정의](#dsl의-invoke-관례-그레이들에서-의존관계-정의)
  - [실전 코틀린 DSL](#실전-코틀린-dsl)
    - [중위 호출 연쇄: 테스트 프레임워크의 should](#중위-호출-연쇄-테스트-프레임워크의-should)
    - [기본 타입에 대한 확장 함수 정의: 날짜 처리](#기본-타입에-대한-확장-함수-정의-날짜-처리)
    - [멤버 확장 함수: SQL을 위한 내부 DSL](#멤버-확장-함수-sql을-위한-내부-dsl)
    - [안코: 안드로이드 UI를 동적으로 생성하기](#안코-안드로이드-ui를-동적으로-생성하기)
  - [요약](#요약)

# 1장. 코틀린이란 무엇이며, 왜 필요한가?

코틀린은 간결하고 실용적이며, 자바 코드와의 상호운용성을 중시한다.  코틀린은 주목적은 현재 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생상적이며 안전한 대체 언어를 제공하는 것이다.

## 코틀린의 주요 특성

### 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳

### 정적 타입 지정 언어

자바와 마찬가지로 코틀린도 정적 타입 지정 언어다.

정적 타입 지정이 타입을 컴파일 시점에서 알 수 있고 프로그램 안에서 `객체 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증`해준다.

동적 타입 지정 언어에서는 타입과 관계 없이 모든 값을 변수에 넣을 수 있고, 메서드나 필드 접근에 대한 검증이 실행 시점에 일어나며, 그에 따라 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성하고 사용할 수 있다. 하지만 컴파일 시 걸러내지 못하고 런타임에 오류가 발생한다.

코틀린은 `컴파일러가 문맥으로 부터 변수 타입을 자동으로 유추`할 수 있기 때문에 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다. 

정적 타입의 지정의 장점은 다음과 같다.

- 성능 - 실행 시점에 어떤 메서드를 호출할지 알아내는 과정이 필요 없음으로 메소드 호출이 더 빠르다.
- 신뢰성 - 컴파일러가 프로그램 정확성을 검증하기 때문에 실행 시 프로그램 오류로 중단될 가능성이 더 적어진다.
- 유지보수 - 코드에서 다르는 객체가 어떤 타입에 속하는지 알수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- 도구 지원 - 정적 타입 지정을 활용하면 더 안전하게 리팩토링 할 수 있고, 도구는 더 정확한 코드 완성 기능을 제공할 수 있으며, IDE의 다른 지원 기능도 더 잘 만들수 있다.

### 함수형 프로그래밍과 객체지향 프로그래밍

함수형 프로그래밍의 핵심 개념

- 일급 시민(first-class) 함수 : 함수를 일반 값처럼 다룰 수 있다.
  - 함수를 변수에 저장하고 함수를 인자로 다른 함수에 전달할 수 있고 함수에서 새로운 함수를 만들어서 반환 할 수있다
- 불변성(immutability) : 함수형 프로그래밍에서는 불변 객체를 사용해 프로그램을 작성한다.
- 부수 효과(side effect) 가 없다.
  - 입력이 같으면 항상 같은 출력을 하고 다른 객체의 상태를 변경하지 않는다.
  - 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다

함수형 스타일의 장점

1. 간결성
   - 함수를 값처럼 활용 → 더 강력한 추상화 → 코드 중복 막을 수 있음
   - ex) 공통부분을 따로 함수로 뽑아내고 서로 다른 사항을 인자에 함수로 전달.

```kotlin
fun findAlice() = findPerson { it.name == "Alice" }
fun findBob() = findPerson { it.name == "Bob" }
```

2. 다중 스레드를 사용해도 안전하다 
   - 불변 데이터 구조를 사용하고 순수 함수를 그 데이터 구조에 적용한다면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다. (따라서 복잡한 동기화를 적용하지 않아도 된다)
3. 함수형 프로그램은 테스트하기 쉽다.
   - 순수함수는 준비 코드(setup code) 없이 독립적으로 테스트할 수 있다.

## 코틀린의 철학

### 실용성

코틀린은 연구를 위한 언어가 아니다. 다른 프로그래밍 언어가 채택한 이미 성공적으로 검증된 해법과 기능들을 구현하여

복잡도가 낮다. 

### 간결성

코틀린은 코드에서 의미 없는 부분을 줄이기 위해 많은 노력을 기울였다.

게터 세터 생성자 파라미터 필드 초기화 로직 등, 자바에 존재하는 여러 번거로운 코드를 묵시적으로 제공하기 대문에 지저분하지 않다. 

코드가 간결하면 읽고 쓰는데 시간이 덜 걸려 생산성을 향상시킨다. 

### 안전성

코틀린은 JVM에서 실행한다는 사실은 메모리, 버퍼 오버플로 방지 메모리 해제 등 안전성을 보장할 수 있다.. 

코틀린은 타입 시스템은 null이 될수 없는 값을 추적하며, 실행 시점에 NullPointerException이 발생할 수 있는 연산을 사용하는 코드를 금지한다.

```kotlin
var s2: String? = null // null이 될 수 있음
var s2: String = "" // null이 될 수 없음
```

또한 ClassCaseException을 방지하게 도와준다.

```kotlin
if (value is String) {
	print(value.toUpperCase())
}
```

### 상호운용성

자바 코드에서 코틀린 코드를 호출할 때도 아무런 노력이 필요 없다.

기존 자바 라이브러리를 가능하면 최대한 활용하며 자체 컬렉션 라이브러리를 제공하지 않고, 자바 표준 라이브러리 클래스에 의존한다.

## 코틀린 도구 사용

### 코틀린 코드 컴파일과정

1. **코틀린 소스코드**: 프로젝트에 작성된 `.kt` 파일들입니다.
2. **코틀린 컴파일러**: 코틀린 소스코드를 바이트코드로 변환하는 도구입니다.
3. **JVM 바이트코드**: 컴파일러에 의해 생성된 `.class` 파일들입니다. 이 바이트코드는 JVM(Java Virtual Machine)에서 실행될 수 있습니다.
4. **JVM**: 바이트코드를 실행하는 가상 머신입니다.

<img src="./images//image-20230929015407676.png">

코틀린 컴파일러로 컴파일한 코틀은 코틀린 런타임 라이브러리에 의존하므로 배포시 런타임 라이브러리도 함께 배포해야 한다

* 런타임 라이브러리에는 코틀린 자체 표준 라이브러리 클래스와 자바 API를 확장한 내용들이 있다.


# 2장. 코틀린 기초

## 기본 요소: 함수와 변수

### 함수

```kotlin
// 함수이름(파라미터): 리턴타입
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

- 함수의 선언은 fun 키워드로 시작
- 함수 이름 뒤에는 괄호 안에 파라미터 목록
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 위치, 단 괄호와 반환 타입 사이를 콜론으로 구분
  - 없는 경우 생략



**코틀린이 반환 타입을 생략할 수 있는 이유는 타입 컴파일러의 추론 때문이다.** 

식이 본문인 함수의 반환 타입만 생략 가능하다. 식의 결과 타입이 있을 수 있기 때문이다.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

### 문(statement)과 식(expression)의 구분

코틀린에서 if는 expression이지 statement가 아니다.

expression은 값을 만들어 내며, 다른 식의 하위 요소로 계산에 참여할 수 있는 반면

statement은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어 내지 않는다.

자바에서는 모든 제어구조가 statement이며 코틀린은 대부분 제어구조가 expression이다. 

### 변수

```kotlin
val answer = 42 // 타입을 명시 하지 않아도 됨
val answer: Int = 42 // 타입명시 
val yeaerToCompute = 7.5e6
```

cㅗ기화 식을 사용하지 않고 변수를 선언하려면 타입을 명시해야 한다

```kotlin
val answer: Int
asnwer = 42
```



타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입 변수 타입으로 지정한다.

```kotlin
var result = 10; // 변경 가능한 참조를 저장
val result = 10; // 변경 불가능한 참조를 저장

val str = "String"
str.add("string") // 값변경 가능
```

* val : value, 값 변경 불가능. final
* var : variable, 변수, 변경 가능함

`val` 참조는 자체는 불면일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.

어떤 블록이 실행될때 오직 1개만의 초기화가 실행된다면 조건에 따라 여러 값으로 초기화 가능

```kotlin
val message: String

if (a1()) {
  message = ""
}

else {
  message = "?"
}
```

### 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
    val name = if (agrs.SIZE > 0) args[0] else "kotlin"
    println("Hello, $name!")
}
```

인자가 없는 경우, 있는 경우에 따라 간단한 문자열 템플릿 만들수 있다.

컴파일 시점에 정적으로 식을 검사하기 때문에 컴파일 타임 에러 잡기가 가능하다. 

## 클래스와 프로퍼티



### 프로퍼티

**클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래에 가두는 것이다.** 

자바에서는 필드와 접근자를 한데 묶어 프로퍼티라고 부른다.

* 자바의 멤버 필드의 가시성은 보통 private 으로 선언하고 접근하기 위한 방법으로 접근자 메서드(accessor method)를 제공

코틀린의 프로퍼티는 자바와 같은 개념이며 기본 기능으로 제공한다.

또한 게터를 호출하는 대신 프로퍼티에 직접 접근한다. 메서드()를 사용하지 않는다  

```kotlin
class Person(
  val name: String,  // 읽기전용 프로퍼티. private field와 public getter 제공
  var isMarried: Boolean // 수정 가능 프로퍼티, private field와 public getter,setter 제공 
)

fun main() {
    val myPerson = Person("name", true)
    myPerson.name // myPerson.getName()
    myPerson.isMarried // myPerson.getIsMarried()
    myPerson.isMarried = false // myPerson.setIsMarried(false)

} 
```

### 커스텀 접근자

프로퍼티에는 프로퍼티 값을 저장하기 위한 필드가 있는데 이를 프로퍼티 backing filed(뒷받침)라고 한다.

```kotlin
class Rectangle(
  val height: Int, 
  val width: Int
) {
    val isSquare: Boolean
        get() { // 프로퍼티 getter 재정의
            return hieght = width
        }
}
```



## 선택의 표현과 처리: enum과 when

### enum 클래스 정의

```kotlin
 enum class Color(
    val r: Int, val g: Int, val b: Int
) {
    RED(255, 0, 0),
    ORANGE(255, 165, 0),
    YELLOW(255, 255, 0),
    GREEN(0, 255, 0),
    BLUE(0, 0, 255);  // 세미콜론 필수

    fun rgb() = (r * 256 * g) * 256 + b
}
```

- 코틀린에서 enum은 soft keyword. 즉 enum이란 키워드를 변수로도 사용 가능.
- class 앞에서는 enum 클래스를 의미하며  enum class가 없다면 키워드가 아니다
- enum에서도 일반적인 클래스와 마찬가지로 생성자와 프로퍼티를 선언
- `코틀린에서 유일하게 ; 이 필요한 곳이 enum이다.`



### when으로 enum 클래스 다루기

```kotlin
fun getMnemonic(color: Color) = 
    when (color) {
        Color.RED -> "Richard"
        Color.ORANGE -> "Of"
        Color.YELLOW -> "York"
        Color.GREEN -> "Gave"
        Color.BLUE -> "Battle"
        Color.INDIGO -> "In"
        Color.VIOLET -> "Vain"
    }
```

if와 마찬가지로 when도 식이며 함수의 반환 값으로 when 식을 직접 사용 가능하다. 

자바와 달리  break를 쓰지 않아도 된다.

한 분기 안에서 여러 값을 콤마로 분리 하여 사용 가능

```kotlin
fun getWarmth(color: Color) = when (color) {
    Color.RED, Color.ORANGE, Color.YELLOW -> "Warm"
    Color.GREEN -> "neutral"
    else -> "cold"
}
```

### when과 임의의 객체를 함께 사용



### 인자 없는 when 사용



### 스마트 캐스트: 타입 검사와 타입 캐스트를 조합



### 리팩토링: if를 when으로 변경



### if와 when의 분기에서 블록 사용



## 대상을 이터레이션: while과 for 루프

### while 루프

### 숫자에 대한 이터레이션: 범위와 수열

### 맵에 대한 이터레이션

### in으로 컬렉션이나 범위의 원소 검사

## 코틀린의 예외 처리

### try, catch, finally

### try를 식으로 사용

## 요약


# 3장. 함수 정의와 호출

## 코틀린에서 컬렉션 만들기

## 함수를 호출하기 쉽게 만들기

### 이름 붙인 인자

### 디폴트 파라미터 값

### 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

## 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

### 임포트와 확장 함수

### 자바에서 확장 함수 호출

### 확장 함수로 유틸리티 함수 정의

### 확장 함수는 오버라이드 할 수 없다

### 확장 프로퍼티

## 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

### 자바 컬렉션 API 확장

### 가변인자 함수: 인자의 개수가 달라질 수 있는 함수 정의

### 값의 쌍 다루기: 중위 호출과 구조 분해 선언

## 문자열과 정규식 다루기

### 문자열 나누기

### 정규식과 3중 따옴표로 묶은 문자열

### 여러 줄 3중 따옴표 문자열

## 코드 다듬기: 로컬 함수와 확장

## 요약


# 4장. 클래스, 객체, 인터페이스

## 클래스 계층 정의

### 코틀린 인터페이스

### open, final, abstract 변경자: 기본적으로 final

### 가시성 변경자: 기본적으로 공개

### 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스

### 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한

## 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

### 클래스 초기화: 주 생성자와 초기화 블록

### 부 생성자: 상위 클래스를 다른 방식으로 초기화

### 인터페이스에 선언된 프로퍼티 구현

### 게터와 세터에서 뒷받침하는 필드에 접근

### 접근자의 가시성 변경

## 컴파일러가 생성한 메소드: 데이터 클래스와 클래스 위임

### 모든 클래스가 정의해야 하는 메소드

### 데이터 클래스: 모든 클래스가 정의해야 하는 메소드 자동 생성

### 클래스 위임: by 키워드 사용

## object 키워드: 클래스 선언과 인스턴스 생성

### 객체 선언: 싱글턴을 쉽게 만들기

### 동반 객체: 팩터리 메소드와 정적 멤버가 들어갈 장소

### 동반 객체를 일반 객체처럼 사용

### 객체 식: 익명 내부 클래스를 다른 방식으로 작성

## 요약


# 5장. 람다로 프로그래밍

## 람다 식과 멤버 참조

### 람다 소개: 코드 블록을 함수 인자로 넘기기

### 람다와 컬렉션

### 람다 식의 문법

### 현재 영역에 있는 변수에 접근

### 멤버 참조

## 컬렉션 함수형 API

### 필수적인 함수: filter와 map

### all, any, count, find: 컬렉션에 술어 적용

### groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경

### flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리

## 지연 계산 lazy 컬렉션 연산

### 시퀀스 연산 실행: 중간 연산과 최종 연산

### 시퀀스 만들기

## 자바 함수형 인터페이스 활용

### 자바 메소드에 람다를 인자로 전달

### SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경

## 수신 객체 지정 람다: with와 apply

### with함수

### apply함수

## 요약


# 6장. 코틀린 타입 시스템

## 널 가능성

### 널이 될 수 있는 타입

### 타입의 의미

### 안전한 호출 연산자: "?."

### 엘비스 연산자 "?:"

### 안전한 캐스트: as?

### 널 아님 단언: !!

### let함수

### 나중에 초기화할 프로퍼티

### 널이 될 수 있는 타입 확장

### 타입 파라미터의 널 가능성

### 널 가능성과 자바

## 코틀린의 기본 타입

### 기본 타입: Int, Boolean 등

### 널이 될 수 있는 기본 타입: Int?, Boolean? 등

### 숫자 변환

### Any, Any?: 최상위 타입

### Unit 타입: 코틀린의 void

### Nothing 타입: “이 함수는 결코 정상적으로 끝나지 않는다.”

## 컬렉션과 배열

### 널 가능성과 컬렉션

### 읽기 전용과 변경 가능한 컬렉션

### 코틀린 컬렉션과 자바

### 컬렉션을 플랫폼 타입으로 다루기

### 객체의 배열과 기본 타입의 배열

6.4요약


2부. 코틀린답게 사용하기

# 7장. 연산자 오버로딩과 기타 관례

## 산술 연산자 오버로드

### 이항 산술 연산 오버로딩

### 복합 대입 연산자 오버로딩

### 단항 연산자 오버로딩

## 비교 연산자 오버로딩

### 동등성 연산자: "equals"

### 순서 연산자: compareTo

## 컬렉션과 범위에 대해 쓸 수 있는 관례

### 인덱스로 원소에 접근: get과 set

### in관례

### rangeTo관례

### for 루프를 위한 iterator 관례

## 구조 분해 선언과 component 함수

### 구조 분해 선언과 루프

## 프로퍼티 접근자 로직 재활용: 위임 프로퍼티

### 위임 프로퍼티 소개

### 위임 프로퍼티 사용: by lazy()를 사용한 프로퍼티 초기화 지연

### 위임 프로퍼티 구현

### 위임 프로퍼티 컴파일 규칙

### 프로퍼티 값을 맵에 저장

### 프레임워크에서 위임 프로퍼티 활용

## 요약


# 8장. 고차 함수: 파라미터와 반환 값으로 람다 사용

## 고차 함수 정의

### 함수 타입

### 인자로 받은 함수 호출

### 자바에서 코틀린 함수 타입 사용

### 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터

### 함수를 함수에서 반환

### 람다를 활용한 중복 제거

## 인라인 함수: 람다의 부가 비용 없애기

### 인라이닝이 작동하는 방식

### 인라인 함수의 한계

### 컬렉션 연산 인라이닝

### 함수를 인라인으로 선언해야 하는 경우

### 자원 관리를 위해 인라인된 람다 사용

## 고차 함수 안에서 흐름 제어

### 람다 안의 return문: 람다를 둘러싼 함수로부터 반환

### 람다로부터 반환: 레이블을 사용한 return

### 무명 함수: 기본적으로 로컬 return

## 요약


# 9장. 제네릭스

## 제네릭 타입 파라미터

### 제네릭 함수와 프로퍼티

### 제네릭 클래스 선언

### 타입 파라미터 제약

### 타입 파라미터를 널이 될 수 없는 타입으로 한정

## 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터

### 실행 시점의 제네릭: 타입 검사와 캐스트

### 실체화한 타입 파라미터를 사용한 함수 선언

### 실체화한 타입 파라미터로 클래스 참조 대신

### 실체화한 타입 파라미터의 제약

## 변성: 제네릭과 하위 타입

### 변성이 있는 이유: 인자를 함수에 넘기기

### 클래스, 타입, 하위 타입

### 공변성: 하위 타입 관계를 유지

### 반공변성: 뒤집힌 하위 타입 관계

### 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정

### 스타 프로젝션: 타입 인자 대신 * 사용

## 요약


# 10장. 애노테이션과 리플렉션

## 애노테이션 선언과 적용

### 애노테이션 대상

### 애노테이션을 활용한 JSON 직렬화 제어

### 애노테이션 선언

### 메타애노테이션: 애노테이션을 처리하는 방법 제어

### 애노테이션 파라미터로 클래스 사용

### 애노테이션 파라미터로 제네릭 클래스 받기

## 리플렉션: 실행 시점에 코틀린 객체 내부 관찰

### 코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty

### 리플렉션을 사용한 객체 직렬화 구현

### 애노테이션을 활용한 직렬화 제어

### JSON 파싱과 객체 역직렬화

### 최종 역직렬화 단계: callBy(), 리플렉션을 사용해 객체 만들기

## 요약


# 11장. DSL 만들기

## API에서 DSL로

### 영역 특화 언어라는 개념

### 내부 DSL

### DSL의 구조

### 내부 DSL로 HTML 만들기

## 구조화된 API 구축: DSL에서 수신 객체 지정 DSL 사용

### 수신 객체 지정 람다와 확장 함수 타입

### 수신 객체 지정 람다를 HTML 빌더 안에서 사용

### 코틀린 빌더: 추상화와 재사용을 가능하게 하는 도구

## invoke 관례를 사용한 더 유연한 블록 중첩

### invoke 관례: 함수처럼 호출할 수 있는 객체

### invoke 관례와 함수형 타입

### DSL의 invoke 관례: 그레이들에서 의존관계 정의

## 실전 코틀린 DSL

### 중위 호출 연쇄: 테스트 프레임워크의 should

### 기본 타입에 대한 확장 함수 정의: 날짜 처리

### 멤버 확장 함수: SQL을 위한 내부 DSL

### 안코: 안드로이드 UI를 동적으로 생성하기

## 요약