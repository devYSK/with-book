# 6 Redis Cluster 시스템 & 로그 모니터링

[toc]



# 6.1 복제 & 분산 시스템 개요

데이터를 분산 저장하려는 목적

**1. 자원 공유**

하나의 서버 자원은 제한적이며 과부하가 발생하는 경우, 다른 서버의 자원을 활용할 수 있기 때문에 효율적이다

**2. 성능 향상**

특정 노드에 과부하가 발생하는 경우, 다른 서버를 통해 자원 분배를 할 수 있기 때문에 로드밸런싱(Load Balancing)이 가능하다

**3. 안정성**

\- 복제 서버는 분산 서버에 장애가 발생하는 경우, 실시간으로 데이터를 복제해 두었다가 장애가 발생한 서버를 대체하여 작동되는 서버를 말한다

Redis Server는 

* 마스터-슬레이브(Master-Slave), 
* 마스터-슬레이브-센티널(Master-Slave-Sentinel), 
* 파티션 클러스터(Partition Cluster) 

기능을 통해 데이터를 복제하고 분산처리할 수 있다.

## 6.1.1 Partition 유형

1. Range Partition(범위 파티션)

Redis 서버에 저장되는 Key값을 특정 범위로 나눠 데이터들을 특정 파티션 서버로 분산 저장하는 개념

2. Hash Partition

Hash Alorithm에 의해 골고루 데이터를 분산 저장하는 개념

## 6.1.2 Partition 구현 방법

### 1. Client Side Partitioning

여러 대의 분산 서버를 구축할 때 각 서버에 저장될 데이터의 성격과 데이터 양을 사용자(클라이언트)가 직접 설계하고 결정하는 방법

Redis Server에서는 Master-Slave 또는 Redis Cluster Data Sharding 기능을 통해 구현할 수 있다.

### 2. Proxy Assisted Partitioning

사용자는 대량의 데이터를 입력할 때 어떤 분산 서버의 데이터 양이 가장 적은 지, 어떤 서버의 분산율이 가장 나쁜지 알 필요가 없는데 이것을 알아서 적절히 분산시켜준다.

**분산 서버 외에 별도로 Proxy Server가 추가로 필요**

*  Proxy Server는 현재 분산 서버의 모든 상태 정보를 수집 및 저장해주며, 사용자가 대량의 데이터에 대한 저장을 요구하는 경우 가장 적절한 분산 서버를 찾아서 데이터를 저장해준다

- Proxy Server는 별도의 분리된 서버에 구축하는 것을 권장한다

Redis 서버에서 기본적으로 제공해주지 않으므로 Twemproxy Cluster와 같은 오픈소스와 연동해서 구축해야 한다

**Twemproxy Cluster**

* Memcached와 ASCII와 Redis Protocol을 위해 트위터에서 개발 지원되는 솔루션

*  C로 개발되고, 단일 스레드를 지원하며 Apache 2.0 오픈소스

*  여러 개의 Redis 인스턴스에 자동 파티셔닝해주고, Redis를 Cache용으로 사용하는 경우에만 사용할 수 있다

### 3. Query Routing(해시 파티션)

데이터를 분산 저장해주고, 특정 분산 서버에 장애가 발생한 경우에 사용 가능한 Slave 서버를 통해 지속적인 읽기 작업이 가능하고, 사용 가능한 서버로 자동 전환(Redirection)해준다

오픈소스로 제공하는 redis-rb 또는 Predis 솔루션을 통해 구현할 수 있다

###  Redis Partition의 단점

1. Redis Server 환경에서는 Partitioning 기능을 이용한 분산 처리 기술의 사용은 적극적으로 권장하지 않는다

2개의 데이터 세트가 여러 개의 인스턴스에 동시에 저장되어 있는 경우, 효과적으로 처리하고 트랜잭션 제어까지 수행하는 것은 결코 쉬운 작업이 아니기 때문에 완벽하게 지원하지 않음



2. 새로운 노드를 추가하고, 기존 노드를 실시간으로 제거하는 작업은 하나의 큰 파티션 영역을 새롭게 분할하고 합병하는 작업이 빈번하게 요구된다

RDB와 AOF 파일을 백업하고 이전해야 하기 때문에 결코 쉬운 방법이 아니다.

3. 런타임 시 노드 추가와 제거 작업이 수행되는 단계에서 전체 서버의 균형을 맞추기 위한 ReBalancing 작업을 수행해야야 한다

처리 시 성능 지연 문제 및 예기치 못한 기술적 한계가 발생할 수 있다



# 6.2. Master & Slave & Sentinel

## 6.2.1 시스템 설정



### 마스터-슬레이브(Master-Slave)

사용자 데이터를 실시간으로 처리(입력/수정/삭제/조회)할 수 있는 Master 서버 1대에 대해 Slave 서버는 Master 서버의 데이터가 실시간으로 복제

Slave는 서버 Master 서버에 의해서만 쓰기 작업을 수행할 수 있고, 사용자는 오직 읽기 작업만 수행할 수 있다.

* 마스터 서버에 장애가 발생해도 슬레이브 서버는 마스터로 자동 전환(FailOver)되지 않는 단점이 있다.
* 사용자는 슬레이브 서버에 복제된 데이터를 이용하여 마스터 서버를 복구할 수는 있다.

### 마스터-슬레이브-센티널(Master-Slave-Sentinel) 

마스터-슬레이브의 단점을 해결을 위해 Slave 서버를 Master 서버로 전환시켜 지속적인 쓰기 및 읽기 작업이 가능하도록 하기 위한 아키텍처. 

이를 위해 Sentinel 서버를 추가로 구축해야 한다

Sentinel 서버는 Master 서버와 Slave 서버를 지속적으로 모니터링하다가 Master 서버에 장애가 감지된 경우, Slave 서버를 즉시 Master 서버로 자동 전환시켜 데이터 유실이 발생하지 않도록 Failover해준다.

Master 서버와 Slave 서버가 어떤 상태인지를 거의 실시간으로 HeartBeat를 통해 감시하고 관련 정보를 제공한다.

* 센티널 서버에는 데이터가 저장되지 않으며, 오직 마스터 서버와 슬레이브 서버의 장애 상태만을 모니터링 하는 역할을 수행한다
* 때문에 센티널 서버는 좋은 사양의 하드웨어가 필요 없지만, 센티넬 서버도 원본 센티넬의 장애가 발생할 수 있기 때문에 복제 센티널 서버를 구성하기도 한다.

###  일반 복제모드 - Redis Master 서버 1대, Slave 서버 1대, Setinel 서버 1대 구축 방법 

* 설정 공식문서 : https://redis.io/docs/management/config/

* slaveOf는 deprecated 되었다 : https://redis.io/commands/slaveof/
* replicaof 를 사용해야 한다 https://redis.io/commands/replicaof/

로컬 호스트 이기 때문에 도커로 진행한다.

```
Master   6379
Slave1   6380
Slave2   6381
Sentinel 6382
```

### **슬레이브 설정파일**

* 파일명 : redis.conf

* 아래 내용을 복사하면 된다

```
replicaof '마스터 노드 IP' '마스터 노드 PORT'

replica-read-only yes

# 슬레이브 서버에서 동기화 요청 후 동기화를 진행하기 전의 지연 시간 default는 5초이며 슬레이브 서버가 동기화 요청 후 5초 후에 마스터 서버는 동기화를 시작
repl-diskless-sync-delay 3

# 주기적으로 마스터node에 ping
repl-ping-replica-period 10

# 마스터 서버와 슬레이브 서버간에 연결이 끊겼다고 인식하는 시간이며, 이는 repl-ping-replica-period 로 설정된 값보다 커야
repl-timeout 60

masterauth '마스터 비밀번호'
requirepass '슬레이브 비밀번호'
```

만약 master가 로컬호스트의 도커 컨테이너인 경우, 다음 명령어로 IP를 찾아 마스터 노드 IP에 입력한다

```sh
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' '마스터 컨테이너 이름'
```

**센티넬 설정파일**

* 파일명 : sentinel.conf
* 센티넬의 기본 포트는 26379이다

```
# 센티널 서버가 바라볼 Master 서버정보 설정
# 참고 : http://redisgate.jp/redis/sentinel/sentinel_conf_han.php

# 문법 :  sentinel monitor <master-name> <redis-ip> <redis-port> <quorum>
# quorum(쿼럼)은 레디스 마스터 서버가 다운되었을 때 몇 개의 센티널이 다운되었는지 인지해야 객관적으로 다운되었다고 판정하는 기준


sentinel monitor mymaster 172.17.0.3 6379 1
sentinel auth-pass mymaster 1234

# 장애 발생시 FailOver Timeout
sentinel down-after-milliseconds mymaster 3000

# 로그파일 설정
logfile "/data/redis-sentinel.log"

# Generated by CONFIG REWRITE
latency-tracking-info-percentiles 50 99 99.9
port 26379
dir "/data"
user default on nopass ~* &* +@all
sentinel myid e2970af8569beb54139b82d510046767775ca8d9
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
sentinel current-epoch 0

sentinel known-replica mymaster 172.17.0.4 6379

sentinel known-replica mymaster 172.17.0.5 6379
```

**sentinel 서버 구축 관련 파라미터**

```
sentinel monitor mymaster 1.192.0.1 5000 1
```

* mymaster : Master 서버를 지칭하는 별칭(alias)

* 1.192.0.1 : Master 서버의 물리적 IP 주소

* 5000 : 마스터의 포트 번호

*  1 : Quirum(정족수)
  *  만약 Sentinel 서버가 3대인 경우, 이중에 2대 이상의 Sentinel에서 Master 서버가 Down된 상태를 인식하면 장애처리 작업을 수행함
  *  전체 3대 중에서  3 / 2 + 1 이상을 정족수라고 함
  *  Sentinel 서버가 2대이고, Quorum이 2일 때, Sentinel 서버 1대가 다운되더라도 Failover는 발생하지 않음

### 도커 실행 명령어

- 도커 컴포즈로도 작성 가능

```
-------// master
docker run -d \
--name redis-master  \
-p 6379:6379 \
-e TZ=Asia/Seoul \
-v /Users/ysk/dev/volume/redis-book/config/redis.conf:/usr/local/etc/redis/redis.conf \
-v /Users/ysk/dev/volume/redis-book/data:/data \
redis:latest redis-server /usr/local/etc/redis/redis.conf --requirepass 1234

-------// slave 1
docker run -d \
--name redis-slave1 \
-p 6380:6379 \
-e TZ=Asia/Seoul \
-v /Users/ysk/dev/volume/redis-slave1/config:/usr/local/etc/redis \
-v /Users/ysk/dev/volume/redis-slave1/data:/data \
redis:latest redis-server /usr/local/etc/redis/redis.conf
# 로컬에 /config 디렉토리 밑에 redis.conf 파일이 있다면
# 도커 컨테이너의 볼륨은 /usr/local/etc/redis 디렉토리로 지정

-------// slave 2
docker run -d \
--name redis-slave2 \
-p 6381:6379 \
-e TZ=Asia/Seoul \
-v /Users/ysk/dev/volume/redis-slave2/config:/usr/local/etc/redis \
-v /Users/ysk/dev/volume/redis-slave2/data:/data \
redis:latest redis-server /usr/local/etc/redis/redis.conf
# 로컬에 /config 디렉토리 밑에 redis.conf 파일이 있다면
# 도커 컨테이너의 볼륨은 /usr/local/etc/redis 디렉토리로 지정


-----// sentinel 1 포트 주의 
docker run -d \
--name redis-sentinel1 \
-p 6382:26379 \
-e TZ=Asia/Seoul \
-v /Users/ysk/dev/volume/redis-sentinel1/config:/usr/local/etc/redis \
-v /Users/ysk/dev/volume/redis-sentinel1/data:/data \
redis:latest redis-server /usr/local/etc/redis/sentinel.conf --sentinel
```

### DockerCompose -1

```yml
version: '3'
    
services:
  redis-master:
    image: redis:latest
    container_name: redis-master
    environment:
      - TZ=Asia/Seoul
    ports:
      - "6379:6379"
    volumes:
      - /Users/ysk/dev/volume/redis-master/config:/usr/local/etc/redis
      - /Users/ysk/dev/volume/redis-master/data:/data
    command: redis-server /usr/local/etc/redis/redis.conf --requirepass 패스워드

  redis-slave1:
    image: redis:latest
    container_name: redis-slave1
    environment:
      - TZ=Asia/Seoul
    ports:
      - "6380:6379"
    volumes:
      - /Users/ysk/dev/volume/redis-slave1/config:/usr/local/etc/redis
      - /Users/ysk/dev/volume/redis-slave1/data:/data
    command: redis-server /usr/local/etc/redis/redis.conf
    depends_on:
      - redis-master
      
  redis-slave2:
    image: redis:latest
    container_name: redis-slave2
    environment:
      - TZ=Asia/Seoul
    ports:
      - "6381:6379"
    volumes:
      - /Users/ysk/dev/volume/redis-slave2/config:/usr/local/etc/redis
      - /Users/ysk/dev/volume/redis-slave2/data:/data
    command: redis-server /usr/local/etc/redis/redis.conf
    depends_on:
      - redis-master
      - redis-slave1
      
  redis-sentinel1:
    image: redis:latest
    container_name: redis-sentinel1
    environment:
      - TZ=Asia/Seoul
    ports:
      - "6382:26379"
    volumes:
      - /Users/ysk/dev/volume/redis-sentinel1/config:/usr/local/etc/redis
      - /Users/ysk/dev/volume/redis-sentinel1/data:/data
    command: redis-server /usr/local/etc/redis/sentinel.conf --sentinel
    depends_on:
      - redis-master
      - redis-slave1
      - redis-slave2
```

### DockerCompose-2

```yml
version: '3'
networks:
  redis-network:
    driver: bridge

services:
  redis-master:
    image: redis:latest
    container_name: redis-master
    environment:
      - TZ=Asia/Seoul
      - REDIS_REPLICATION_MODE=master
      - ALLOW_EMPTY_PASSWORD=yes
    ports:
      - "6379:6379"
    volumes:
      - /Users/ysk/dev/compose/volume/redis-master/config/redis.conf:/usr/local/etc/redis/redis.conf
      - /Users/ysk/dev/compose/volume/redis-master/data:/data
    networks:
      - redis-network

  redis-slave1:
    image: redis:latest
    container_name: redis-slave1
    environment:
      - TZ=Asia/Seoul
      - REDIS_REPLICATION_MODE=slave
      - REDIS_MASTER_HOST=redis-master
      - ALLOW_EMPTY_PASSWORD=yes
    ports:
      - "6380:6379"
    volumes:
      - /Users/ysk/dev/compose/volume/redis-slave1/config:/usr/local/etc/redis
      - /Users/ysk/dev/compose/volume/redis-slave1/data:/data
    command: redis-server --replicaof redis-master 6379
    depends_on:
      - redis-master
    networks:
      - redis-network

  redis-slave2:
    image: redis:latest
    container_name: redis-slave2
    environment:
      - TZ=Asia/Seoul
      - REDIS_REPLICATION_MODE=slave
      - REDIS_MASTER_HOST=redis-master
      - ALLOW_EMPTY_PASSWORD=yes
    ports:
      - "6381:6379"
    volumes:
      - /Users/ysk/dev/compose/volume/redis-slave2/config:/usr/local/etc/redis
      - /Users/ysk/dev/compose/volume/redis-slave2/data:/data
    command: redis-server --replicaof redis-master 6379
    depends_on:
      - redis-master
      - redis-slave1
    networks:
      - redis-network

  # 센티넬 구성파일은 미리 생성되어있어야 합니다. 안그러면 센티넬 실행 안됌
  redis-sentinel1:
    image: redis:latest
    container_name: redis-sentinel1
    environment:
      - TZ=Asia/Seoul
      - REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS=3000
      - REDIS_MASTER_HOST=redis-master
      - REDIS_MASTER_PORT_NUMBER=6379
      - REDIS_MASTER_SET=master-name
      - REDIS_SENTINEL_QUORUM=1
    ports:
      - "6382:26379"
    volumes:
      - /Users/ysk/dev/compose/volume/redis-sentinel1/config:/usr/local/etc/redis
      - /Users/ysk/dev/compose/volume/redis-sentinel1/data:/data
    command: redis-server --sentinel
    depends_on:
      - redis-master
      - redis-slave1
      - redis-slave2
    networks:
      - redis-network


```





## Redis.Conf 작성법

```
# Redis 서버가 바인딩할 IP 주소 (모든 IP에 바인딩하려면 0.0.0.0 사용)
bind 127.0.0.1

# Redis 포트 번호
port 6379

# 비밀번호 설정
requirepass mysecretpassword

# 연결을 유지할 시간 (초 단위)
timeout 0

# 백그라운드에서 실행
daemonize no

# 로그 레벨 설정
loglevel notice

# 로그 파일 경로
logfile /var/log/redis/redis-server.log

# 데이터베이스의 수
databases 16

# RDB 스냅샷 파일 경로
dbfilename dump.rdb

# RDB 스냅샷을 저장할 디렉터리
dir /var/lib/redis

# RDB 스냅샷 생성 조건 (예: 10분마다 1번 변경된 키)
save 900 1

# 슬레이브 설정 (선택 사항)
slaveof <masterip> <masterport>
masterauth <master-password>

# 센티널 설정 (선택 사항)
sentinel monitor mymaster <masterip> <masterport> <quorum>
sentinel auth-pass mymaster <password>

# 기타 추가 설정 가능
```



성공한다면 

슬레이브 로그를 확인하면 다음과 같이 나온다

```
docker logs -f redis-slave1
```

결과

```
1:S 15 Aug 2023 20:01:12.668 * Connecting to MASTER 172.17.0.3:6379
1:S 15 Aug 2023 20:01:12.669 * MASTER <-> REPLICA sync started
1:S 15 Aug 2023 20:01:12.669 * Non blocking connect for SYNC fired the event.
1:S 15 Aug 2023 20:01:12.669 * Master replied to PING, replication can continue...
1:S 15 Aug 2023 20:01:12.669 * Partial resynchronization not possible (no cached master)
1:S 15 Aug 2023 20:01:17.355 * Full resync from master: 3729941e69f3207ec81d612bb8013e21986f4707:378
1:S 15 Aug 2023 20:01:17.377 * MASTER <-> REPLICA sync: receiving streamed RDB from master with EOF to disk
1:S 15 Aug 2023 20:01:17.384 * MASTER <-> REPLICA sync: Flushing old data
1:S 15 Aug 2023 20:01:17.385 * MASTER <-> REPLICA sync: Loading DB in memory
1:S 15 Aug 2023 20:01:17.399 * Loading RDB produced by version 7.0.9
1:S 15 Aug 2023 20:01:17.399 * RDB age 0 seconds
1:S 15 Aug 2023 20:01:17.399 * RDB memory usage when created 1.02 Mb
1:S 15 Aug 2023 20:01:17.399 * Done loading RDB, keys loaded: 0, keys expired: 0.
1:S 15 Aug 2023 20:01:17.399 * MASTER <-> REPLICA sync: Finished with success
```

**마스터 레디스에서 다음처럼 확인도 가능**

```
127.0.0.1:6379 : info replication
```

결과

```
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:2
slave0:ip=172.17.0.4,port=6379,state=online,offset=392,lag=0
slave1:ip=172.17.0.5,port=6379,state=online,offset=392,lag=0
```



**슬레이브 레디스에서 확인**

```sh
docker exec -it redis-slave1 redis-cli -a 

127.0.0.1:6379> info replication
```

결과

```
# Replication
role:slave						 # 현재 서버가 slave 인것을 확인
master_host:172.17.0.3 # 마스터 서버의 IP
master_port:6379			 # 마스터 서버의 port
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
```



**센티넬 레디스에서 확인**

```sh
> docker exec -it redis-sentinel1 redis-cli -p 26379

# 이 명령어로 확인
127.0.0.1:26379> info sentinel # 이 명령어로 확인
```

결과

```
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_tilt_since_seconds:-1
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
# 마스터 정보와 슬레이브 정보가 들어있다.
master0:name=mymaster,status=ok,address=172.17.0.3:6379,slaves=2,sentinels=1
```



명령어로 복제 확인

```
# 마스터 레디스
127.0.0.1:6379 : set foo bar
```

슬레이브 레디스에서 확인

```
# slave1 레디스
127.0.0.1:6379> get foo
"bar"

# slave2 레디스
127.0.0.1:6379> get foo
"bar"
```



### fail-over 테스트

마스터 서버를 shutdown 하면 sentinel 서버에 의해 slave 서버는 master 서버가 된다

먼저 마스터를 종료한다

```sh
docker stop redis-master
```

다음 slave1 서버로 접속해서 info replication 명령어를 입력하여 확인한다

```sh
> docker exec -it redis-slave1 redis-cli

127.0.0.1:6379> info replication
# Replication
role:master             # 마스터로 변경됌
connected_slaves:1      # 슬레이브가 1개가 됌 
slave0:ip=172.17.0.5,port=6379,state=online,offset=74131,lag=0
master_failover_state:no-failover
```

센티넬에서도 확인해보자

```
docker exec -it redis-sentinel1 redis-cli -p 26379
127.0.0.1:26379> info sentinel

# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_tilt_since_seconds:-1
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
# 172.17.0.4 는 원래 slave-1의 IP이다. 
master0:name=mymaster,status=ok,address=172.17.0.4:6379,slaves=2,sentinels=1
```

* http://redisgate.jp/redis/sentinel/sentinel.php



### 또다른 레디스 클러스터 구성 방법

* http://redisgate.kr/redis/configuration/redis_overview.php
* https://azderica.github.io/01-db-nosql-redis/

* https://co-de.tistory.com/15
* https://crazy-horse.tistory.com/entry/%EB%A0%88%EB%94%94%EC%8A%A4-%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A5%BC-%EB%8F%84%EC%BB%A4%EC%97%90%EC%84%9C-%EA%B5%AC%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90
* https://uchupura.tistory.com/56



## 6.2.2 장애 처리 방법

센티널 서버가 장애를 인지하고 failover 하는 절차

**1. Sentinel 서버는 매 1초마다 HeartBeat를 통해 Master 서버와 Slave 서버가 작동중인지 여부를 확인함**

**주관적 다운(Subjectively Down) 이라고 한다**

* 일정 타임아웃 동안 더 이상 응답이 없으면 장애가 발생한 것으로 간주함

* 로그 파일에 +sdown 상태로 표기됨

* 타임아웃 시간은 sentinel.conf 파일에 정의되어 있는 down-after-milliseconds 파라미터에 의해 결정됨(기본값 : 3000milliseconds)

**2. 객관적다운을 확인한다. 주관적 다운은 하나의 Sentinel 서버가 장애 상태를 인지한 경우를 말한다**

**객관적 다운(Objectively Down)**

*  Sentinel 서버가 여러 대인 경우, 모든 Sentinel 서버가 장애 상태를 인지하는 경우를 말한다

*  로그 파일에 +odown 상태로 표기됨

* Sentinel 서버는 Master 서버가 다운된 경우 다른 Sentinel 서버와 함께 전체 정족수(Quorum)를 확인한 다음 이에 미치지 못한 경우 최종적으로 실제 다운되었다고 판단함

**3. 주관적 다운과 객관적 다운이 최종 확인되면 장애 조치 작업을 단계별로 수행한다**

1. 여러 개의 Sentinel 서버로 구축되어 있는 경우, Sentinel 리더를 선출해야한다

내부에서는 선출과정이 반복적으로 수행되고 최종 Sentinel 리더가 선출된다

2. 리더로 결정된 Sentinel 서버는 장애가 발생한 Master 서버를 대신할 Slave 서버를 선정한다

3. 선정된 Slave 서버는 최종 Master 서버로 승격된다
4. 남은 Slave 서버가 새로운 Master 서버를 모니터링 하도록 명령을 수행한다.
5. 모든 작업이 완료되면 Sentinel 서버 정보를 갱신하고 장애 복구 작업을 종료한다.

### **특정 Sentinel 서버를 리더로 결정하는 방법**

우선순위가 결정될 수 있는 값을 부여할 수 있다.

3대의 Sentinel 서버가 구축되어 있는 경우, down-after-milliseconds는 주관적 다운 상태를 인지할 수 있도록 설정된 값으로, 값을 각각 다르게 설정해주면 첫번째 Sentinel 서버가 다운된 경우 1500값을 설정한 두번째 서버가 Sentinel 서버 리더가 될 수 있음

```
$ vi sentinel1.conf 
down-after-millisecodns 1000 

$ vi sentinel2.conf 
down-after-milliseconds 1500         # 장애 발생 시 Sentinel 서버 리더가 됨 

$ vi sentinel3.conf 
down-after-millisecodns 2000

```

### 특정 Slave 서버 중 Master가 될 수 있는 우선순위 결정 방법

* slave-priority 값이 중간이면 된다. 

```
$ vi redis_5000.conf
slave-priority 100

$ vi redis_5001.conf
slave-priority 102

$ vi redis_5002.conf
slave-priority 101        # 포트번호 5000 서버가 장애 발생 시 Master 서버가 됨
```

## 6.2.3 Setinel 명령어

**1. Sentinel 서버 상태와 Master, Slave 상태 조회**

```
127.0.0.1:5002> info sentinel
# Sentinel
sentinel_masters:1                   # Sentinel이 모니터링하고 있는 Master 서버수
sentinel_tilt:0                      # 0: 정상, 1 : 보호모드(모니터링만 수행, 장애조치 안함)
sentinel_running_scripts:0           # 실행 중인 스크립트 수
sentinel_scripts_queue_length:0      # 실행 대기 중인 스크립트 수
sentinel_simulate_failure_flags:0    # 장애 조치할 Sentinel 선정 수, 나머지는 다운
master0:name=mymaster,status=ok,address=127.0.0.1:5000,slaves=1,sentinels=1
# name: Master 서버명
# status : ok, sdown(주관적 다운), odown(객관적 다운)
# address : Master IP 주소와 포트번호
# slaves : Master에 등록된 Slave수
# sentinel : Master를 모니터링하는 Sentinel 서버수
```



**2. 서버 정보**

```
127.0.0.1:5002> info server
# Server
...
redis_mode:sentinel             # 해당 서버의 용도 : Sentinel 서버
...
tcp_port: 5002                  # Sentinel 서버의 포트 번호
...
hz:11                           # 10~19 사이 값이 랜덤하게 설정(Sentinel 리더 선출을 위한 정보)
...
```



**3. 포트 5002, 5001, 5000의 Redis 서버 용도 및 서버명**

```
127.0.0.1:5002> role
1) "sentinel"                  # Sentinel
2) 1) "mymaster"               # Master 서버명

127.0.0.1:5001> role
1) "slave"
2) "192.168.65.128"            # 포트 5001의 서버 용도
3) (integer) 5000
4) "connected"
5) (integer) 46637

127.0.0.1:5000> role
1) "master"                    # 포트 5000의 서버 용도
2) (integer) 48839
3) 1) 1) "192.168.65.129"
      2) "5001"
      3) "48839"
```



**4. 모니터링 설정된 Master 서버 해제 후, Sentinel 서버 상태 조회**

Sentinel 서버 상태 조회 시 마지막 라인에 상태 정보가 없음

```
127.0.0.1:5002> sentinel remove mymaster
OK

127.0.0.1:5002> info sentinel
# Sentinel
sentinel_masters:0
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
```



**6. Sentinel Master 서버 모니터링 및 Sentinel 서버 상태 조회**

\- Master 서버명 : mymaster

\- IP 주소와 포트

\- Quorum : 1

```
127.0.0.1:5002> sentinel monitor mymaster 192.168.65.128 5000 1
OK

127.0.0.1:5002> info sentinel
# Sentinel
sentinel_masters:1                       # 모니터링 중인 Master 서버수
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=192.168.65.128:5000,slaves=1,sentinels=1
```



**7. Sentinel 서버의 정족수(Quorum)를 2로 변경 후, Sentinel 서버 상태 조회**

```
127.0.0.1:5002> sentinel set mymaster quorum 2
OK

127.0.0.1:5002> info sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=192.168.65.128:5000,slaves=1,sentinels=1
```



**8. Sentinel 서버의 정족수(Quorum)를 1로 변경**

```
127.0.0.1:5002> sentinel set mymaster quorum 1
OK
```



**9. Sentinel 서버가 모니터링 중인 모든 Master 정보**

```
127.0.0.1:5002> sentinel masters
1) 1) "name"
   2) "mymaster"                         # Master 서버명
   3) "ip"
   4) "192.168.65.128"                   # Master 서버의 IP 주소
   5) "port"
   6) "5000"                             # Master 서버의 포트 번호
...
   9) "flags"
   10) "master"                          # master, slave, s_down, o_down 상태값
...
   21) "down-after-milliseconds"
   22) "30000"                           # Master 서버가 다운된 30초 이후 Failover
   23) "info-refresh"
   24) "1672"
   25) "role-reported"
   26) "master"
...
   31) "num-slaves"
   32) "1"                               # Slave 서버수
   33) "num-other-sentinels"
   34) "0"                               # Sentinel 서버수
   35) "quorum"
   36) "1"                               # 정족수(Quorum)
   37) "failover-timeout"
   38) "180000"
   39) "parallel-syncs"
   40) "1"
```



**10. Slave 서버 상태 조회**

```
127.0.0.1:5002> sentinel slaves mymaster
1) 1) "name"
   2) "192.168.65.129:5001"              # Slave 서버의 IP 주소와 포트번호
   3) "ip"
   4) "192.168.65.129"
   5) "port"
   6) "5001"
   7) "runid"
   8) ""
   9) "flags"
   10) "s_down,slave,disconnected"      # Slave 서버의 상태(s_down : 주관적 다운)
...
   39) "slave-priority"
   40) "100"                            # 낮은 값의 서버가 장애 발생 시 Master 선정
```



**11. Sentinel 상태 정보 초기화**

Master, Slave 정보 Refresh

```
127.0.0.1:5002> sentinel reset mymaster
(integer) 1
```



**12. 현재 설정된 Quorum 값의 적정 여부 체크**

```
127.0.0.1:5002> sentinel ckquorum mymaster
OK 1 usable Sentinals. Quorum and failover authorization can be reached
```



**13. 장애 처리 중 시뮬레이션 목적으로 Sentinel 서버를 임의 다운**

```
127.0.0.1:5002> sentinel simulate-failure crash-after-election
OK
```



**14. Slave 서버를 Master로 승격 후 Sentinel 서버를 임의 다운**

```
127.0.0.1:5002> sentinel simulate-failure crash-after-promotion
OK
```



**15. Sentinel 서버 상태 조회**

```
127.0.0.1:5002> info sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:2        # 각 단계별로 Sentinel 서버 임의 다운 횟수
master0:name=mymaster,status=ok,address=192.168.65.128:5000,slaves=1,sentinels=1
```



**16. Sentinel 서버의 임의 다운을 취소 후, Sentinel 서버 상태 조회**

```
127.0.0.1:5002> sentinel simulate-failure
OK

127.0.0.1:5002> info sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0        # 임의  다운 작업이 취소됨
master0:name=mymaster,status=ok,address=192.168.65.128:5000,slaves=1,sentinels=1
```



**17. Sentinel 서버의 환경 파라미터 값 변경**

```
127.0.0.1:5002> sentinel set mymaster down-after-milliseconds 1000
OK
127.0.0.1:5002> sentinel set mymaster failover-timeout 100000
OK
```



**18. Master 정보**

```
127.0.0.1:5002> sentinel masters
1) 1) "name"
   2) "mymaster"
   3) "ip"
   4) "192.168.65.128"
   5) "port"
   6) "5000"
...
   21) "down-after-milliseconds"
   22) "1000"                           # 기본값 3000에서 1000으로 변경
...
   37) "failover-timeout"
   38) "100000"                         # 기본값 180000에서 100000으로 변경
   39) "parallel-syncs"
   40) "1"
```



**19. sentinel.conf 파일에 변경된 값 반영**

``````
127.0.0.1:5002> sentinel flushconfig OK
``````



# 6.3 부분 동기화 - 패스 별거아님



# 6.4 Redis Cluster 구축 및 운영

## 6.4.1 Cluster 서버

하나의 Standalone 서버만으로 처리할 수 없을 만큼 빅데이터가 발생하는 비즈니스 환경에서는 성능 지연 문제 뿐만 아니라 다양한 장애 현상이 빈번하게 발생하게 된다

이를 클러스터링으로 해결한다.

데이터 분산 처리를 위한 파티셔닝 시스템과 안정성 확보를 위한 복제 시스템은 함께 사용될 수 밖에 없는데 Redis Cluster(Shard-Replication)라고 표현한다.

*  클러스터 환경에서는 Sentinel 서버는 요구되지 않는다고 한다?

 **Redis Cluster 시스템 구축 방법**

**1. Redis Cluster 명령어를 이용한 수동 설정 방법**

*  사용자가 직접 물리적 설계를 해야 한다

*  최적화된 Cluster 서버 환경을 구축할 수 있다

*  장애 발생 시 관리자의 의도에 따라 대응할 수 있다

**2) Redis-trib.rb 유틸리티를 이용한 자동 설정 방법**

*  자동화된 알고리즘을 통해 Cluster 서버를 구축할 수 있다

* Clsuter 구축 및 운용 관리에 대한 기술적 이해가 부족하더라도 구현 가능하다

*  장애 발생 시 자동화 알고리즘을 통해 시스템 재구성이 수행된다

**Redis Cluster의 특징**

1. Redis 3.0 버전부터 제공됨

2. Cluster 모드는 Database 0번만 사용할 수 있다

3. Cluster 모드에서는 mset 명령어를 실행할 수 없고, Hash-Tag를 통해 데이터를 표현할 수 있고 데이터를 분산 저장한다

4. 기본적으로 Master, Slave 서버만으로 구성되고, Sentinel 서버는 요구되지 않는다

5) Redis Server는 기본적으로 16,384개의 Slot을 가지는데,  빅데이터를 여러 대의 서버에 분산 저장할 때 각 Slot 당 데이터를 일정한 단위로 분류하여 저장할 때 사용됨
   * 예) 3대의 Redis Server가 구축되어 이쓴 환경에서 첫 번째 서버에는 0~5,460, 두 번째 서버에는 5,461~10,922, 세 번째 서버에는 10,923~16,384 Slot 정보가 분산된다
   *  분산 서버수가 4대, 5대로 증가하게 되면 증가된 수를 16,384로 나누면 각 서버에 저장될 Slot 정보를 가늠해볼 수 있다

6) Hash 파티션을 통해 데이터를 분산 저장할 수 있다
   * Hash 함수는 CRC16(Cycle Redundancy Check) 함수를 사용한다.

## 6.4.2 Cluster 명령어를 이용한 수동 설정 방법

### 1. 최소 3대의 Master 서버를 통해 데이터를 분산저장해야 하고, 각 Master 서버에 장애가 발생하는 경우에 대비하기 위해 각 Slave 서버를 통해 복제 시스템 구축을 목표로 해야 한다

* 3대의 서버를 사용하는 이유는 일반적으로 분산 시스템에서 합의 알고리즘을 적용할 때 쿼럼(Quorum)을 형성하기 위한 것입니다. 쿼럼은 분산 시스템의 일관성을 유지하기 위한 최소한의 노드 수로, 시스템의 일부가 실패하거나 네트워크 분할이 발생해도 올바른 작동을 보장합니다.
* **홀수 개수의 서버 사용**: 홀수 개수의 서버를 사용하면 더 나은 합의를 달성할 수 있습니다. 2대의 서버가 있을 경우, 한 대가 실패하면 퀴럼을 형성할 수 없게 되므로 합의에 도달할 수 없습니다. 반면 3대의 서버에서는 한 대가 실패해도 나머지 두 대로 퀴럼을 형성할 수 있으므로 시스템은 계속 작동합니다.
* **유연한 유지보수**: 3대의 서버가 있으면 하나의 서버를 유지보수로 내릴 경우에도 나머지 두 대로 시스템을 계속 운영할 수 있습니다. 2대의 서버에서는 유지보수 중인 서버가 있다면, 남은 하나의 서버만으로는 퀴럼을 형성할 수 없으므로 안정적인 운영이 어려울 수 있습니다.

안정성 확보가 요구되는 서비스 환경이라면

*  Master 1 - Slave 1 - Slave 2

와 같이 Slave 2 서버를 추가로 확보했을 때 가장 이상적인 시스템을 구축할 수 있지만 서버를 추가하는 경우, 유지보수 비용이 증가하는 문제점이 있을 수 있다.

* 예) Master 2대 - Slave 2대(최소 환경)

* 예) Master 3대 - Slave 3대(권장 환경)

* 예) Master 3대 - Slave1 3대 - Slave2 3대(최적 환경)

### 2. NoSQL과 Redis Server의 경우에는 반드시 Master 서버수와 Slave 서버수가 1:1로 매핑되어야 할 필요가 없다

**최초 시스템을 구축할 때 바람직하지 않으므로 권장되지 않음**

* 초기 시스템 구축 단계에서는 복잡성을 최소화하고 리소스를 효과적으로 관리하며 일관된 성능을 제공하기 위해 Master와 Slave의 1:1 매핑을 선호할 수 있다

* 예) Master 1 - Slave 1 : Master 1 서버는 하나의 Slave 1 서버로 복제됨

* 예) Master 2 - Slave 1 - Slave 2 : Master 2 서버는 Slave 1 서버와 Slave 2 서버 두 대로 복제되는 구성이 가능함



## 실습 - 3개의 샤드서버(Master)와 3대의 Slave 서버 클러스터 구성

* http://redisgate.kr/redis/configuration/redis_overview.php
* https://azderica.github.io/01-db-nosql-redis/

* https://co-de.tistory.com/15
* https://crazy-horse.tistory.com/entry/%EB%A0%88%EB%94%94%EC%8A%A4-%EB%A0%88%EB%94%94%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A5%BC-%EB%8F%84%EC%BB%A4%EC%97%90%EC%84%9C-%EA%B5%AC%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90
* https://uchupura.tistory.com/56



## Docker-compose.yml 작성

### 1. 설정파일 작성

설정파일은 각각 디렉토리에 맞게 설정 및 생성하셔야 합니다

```
# redis-master1.conf
cluster-enabled yes
cluster-config-file "./nodes-master1.conf"
cluster-node-timeout 5000
appendonly yes

# redis-master2.conf
cluster-enabled yes
cluster-config-file "./nodes-master2.conf"
cluster-node-timeout 5000
appendonly yes

# redis-master3.conf
cluster-enabled yes
cluster-config-file "./nodes-master3.conf"
cluster-node-timeout 5000
appendonly yes

# redis-slave1.conf
cluster-enabled yes
cluster-config-file "./nodes-slave1.conf"
cluster-node-timeout 5000
appendonly yes

# redis-slave2.conf
cluster-enabled yes
cluster-config-file "./nodes-slave2.conf"
cluster-node-timeout 5000
appendonly yes

# redis-slave3.conf
cluster-enabled yes
cluster-config-file "./nodes-slave3.conf"
cluster-node-timeout 5000
appendonly yes
```

저는 쉘 스크립트로 한방에 했습니다.

```sh
#!/bin/bash

base_directory="/Users/ysk/dev/volume/redis-cluster"

declare -a masters=("master1" "master2" "master3")
declare -a slaves=("slave1" "slave2" "slave3")

for master in "${masters[@]}"; do
  directory="${base_directory}/${master}"
  mkdir -p "${directory}"
  filename="redis-${master}.cnf"
  echo "cluster-enabled yes" > "${directory}/${filename}"
  echo "cluster-config-file \"./nodes-${master}.conf\"" >> "${directory}/${filename}"
  echo "cluster-node-timeout 5000" >> "${directory}/${filename}"
  echo "appendonly yes" >> "${directory}/${filename}"
  echo "Config file for ${master} created successfully!"
done

for slave in "${slaves[@]}"; do
  directory="${base_directory}/${slave}"
  mkdir -p "${directory}"
  filename="redis-${slave}.cnf"
  echo "cluster-enabled yes" > "${directory}/${filename}"
  echo "cluster-config-file \"./nodes-${slave}.conf\"" >> "${directory}/${filename}"
  echo "cluster-node-timeout 5000" >> "${directory}/${filename}"
  echo "appendonly yes" >> "${directory}/${filename}"
  echo "Config file for ${slave} created successfully!"
done

echo "All config files created successfully!"
```



### 2. Docker-compose.yml 작성

```yml
version: '3'
networks:
  redis-network:
    driver: bridge


services:
  redis-master1:
    container_name: redis-master1
    image: redis:latest
    volumes:
      - /Users/ysk/dev/volume/redis-cluster/master1/redis-master1.cnf:/usr/local/etc/redis/redis.conf
    ports:
      - "7001:6379"
      - "17001:17001"
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - redis-network

  redis-master2:
    container_name: redis-master2
    image: redis:latest
    volumes:
      - /Users/ysk/dev/volume/redis-cluster/master2/redis-master2.cnf:/usr/local/etc/redis/redis.conf
    ports:
      - "7002:6379"
      - "17002:17002"
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - redis-network

  redis-master3:
    container_name: redis-master3
    image: redis:latest
    volumes:
      - /Users/ysk/dev/volume/redis-cluster/master3/redis-master3.cnf:/usr/local/etc/redis/redis.conf
    ports:
      - "7003:6379"
      - "17003:17003"
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - redis-network

  redis-slave1:
    container_name: redis-slave1
    image: redis:latest
    volumes:
      - /Users/ysk/dev/volume/redis-cluster/slave1/redis-slave1.cnf:/usr/local/etc/redis/redis.conf
    ports:
      - "7101:6379"
      - "17101:17101"
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - redis-network

  redis-slave2:
    container_name: redis-slave2
    image: redis:latest
    volumes:
      - /Users/ysk/dev/volume/redis-cluster/slave2/redis-slave2.cnf:/usr/local/etc/redis/redis.conf
    ports:
      - "7102:6379"
      - "17102:17102"
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - redis-network

  redis-slave3:
    container_name: redis-slave3
    image: redis:latest
    volumes:
      - /Users/ysk/dev/volume/redis-cluster/slave3/redis-slave3.cnf:/usr/local/etc/redis/redis.conf
    ports:
      - "7103:6379"
      - "17103:17103"
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - redis-network
```

* 네트워크 묶기
* 로컬에 있는 conf 파일 redis.conf로 마운팅 잘하기

### 3. Docker-compose 실행

```
> docker compose up -d
```

### 4. 클러스터 생성

컨테이너 마스터 1의 쉘에 진입하여 클러스터 생성

**명령어**

```
redis-cli --cluster create 마스터1:포트 마스터2:포트 마스터3:포트 ...
```

```sh
redis-cli --cluster create redis-master1:6379 redis-master2:6379 redis-master3:6379

# 실행 후
>>> Performing hash slots allocation on 3 nodes...
Master[0] -> Slots 0 - 5460
Master[1] -> Slots 5461 - 10922
Master[2] -> Slots 10923 - 16383
M: 65f40a58b01f6d64e43b15f84137bc3870650fab redis-master1:6379
   slots:[0-5460] (5461 slots) master
M: e7c7348f763e3a52cf8a1d41a14eb9eef3227a20 redis-master2:6379
   slots:[5461-10922] (5462 slots) master
M: c3a9744f3bb1f4f14c6f4a800b4fff7ecfc3c6ce redis-master3:6379
   slots:[10923-16383] (5461 slots) master
Can I set the above configuration? (type 'yes' to accept): yes
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join
.
>>> Performing Cluster Check (using node redis-master1:6379)
M: 65f40a58b01f6d64e43b15f84137bc3870650fab redis-master1:6379
   slots:[0-5460] (5461 slots) master
M: c3a9744f3bb1f4f14c6f4a800b4fff7ecfc3c6ce 172.23.0.2:6379
   slots:[10923-16383] (5461 slots) master
M: e7c7348f763e3a52cf8a1d41a14eb9eef3227a20 172.23.0.6:6379
   slots:[5461-10922] (5462 slots) master
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
```

다음으로 클러스터 노드 확인

```sh
redis-cli cluster nodes

# 실행 후
c3a9744f3bb1f4f14c6f4a800b4fff7ecfc3c6ce 172.23.0.2:6379@16379 master - 0 1692111759933 3 connected 10923-16383
65f40a58b01f6d64e43b15f84137bc3870650fab 172.23.0.3:6379@16379 myself,master - 0 1692111759000 1 connected 0-5460
e7c7348f763e3a52cf8a1d41a14eb9eef3227a20 172.23.0.6:6379@16379 master - 0 1692111758908 2 connected 5461-10922
```

명령어를 입력하면 3개의 마스터 노드에 자동 샤딩이 적용되어 해시 값에 따라 저장되는 슬롯이 다르게 됩니다

### 5. Slave 클러스터 생성

명령어

```
redis-cli --cluster add-node 슬레이브IP:포트 마스터IP:포트 --cluster-save
```

실행

```sh
redis-cli --cluster add-node redis-slave1:6379 redis-master1:6379 --cluster-slave
redis-cli --cluster add-node redis-slave2:6379 redis-master2:6379 --cluster-slave
redis-cli --cluster add-node redis-slave3:6379 redis-master3:6379 --cluster-slave
```

### 6. 클러스터 정보 확인

1. redis-cli cluster info

```sh
redis-cli cluster info

# 결과
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
... 생략
```

2. Master slave 관계 파악하기

```sh
redis-cli cluster nodes

# 결과


## 마스터노드 - redis-master1 (0.3) 슬롯 : 0-5460
65f40a58b01f6d64e43b15f84137bc3870650fab 172.23.0.3:6379@16379 myself,master - 0 1692112457000 1 connected 0-5460

## 마스터노드 - redis-master2 - 슬롯 : 5461-10922
e7c7348f763e3a52cf8a1d41a14eb9eef3227a20 172.23.0.6:6379@16379 master - 0 1692112457000 2 connected 5461-10922

## 마스터노드 - redis-master3 - 슬롯 : 10923-16383
c3a9744f3bb1f4f14c6f4a800b4fff7ecfc3c6ce 172.23.0.2:6379@16379 master - 0 1692112457640 3 connected 10923-16383


## 슬레이브노드 - 연결된 마스터 : 65f40a58b01f6d64e43b15f84137bc3870650fab (첫 번째 master)
8deea3df16a3a40cd4dc5bbf7e7535326ca0e8f9 172.23.0.7:6379@16379 slave 65f40a58b01f6d64e43b15f84137bc3870650fab 0 1692112456084 1 connected

## 슬레이브노드 - 연결된 마스터 :  e7c7348f763e3a52cf8a1d41a14eb9eef3227a20 (두 번째 master)
bc5f16e85ddca84b47ffacd5c509ee062365e361 172.23.0.5:6379@16379 slave e7c7348f763e3a52cf8a1d41a14eb9eef3227a20 0 1692112456617 2 connected

## 슬레이브노드 - 연결된 마스터  : c3a9744f3bb1f4f14c6f4a800b4fff7ecfc3c6ce (세 번째 master)
03afb59173ca34f69cc0cb2864074c48ab99b6c8 172.23.0.4:6379@16379 slave c3a9744f3bb1f4f14c6f4a800b4fff7ecfc3c6ce 0 1692112457123 3 connected
```

### 슬롯?

Redis 클러스터에서 슬롯(Slot)은 키 공간을 16384개의 범위로 나눈 것. 

즉, 슬롯은 0부터 16383까지의 숫자 중 하나가 될 수 있으며, 클러스터 내의 특정 노드에 할당된다.

클러스터 모드에서 Redis는 키를 슬롯에 매핑하여 분산 저장된다.

키가 어떤 슬롯에 속하는지는 키에 대해 CRC16 Function을(해시함수) 적용하고 16384 값을 나눈것에 의해 결정된다. 

* CRC16 function으로 나온 값에 16384를 나눈 나머지 값이 슬롯이다.

그리고 각 슬롯은 특정 마스터 노드에 할당되어 처리된다.

### 6.4.3 클러스터 명령어

슬레이브 확인 명령어

```
redis-cli cluster slaves '마스터 노드 값'

## ex)

> redis-cli cluster slaves 65f40a58b01f6d64e43b15f84137bc3870650fab
1) "8deea3df16a3a40cd4dc5bbf7e7535326ca0e8f9 172.23.0.7:6379@16379 slave 65f40a58b01f6d64e43b15f84137bc3870650fab 0 1692113258629 1 connected"
```

**1. 클러스터 정보**

```
127.0.0.1:6379> cluster info
```

**2. 클러스터에 할당된 모든 노드 정보**

```
127.0.0.1:6379> cluster nodes
```

**3. 클러스터 슬롯 정보**

```
127.0.0.1:6379> cluster slots

1) 1) (integer) 0
   2) (integer) 5460 # 0부터 5460
   3) 1) "172.23.0.3"
      2) (integer) 6379
      3) "65f40a58b01f6d64e43b15f84137bc3870650fab"
      4) (empty array)
   4) 1) "172.23.0.7"
      2) (integer) 6379
      3) "8deea3df16a3a40cd4dc5bbf7e7535326ca0e8f9"
      4) (empty array)
2) 1) (integer) 5461
   2) (integer) 10922 # 5461부터 10922
   3) 1) "172.23.0.6"
      2) (integer) 6379
      3) "e7c7348f763e3a52cf8a1d41a14eb9eef3227a20"
      4) (empty array)
   4) 1) "172.23.0.5"
      2) (integer) 6379
      3) "bc5f16e85ddca84b47ffacd5c509ee062365e361"
      4) (empty array)
3) 1) (integer) 10923
   2) (integer) 16383 # 10923 부터 16383
   3) 1) "172.23.0.2"
      2) (integer) 6379
      3) "c3a9744f3bb1f4f14c6f4a800b4fff7ecfc3c6ce"
      4) (empty array)
   4) 1) "172.23.0.4"
      2) (integer) 6379
      3) "03afb59173ca34f69cc0cb2864074c48ab99b6c8"
      4) (empty array)
```

**4. key 1111이 저장되어 있는 슬롯 번호**

```
127.0.0.1:6379> cluster keyslot 1111
(integer) 14366
```

* `CLUSTER KEYSLOT 1111` 명령은 이 특정 키가 Redis 클러스터 내 어느 해시 슬롯에 속하는지를 알려주는 명령

**5. 슬레이브 노드를 마스터 노드로 전환**

* 여기서 172.17.0.4 5004는 슬레이브 노드의 IP와 포트이다
* `cluster failover` 명령은 슬레이브가 현재 연결된 마스터의 역할을 인수하게 합니다.

```
$ redis-cli -h 172.17.0.4 -p 5004 cluster failover
```

**6. Master 노드에만 적용해야 함**

```
$ redis-cli -h 127.0.0.1 -p 5008 cluster reset
```

* 이 명령을 실행하면 해당 노드는 클러스터의 일원이 아닌 독립된 Redis 인스턴스로 작동하게 됩니다.

**7. 변경된 환경 정보 redis.conf에 저장**

````
$ redis-cli -h 127.0.0.1 -p 6379 cluster saveconfig
````

* 이렇게 하면 클러스터 구성의 변경사항이 영구적으로 저장되어 Redis 인스턴스가 재시작될 때도 유지됩니다.

## 6.4.4 redis-trib.rb 유틸리티를 이용한 자동 설정방법

마스터 3대, 슬레이브 3대 설정하는거는 똑같습니다.

위 설정대로 실행한 후 다음 순차를 따라주세요

**1) 관련 패키지 설치**

```sh
$ apt-get update
$ curl -sSL https://rvm.io/mpapis.asc | gpg --import -    # Ruby 설치
$ curl -L get.rvm.io | bash -s stable

$ source /etc/profile.d/rvm.sh
$ rvm reload
$ rvm requirements run
$ rvm install 2.4.1
$ exit

$ ruby --version

$ vi /etc/sysctl.conf
net.core.somaxconn = 1024          # 소켓수 무제한 설정(unlimited)
```

**2) 인스턴스 활성화**

재실행 시 node-500x.conf 파일 제거 해야 함

**3.  활성화된 각 노드를 Cluster 서버로 설정**

```
$ cd /home/redis/src
$ ./redis-trib.rb create --replicas 1 127.0.0.1:5001 127.0.0.1:5002 127.0.0.1:5003 127.0.0.1:5004
$ ./redis-trib.rb create --replicas 1 127.0.0.1:5001 127.0.0.1:5002 127.0.0.1:5003 127.0.0.1:5004 127.0.0.1:5005 127.0.0.1:5006

```

**4. 구축된 Cluster 시스템을 확인하는 방법**

```
$ ./redis-cli -c -h 127.0.0.1 -p 5001
```

### 새로운 노드 추가

1. 특정 노드 추가 및 제거

```sh
$ ./redis-trib.rb add-node 127.0.0.1:5007 127.0.0.1:5001
```

2. **8번 노드를 7번 노드의 Slave 서버로 추가**

```
$ ./redis-trib.rb add-node --slave 127.0.0.1:5008 127.0.0.1:5007
```

3. **전체 서버로 재분산 작업 수행**

```
$ ./redis-trib.rb reshard 127.0.0.1:5001       # Resharding 작업 실행
$ ./redis-cli -c -h 127.0.0.1 -p 5001
```

4. **7번, 8번 노드를 제거하는 방법**

5. 현재 데이터가 분산 저장되어 있는 상태에서 제거할 수 없음(에러 발생)

   노드를 삭제하기 위해서는 먼저 7번 노드의 데이터를 다른 노드로 옮긴 다음 제거해야 하고, Reshard 작업을 먼저 수행해야 함

```
$ ./redis-trib.rb del-node 127.0.0.1 5007 b063fdcfc74cfcdbd0c4867525827dc14eacb380
$ ./redis-trib.rb del-node 127.0.0.1 5008 3626c198ff990c2dafac8ae9d9dbac9bbd31fdd3
```

## **6.4.5 redis-trib.rb 옵션절**

* https://blog.naver.com/PostView.naver?blogId=rinjyu&logNo=222683036828&parentCategoryNo=&categoryNo=&viewDate=&isShowPopularPosts=false&from=postView

**1. 사용 가능한 명령어 확인**

```
$ ../src/redis-trib.rb help
```

**2. Cluster 서버의 상태와 Slot 정보 제공**

```
$ ../src/redis-trib.rb info 192.168.65.128:5001
```



**3. Cluster 전체 내용과 상태 체크**

```
$ ../src/redis-trib.rb check 127.0.0.1:5001
```



**4. 전체 데이터를 Cluster로 재분배**

```
$ ../src/redis-trib.rb rebalance 127.0.0.1:5001
```



**5. --use-empty-masters**

새로운 노드를 추가한 후 비어 있는 노드를 재 분배할 때 사용

```
$ ../src/redis-trib.rb rebalance --use-empty-masters 192.0.0.1:5001
```

# 6.5 Redis Cluster 장애 복구

분산/복제 시스템의 가장 큰 장점은 장애가 발생하더라도 데이터 안정성을 최대한 보장해야 한다

그러기 위해 Slave 서버는 Master 서버의 장애 상태를 인지하고 빠른 시간 내에 Master 서버로 Failover 되어야 한다



# 6.6 Client for Redis Server

Java 프로그래밍 언어에서 Redis Server에 접속하여 데이터를 처리할 수 있는 클라이언트를 위한 API 소프트웨어

## JEDIS

* https://github.com/redis/jedis

```groovy
dependencies {
    // https://mvnrepository.com/artifact/redis.clients/jedis
    implementation 'redis.clients:jedis:4.4.3'
}
```

```java
public class JedisTest {

	public static void main(String[] args) {
		Jedis jedis = new Jedis("127.0.0.1", 7001);
		jedis.set("10", "Computing Team");
		String value = jedis.get("10");

		System.out.println(value);
	}
}
```

### **2) Master-Slave-Sentinel Redis Server connection 예제**

```java

public class JedisTestSentinelEndpoint {
	private static final String MASTER_NAME = "mymaster";
	public static final String PASSWORD = "1234";
	private static final Set sentinels;

	static {
		sentinels = new HashSet<>();
		sentinels.add("127.0.0.1:7001");
		sentinels.add("127.0.0.1:7002");
		sentinels.add("127.0.0.1:7003");
	}

	public JedisTestSentinelEndpoint() {

	}

	public static void main(String[] args) throws InterruptedException {
		new JedisTestSentinelEndpoint().runTest();
	}

	private void runTest() throws InterruptedException {
		JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels);
		Jedis jedis = null;
		try {
			printer("Fetching connection from pool");
			jedis = pool.getResource();

			printer("Authentication !!");
			jedis.auth(PASSWORD);

			printer("Authentication Finish...");


			printer("Connected to " + jedis.info());
			printer("Writing...");

			jedis.set("10", "Computing Team");
			printer("Reading...");
			jedis.get("1101");

			jedis.zadd("type", 0, "bentz");
			jedis.zadd("type", 0, "bmw");
			jedis.zrange("type", 0, -1);
		} catch (JedisException e) {
			printer("Connection error of some sort!");
			printer(e.getMessage());
			Thread.sleep(2 * 1_000);
		} finally {
			if (jedis != null) {
				jedis.close();
			}
		}
	}

	private static void printer(String str) {
		System.out.println(str);
	}
}

```

> 책 설명 너무 오래되서 구리다.



## Redission

https://github.com/redisson/redisson/wiki/Table-of-Content

**Redisson Edition 다운로드**

https://redisson.pro/

**1) Standalone Redis Server connection 예제**

```java
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:5000");
RedissonClient redisson = Redisson.create(config);
```

**2) Master-Slave Redis Server connection 예제**

```java
Config config = new Config();
config.useMasterSlaveServers()
       // SSL 연결을 위해 redis://를 사용
       .setMasterAddress("redis://127.0.0.1:5000")
       .addSlaveAddress("redis://127.0.0.1:5001", "redis://127.0.0.1:5002")
       .addSlaveAddress("redis://127.0.0.1:5003");

RedissonClient redisson = Redisson.create(config);
```



**3) Master-Slave-Sentinel Redis connection 예제**

```java
Config config = new Config();
config.useSentinelServers()
       .setMasterName("mymaster")
       .addSentinelAddress("redis://127.0.0.1:6000", "redis://127.0.0.1:6001")
       .addSentinelAddress("redis://127.0.0.1:6002");

RedissonClient redisson = Redisson.create(config);
```

**4) Redis Cluster Server connection 예제**

```java
Config config = new Config();
config.useClusterServers()
       // 클러스터 상태 검색 간격(milliseconds)
       .setScanInterval(2000)
       // SSL 연결을 위해 redis://를 사용
       .addNodeAddress("redis://127.0.0.1:5001", "redis://127.0.0.1:5002")
       .addNodeAddress("redis://127.0.0.1:5003");

RedissonClient redisson = Redisson.create(config);
```



## Lettuce

https://github.com/lettuce-io/lettuce-core



**1) Master-Slave-Sentinel Redis Server connection 예제**

```java
RedisURI redisUri = RedisURI.create("127.0.0.1", 6000);
RedisClient client = new RedisCliet(redisUri);

RedisSentinelAsyncConnection<String, String> connection = client.connectSentinelAsync();

Map<String, String> map = connection.master("mymaster").get();
```

**2) Sentinel Master Redis Server connection 예제**

```java
RedisURI redisUri = RedisURI.Builder.sentinel("127.0.0.1:6000", "mymaster").withSentinel("127.0.0.1:6001").build;
RedisClient client = RedisClient.create(redisUri);

RedisConnection<String, String> connection = client.connect();
```

**3) Redis Cluster Server connection 예제**

```java
RedisURI node1 = RedisURI.create("127.0.0.1", 6000);
RedisURI node2 = RedisURI.create("127.0.0.1", 6001);

RedisClusterClient clusterClient = RedisClusterClient.create(Arrays.asList(node1, node2));
StatefulRedisClusterConnection<String, String> connection = clusterClient.connect();
RedisAdvancedClusterCommands<String, String> syncCommands = connection.sync();
...
connection.close();
clusterClient.shutdown();
```

# 6.7 Logging & Monitoring

Redis Server에는 예기치 못한 장애가 발생하게 되면 서버 내에는 시간별로 장애 발생 원인과 이벤트 정보들이 기록된다 

## 1. Logging 정보

**1 loglevel 파라미터**

Redis Server 내에서 발생하는 다양한 상태 정보를 구체적으로 수집할 것인지 사용자가 결정할 수 있다

**2. logfile 파라미터**

사용자가 원하는 경로에 워하는 이름의 파일로 저장할 수 있다

```sh
-- redis.conf 파일

$ vi redis.conf
logfile    "/home/redis/log_5001.log"         # 로그 정보가 저장되거나 경로와 이름. 미리 만들어 두어야 함?
loglevel   notice                             # 로그 수집 레벨

syslog-enabled  yes                           # 시스템 로그 정보의 수집 여부 결정

syslog-ident    redis123                      # 시스템 로그 식별자
```

* https://redis.io/docs/management/config-file/

로그 레벨

| 로그 레벨 | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| debug     | 많은 정보가 있으며, 개발/테스팅에 유용합니다.                |
| verbose   | 유용하지 않은 많은 정보가 있지만, debug 레벨처럼 많은 정보가 기록되진 않음 |
| notice    | \- 적당히 상세한 정보들이 기록됨<br />\- 프로덕션 환경에서 원하는 정보들이 있음 |
| warning   | 매우 중요하거나 위기의 메시지만 기록됩니다.                  |
| nothing   | 로그가 기록되지 않습니다.                                    |

ex)

```
# in redis.conf ...
vi redis.conf

loglevel nothing
```

## 2. 모니터링

Redis Server의 상태를 모니터링하는 방법

```sh
# conf 파일에 설정해야 한다
$ vi redis.conf

config set latency-monitor-threshold   25       # 25 millisecond 이상 소요되는 작업을 수집 분석

$ ./redis-cli -c -p 5001
127.0.0.1:5001> debug sleep .25                 # .025초 이상 소요된 작업 수집
OK
> latency latest                                # 조건을 만족하는 작업 리스트
1) 1) "command"
   2) (integer) 1405067976
   3) (integer) 251
   4) (integer) 1001

----
> latency doctor                                # Advice Report 제공
> exit

----
$ ./redis-cli -p 5001 -latency                  # Latency 상태 모니터링

$ ./redis-cli -p 5001 --latency-history         # Latency 히스토리 상태 모니터링

$ ./redis-cli -p 5001 --bigkeys

$ ./redis-cli -p 5001 monitor                   # 하나의 세션에서 다른 클라이언트 작업 모니터링
```



# 6.8 Subscribe & Publish ( Redis Pub Sub)

Redis는 서버와 클라이트 간에 메시지를 송수신할 수 있는 긴으을 통해 데이터베이스 운영 관리가 가능하도록 Subscribe와 Publish 명령어를 제공한다

**1) Publish 명령어**

메시지를 송신할 때 실행함

**2) Subscribe 명령어**

수신할 때 실행하는 명령어

**주요 특징**

* Subscribe는 클라이언트로부터 해당 채널로 보낸 메시지를 푸시함

*  하나 이상의 채널에 가입한 클라이언트는 채널을 해제할 수 있지만 메시지를 내보내는 명령을 실행할 수 없음

*  Subscribe 명령어를 실행하면 일관된 메시지 스트림을 수행할 수 있음

*  Unscribe 명령어는 메시지 수신을 취소할 때 실행해야 함

* Publish, Subscribe는 Key-Value 저장공간과 관련이 없으며 전송과 수신 데이터는 어떤 기능으로 인해 방해받지 않도록 설계되어 있음

*  Psubscribe는 사용자가 지정한 특정 패턴의 메시지만 수신함

### 실습

```
<Session-1>
> subscribe redis                       # redis는 채널명

<Session-2>
> publish redis hello                   # hello : 전송 내용
> publish redis "Hello World ~~"

<Session-3>
> subscribe redis

<Session-2>
> publish redis "Hello World ~~"

<Session-1>
> psubscribe r*                         # r* : 채널명
redis

<Session-2>
> publish redis hello
```

# 6.9 Server Monitor

Redis-cli는 Redis Server 내에서 실행되는 모든 이벤트 정보를 온라인으로 수신할 수 있ㄷ

```sh
<Session 1>
$ redis-cli -p 6379 monitor
OK

< Session 2>
$ redis-cli
127.0.0.1:6379> set 1 a
OK
127.0.0.1:6379> get 1
"a"

<Session 1>
$ redis-cli monitor
OK
```

