# 리액티브 프로그래밍







리액티브 매니페스토(https://www.reactivemanifesto.org)에 명시된 리액티브 시스템 특징입니다.

- ﻿﻿응답성
- ﻿﻿회복력
- ﻿﻿탄력성
- ﻿﻿메시지 기반

리액티브 스트림(RS) 구상은 서비스 간의 상호작용에 초점을 맞추고, 다음 네 가지 요소가 핵심입니다.

- ﻿﻿Application Programming Interface
- ﻿﻿Specfication
- ﻿﻿구현 예제
- ﻿﻿기술 호환성 키트Techology Compatolty Kt (이하 TCK)



API는 네 개의 인터페이스로 구성됩니다.

- ﻿﻿Pub Lisher (게시자) : 사물의 생성자
- ﻿﻿Subscriber (구독자) : 사물의 구독자
- ﻿﻿Subscription (구독) : 게시자와 구독자 간 계약
- ﻿﻿Processor (처리자): 사물의 수신, 변형, 전송을 위한 게시자와 구독자의 통합



텍스트 사양(Specification)은 APT 구현에서 기대된 동작 및/또는 필수 동작을 자세히 설명합니다.

Publisher가 실패하면 onError 신호를 보내야 합니다.

(원문) If a Publisher fails it MuST signal an onError.



## 리액티브 스트림, 비동기성, 백프레셔

리액티브 스트림은 리액티브 스트림 정보 사이트(www.reactive-streams.org) 강령의 첫 단 락 설명에 뚜렷하게 명시됐듯 비동기식 통신과 처리를 기반으로 구축됐습니다.

리액티브 스트림은 논블로킹 백프레셔로 비동기식 스트림을 처리할 표준을 제공하기 위해 구상됐습니다. 

네트워크 프로토콜만이 아니라 런타임 환경(JVM과 자바스크립트)을 대상으로 하는 노력도 포함됩니다.

비동기식 처리는 서비스가 보류 중인 요청의 응답을 '수신(listen) 하는 이벤트 루프 같은 구현 메커니즘으로 인해 최소한의 오버헤드(비용)가 발생합니다.  애플리케이션 간 연결이 매우 적은 시나리오에서는 동기식 통신과 처리보다 성능이 약간 떨어지기도 합니다. 그러나 이런 현 상은 애플리케이션 간 연결이 증가하고 스레드가 고갈되면서 빠르게 반전되어, 리소스는 동기 식 처리와 달리 비동기식 처리로 단순히 의무화되지 않으며 idle 상태가 되지도 않습니다. 



논블로킹 백프레셔란 서비스 A의 응답 처리 능력을 서비스 B에게 알린다는 단순한 개념입니다.

A는 단순히 "모든 걸 줘”라고 말하는 게 아니라, B에게 여러 객체를 요청한 후에 처리하고, 그 다음 응답 객체를 처리할 준비가 됐을 때 B에게 객체를 더 요청합니다.



## 리액티브 데이터 액세스

데이터베이스 엔진과 드라이버는 애플리케이션 요청과 흐름 제어를 블로킹하지 않고 처리하는 문제를 해결해야 합니다. 페이징은 이 문제를 해결하기 위한 방법이지만 완벽하지 않으며, 각 페이지마다 새로운 쿼리 실행이 필요합니다. 리액티브 방식에서는 명령형 '하나씩 가져오기' 방식 대신, 데이터가 연속적으로 흘러나오는 방식을 선호합니다.

flux는 컵을 다시 채우기 위해 단순히 수도꼭지를 트는 일입니다. 리액티브 시나리오에서 물은 명령형 처럼 '가서, 다시 가져오기' 방식이 아니라 수도꼭지를 틀어서 흘러내리기만 하면 됩니다.



## R2DBC



현재 H2를 R2DBC와 함께 사용하려면, 애플리케이션에서 사용할 Connectionfactory initializer 빈을 생성하고 구성해야 합니다. 설정 시 실제로 두 단계만 필요합니다.

- ﻿﻿Connection factory를 ConnectionFactory 빈으로 인자로 주입(자동 설정으로 구현)
- ﻿﻿원할 때 또는 필요에 따라 데이터베이스를 초기화하거나 재초기화하기 위해 하나 이상의 스크립트를 실행하도
   룩 데이터베이스 구성



# RSocket

TCP, 웹소켓 ,Aeron 전송 메커니즘을 통해 사용할 수 있는 초고속 이진(binary) 프로토콜.

4가지 비동기 상호작용 모델을 지원한다.

* 요청 - 응답
* 요청 - 스트림
* 실행 후 무시(Fire & Forget)
* 요청 채널(양방향 스트림)

아래의 사용사례에서 사용한다

- ﻿﻿한쪽이 요청하고, 다른 쪽에서 응답을 받는 1:1 상호작용
- ﻿﻿한쪽이 요청하고, 상대방에게 일련의 응답을 받는 1:N 상호작용
- ﻿﻿한쪽이 요청하는 1:0 상호작용
- ﻿﻿양 당사자가 요청. 응답 또는 요청하지 않은 모든 종류의 데이터 스트림을 보내는 완전한 양방향 채널