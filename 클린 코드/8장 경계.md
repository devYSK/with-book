# 8장 경계

[toc]



시스템의 모든 소프트웨어를 직접 개발하는 경우는 드물다.

오픈소스, 라이브러리 등의 외부 코드를 사용한다.

이 외부 코드를 우리 코드에 깔끔하게 통합하고 이 경계를 깔끔하게 저리하는 기법과 기교를 살펴보자



# 외부 코드 사용하기 

인터페이스 제공자와(라이브러리라고 하자) 인터페이스 사용자 사이에서 인터페이스 제공자는 최대한 적용성을 넓히려 애쓴다. 많은 환경에서 호환되고 돌아가야 많은 고객이 사용하기 때문이다.

한 예로, Map을 보면 Map은 다양한 인터페이스로 수많은 기능을 제공한다.

인터페이스 객체로 Map을 여기저기 넘기면서 사용하면 여러 문제가 생길 수 있다.

* clear()로 누군가는 지워버리던가, 
* 특정 객체유형만 지원하고자 하는데 Map은 다양한 객체를 지원한다. 마음만 먹으면 어떤 유형도 추가할 수 있다. Object
* 제네릭을 사용하더라도, 제네릭 `Map<String, Sensor>`가 사용자에게 필요하지 않은 기능까지 제공하는 문제는 해결하지 못한다. 

어떻게 깔끔하게 쓸 수 있을까?

경계 인터페이스인 Map을 사용할 인터페이스 객체 내에 감싸는 것이다. 

```java
public class Sensors {
  private Map sensors = new HashMap();
  
  public Sensor getById(String id) {
    return (Sensor) sensors.get(id);
  }
}
```

또한 필요한 인터페이스만 제공하므로 map을 내놓을 필요가 없다. 

> 구 레거시 코드들을 보면 Map<String, Object>를 반환하는 코드가 매우 많다. 이렇게 쓰지 말고 dto등과 같은 인터페이스 객체로 사용하자

## 아직 존재하지 않는 코드를 사용하기 - 인터페이스

여러 팀이 협업을 할때, 인터페이스를 먼저 정의해서 만들면 코드가 존재하지 않아도 작성할 수 있다.

다음과 같이 필요한 기능을 정의하고 인터페이스로 만들어 공유하면 이 기능을 구현할 팀은 인터페이스에 맞게 맞추어 구현하여 제공만 하면 된다.

그럼 사용하는 팀은 인터페이스에만 의존하고 있고 단위테스트도 더 쉬워진다

```java
// 지정한 주파수를 이용해 이 스트림에서 들어오는 자료를 아날로그 신호로 전송하라 

public interface Transmitter {
  void transmit(Frequency frequency, Stream stream)
}
```

만약 저쪽 팀이 이 인터페이스를 이용해 구현하면 통합 테스트까지 할 수 있다.

또한 Adapter를 이용하면 둘이 서로 다른 인터페이스여도 둘간의 간극을 매꿀 수 있다.

## 깨끗한 경계

경계를 깨끗히하면 변경에도 유연하다.

변경을 하더라도 변경하는데 많은 투자와 재작업이 필요하지 않다. 

이 외부 시스템과의 경계에 위치하는 코드를 깔끔히 분리하고, 외부 패키지를 의존(import)하지도 말자. 우리쪽 패키지에 인터페이스를 정의하여 주입만 받아도 된다. 

* Map에서 봤듯이 새로운 클래스로 감싸거나, Adapter를 이용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하면 된다.

이렇게 외부 패키지를 호출하는 코드를 줄여 우리가 모르는 경계를 관리할수록 유지보수성, 가독성, 일관성도 높여지며 외부 패키지가 변해도 변경할 코드가 줄어든다. 