# 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식





# **2장 느려진 서비스, 어디부터 봐야 할까**

네트워크, 디스크, 메모리, CPU 속도 등의 다양한 지표가 성능과 견롼뎌ㅙㅁ.



서버 성능은 주로 응답 시간과 처리량 에 달려있다. 

## 처리량과 응답 시간

![image-20250528165322207](./images//image-20250528165322207.png)

* 응답시간의 구성



서버 처리 시간은 다음과 같은 요소를 포함함

* 로직 수행 - if, for
* DB SQL
* 외부 API 속도
* 응답 데이터 생성(전송)

일반적으로, 최고 지연 시간은 DB 연동 속도와 API 연동 속도가 제일 많은 편이다. 로직은 길지 않다. 

### 처리량

처리량은 단위 시간당 시스템이 처리하는 작업량. TPS 또는 RPS로 표현

* TPS : 초당 처리 트랜잭션
* RPS : 초당 요청 수

TPS를 늘리는 방법은 2가지

1. 서버가 동시 처리할 수 있는 요청 수를  늘려 대기 시간 줄이기 (처리량을 넘어가면 다음요청은 대기하게됌)
2. 처리 시간 자체를 줄여  다른 요청 대기 시간을 줄이기

## 서버 성능 개선 기초

트래픽이 증가하면서 주로 성능 문제가 생김. 시스템 수용 가능 TPS를 초과하거나 데이터가 쌓이기 때문

모니터링 도구를 사용해 문제가 발생하는 지점을 먼저 찾아야 함. 

### DB 커넥션 풀

DB 사용시 다음단계 거침

1. DB 연결
2. 쿼리 실행
3. 응답 받고 연결 종료

여기 주 지연시간은 서버와 DB연결 및 종료가 꽤 맣은 레이턴시를 가짐. 

때문에 미리 연결된 커넥션을 생성해서 커넥션 풀에 담아 보유하는 방법을 사용함.



트래픽이 순간적으로 급증하는 패턴이 존재시, 커넥션 풀의 최소 크기를 최대 크기에 맞추는 것이 좋음.

* 즉, 최대 = 최소로 아예 처음부터 최대로 만들어놓는것.

* 단 DB 사용률이 CPU 80%를 넘기면, 그때는 줄여서 DB 서버가 포화되지 않도록 하는것이 더 나음

### 커넥션 대기시간

지정된 대기시간 안에 커넥션을 구하지 못하면 DB 연결 실패 에러 발생.

응답시간이 중요하다면 대기시간을 가능한 한 짧게 설정하는것이 좋음. 0.5초~3초. 

짧게 설정시, 커넥션 풀이 모두 사용중이라면 일시적 에러 메시지 보여줄 수 있음.

* 긴 시간 무응답보다, 빠르게 에러를 반환하는것이 사용자 경험에서 나을 수 있음. 서버 부하 증가 방지도 할 수 있음. 

### 최대 유휴시간, 유효성 검사, 최대 유지시간

새벽 시간대나 최대 어느정도 시간이 지나도 사용자가 없다면 커넥션은 끊는것이 나음.

커넥션 유효성 검사시 SELECT 1 등과 같은 쿼리 사용함. 

### 캐시 적중률과 사용 규칙

적중률 (hit rate) = 캐시에 존재한 건수 / 조회 시도 건수

캐시 갱신 방법

* LRU : 가장 오래전에 사용된
* LFU : 가장 적게 사용된
* FIFO : 먼저 추가된

많은 서비스는 최신 데이터를 조회하는 경향이 있으므로 오래된 데이터는 미리 삭제하자.

또한 TTL도 무시하지말자

### 로컬 캐시와 리모트 캐시

보통 서버용 캐시는 2가지. 로컬 캐시와 리모트 캐시

![image-20250528175855632](./images//image-20250528175855632.png)

로컬 캐시 구현 기술

* caffeine(자바), go-cache(Go)

로컬캐시

* 장점 : 속도. 구조면에서 단순함

* 단점 : 단점데이터 크기 제한. 서버 재시작시에 캐시 리셋. 

리모트 캐시 (ex : redis)

* 캐시 크기 유연하게 확장. 수평확장도 가능
* 단점 : 속도. 네트워크 통신 해야함. 

배포 빈도가 높은 서비스면 리모트 캐시 사용을 고려하자. 

### 캐시 사전 적제

가상의 사례

* 앱 사용자 300만명.
* 사용자에게 매달 정해진 날에 이달의 요금 정보르 ㄹ보여줌
* 정해진 날에 전체 대상으로 푸시 알림 발송
* 일부는 앱을 통해 요금 정보 조회

푸시알림 보내기전, 앱 캐시에 등록해놓으면 캐시 적중률 99% 가능



변경에 민감한 데이터를 리모트에 보관하자. 로컬캐시는 자신의 데이터만 변경하기 때문. 

### 가비지 컬렉터와 메모리 사용

객체가 많아질수록 GC 발생률이 높아짐.

대량 조회 시도시, 대량 객체 생성되므로 조회 범위를 제한하는것이 좋음.

파일 다운로드는 다음처럼 스트림을 사용하자

```kotlin
fun copyFileTransferTo(path: Path, out: OutputStream) =
    Files.newInputStream(path).use { it.transferTo(out) }

// nio
fun copyFileChannel(path: Path, out: OutputStream) {
    FileChannel.open(path, READ).use { inChan ->
        Channels.newChannel(out).use { outChan ->
            var pos = 0L
            val size = inChan.size()
            while (pos < size) {
                // 한 번에 최대 2 GB까지 전송 가능
                pos += inChan.transferTo(pos, size - pos, outChan)
            }
        }
    }
}
```

* 8KB씩 끊어서 읽음
* 동시에 100명이 요청해도 800KB밖에 안됌. 

### 응답 데이터 압축

응답 시간에는 데이터 전송시간이 포함되는데, 주로 아래 2가지 요인에 영향받는다

* 네트워크 속도
* 전송 데이터 크기

텍스트 데이터를 gzip 등으로 압축시 크기가 줄어들어 전송시간도 빨라진다

* 그러나 jpeg이미지나 zip 파일처럼 이미 압축된 데이터는 큰 효과가 없음. 텍스트 데이터 형식에 적용

### 대기 처리

콘서트 예매처럼 사용자 폭증시 대기 처리를 통하면 디비 비용을 감소할 수 있다.



# **3장 성능을 좌우하는 DB 설계와 쿼리**


## 조회 트래픽을 고려한 인덱스 설계

주로 조회량이 쓰기보다 9배정도 높음. 9:1

## 몇 가지 조회 성능 개선 방법

인덱스 아니여도 조회 성능 개선 가능

카운트의 경우 기획자와 합의하여 전체 갯수를 세지 않도록 해보자.

# **4장 외부 연동이 문제일 때 살펴봐야 할 것들**


## 타임아웃



* 소켓 타임아웃 : **서버에 연결된 이후**, 데이터를 **받거나 쓰기를 시작하지 못한 경우** 일정 시간 이후 연결을 끊는 타임아웃
  * 연결은 성공했지만, **응답이 일정 시간 안에 오지 않으면 실패**로 간주.
  * **읽기(read) 또는 쓰기(write)** 작업이 **지연될 때** 발생
* 커넥션 타임아웃 : 클라이언트가 서버에 **연결을 시도할 때** 일정 시간 안에 연결이 안 되면 실패하는 타임아웃
  * 서버가 죽었거나 방화벽 등으로 연결 자체가 느릴 때 트리거
  * 연결에 오래 걸리는걸 방지 

* 읽기 타임아웃 : 요청을 보내고, **서버의 응답을 받는 과정에서**, 응답 바이트가 **지정된 시간 안에 도착하지 않으면 실패**로 처리
  * 서버가 응답을 주기로 했는데도 **지연되거나 멈췄을 때** 타임아웃 발생
  * **첫 번째 바이트**를 기다리는 동안이 아니라, **연속적인 읽기**에 초점



- API 통신 등에서는 보통 다음 세 가지를 설정:
  - 연결 타임아웃 (connect timeout): 서버까지 도달 못할 때
  - 읽기 타임아웃 (read timeout): 응답이 느릴 때
  - 쓰기 타임아웃 (write timeout): 데이터 보내는 중 멈출 때 → 일부 클라이언트만 지원





## 재시도

무한정 재시도는 불가능. 

해도 되는 조건

* 단순 조회 기능  -> 조회는 중복 문제가 크게 발생 안함 
* 연결 타임 아웃. -> 연결 타임아웃은 연결되지 않은 것이므로 처리 안되어있을것임. 
* 멱등성(idempotent)를 가진 변경 기능



읽기 타임아웃은 재시도시 주의해야함. 처리중이였을수도 있음 

멱등성이 없어도, 중복 문제가 발생할 수 있음 

또한 같은 API라도 실패 원인에 따라 재시도 여부를 결정해야 함.

### 재시도 횟수와 간격

다음 2가지 고려

* 재시도 횟수 -> 대부분 2번정도가 적당. 2번 재시도시 총 3번 요청임. 재시도해도 실패할 확률이 높음 
* 재시도 간격  -> 간격도 너무 짧으면, 요청받는 서버가 해소가 안되어있을 수 있음 


## 서킷 브레이커

연동서비스 장애시 서킷브레이커 패턴을 이용해 연동 대신 바로 에러를 응답할 수 있음

**fast fail 패턴** 

과도한 오류 발생시 연동을 차단(중지)시키고 바로 에러를 응답하게 한다.

![image-20250530171833018](./images//image-20250530171833018.png)

* closed, open, half-open 3가지 상태를 갖는다.

닫힘 상태로 시작하며, 닫힘상태일때는 모든 요청을 전달한다.



임계치를 설정해서 닫힘-열림 상태를 판별하는데, 임계치는 다음과 같다.

* 시간 기준 오류 발생 : 10초 동안 오류 비율 50%
* 개수 기준 오류 발생 : 100개 요청 중 오류 비율이 50% 초과



서킷 브레이커가 열려 있는 동안은 연동 서비스에 요청이 전달되지 않기 때문에 연동 서비스가 과부하 상황에서 벗어날 수 있는 기회도 생긴다.

## 외부 연동과 DB 연동

DB 연동 + 외부 연동 함께 처리시, 트랜잭션을 어떻게 처리할지 알맞게 판단해야 함.

그러나, 읽기 타임아웃이 발생해 트랜잭션을 롤백시에는 외부 서비스가 실제로 성공적으로 처리했을 가능성을 염두에 둬야함. 이경우

* 일정 주기로 두 시스템 데이터 일치 여부를 비교해서 수동 또는 자동으로 보정
* 두번째는 일정 시간 후 성공 확인 API를 재호출해서 성공했는지 확인. 성공시 트랜잭션 완료, 실패시 트랜잭션 롤백 -> 제공해줘야만 가능함



### 외부 연동 DB 커넥션 풀 문제

외부연동 API 실행시 4.8초가 걸리고 db 연동시 0.2초가 걸린다면 커넥션을 5초 점유해서 문제가 생길 수 있음.

커넥션풀이 매우 모자랄 수 있기 때문.

이경우 외부연동을 커넥션 풀 밖에서 트랜잭션 커밋 후 실행하는것이 좋음. 외부 연동 실패시 보상 트랜잭션으로 데이터를 보정해야함. 

### HTTP 커넥션 풀

DB 커넥션 풀이 DB 연결에 걸리는 시간을 줄여 성능을 높이는 것처럼 HTTP 연결도 커넥션 풀을 사용하면 연결 시간을 줄일 수 있어 응답 속도 향상에 도움이 된다.

HTTP 커넥션 풀을 사용할 때는 다음 3가지를 고려해야 한다.

- ﻿HTTP 커넥션 풀의 크기
- ﻿﻿풀에서 HTTP 커넥션을 가져올 때까지 대기하는 시간
- ﻿﻿HTTP 커넥션을 유지할 시간(keep alive)

두가지를 고려해야함

1. 풀의 크기로, 연동할 서비스 성능에 따라 결정해야함
2. 대기시간. 디비풀과 마찬가지로, 커넥션을 얻기위해 대기하게됌. 0.1초는 너무 짧음. 1~5초 사이가 적당.

3. 커넥션 유지시간. http/1.1에서 Keep-Alive 헤더로 적당시간을 유지하는것이 좋다.







HTTP 커넥션 풀
연동 서비스 이중화

# **5장 비동기 연동, 언제 어떻게 써야 할까**

동기 연동과 비동기 연동
별도 스레드로 실행하기
메시징
트랜잭션 아웃박스 패턴
배치 전송
CDC(Change Data Capture)

# **6장 동시성, 데이터가 꼬이기 전에 잡아야 한다**

서버와 동시 실행
잘못된 데이터 공유로 인한 문제 예시
프로세스 수준에서의 동시 접근 제어
DB와 동시성
잠금 사용 시 주의 사항
단일 스레드로 처리하기

# **7장 IO 병목, 어떻게 해결하지**

네트워크 IO와 자원 효율
가상 스레드로 자원 효율 높이기
논블로킹 IO로 성능 더 높이기
언제 어떤 방법을 택할까

# **8장 실무에서 꼭 필요한 보안 지식**

중요한 보안
인증과 인가
데이터 암호화
HMAC을 이용한 데이터 검증
방화벽으로 필요한 트래픽만 허용하기
감사 로그(audit log) 남기기
데이터 노출 줄이기
비정상 접근 처리
시큐어 코딩
개인 보안

# **9장 최소한 알고 있어야 할 서버 지식**

개발자와 서버
OS 계정과 권한
프로세스 확인하기
백그라운드 프로세스
디스크 용량 관리
파일 디스크립터 제한
시간 맞추기
크론으로 스케줄링하기
alias 등록하기
네트워크 정보 확인

# **10장 모르면 답답해지는 네트워크 기초**

네트워크 기초를 모르면
노드, 네트워크, 라우터
IP 주소와 도메인
NAT
VPN
프로토콜과 TCP, UDP, QUIC

# **11장 자주 쓰는 서버 구조와 설계 패턴**

MVC 패턴
계층형 아키텍처
DDD와 전술 패턴
마이크로서비스 아키텍처
이벤트 기반 아키텍처
CQRS 패턴

# **부록 A: 처음 해보는 성능 테스트를 위한 기본 정리**

성능 테스트 종류
포화점과 버클존
주요 측정 지표
성능 테스트 설계 시 고려 사항
성능 테스트 도구
성능 테스트 실행 시 주의 사항

# **부록 B: NoSQL 이해하기**

NoSQL이란
NoSQL 종류
NoSQL 도입 시 고려 사항
CAP 정리

# **부록 C: DB로 분산 잠금 구현하기**

잠금 정보 저장 테이블
분산 잠금 동작
DB 잠금 구현