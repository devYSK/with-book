# 이펙티브 코틀린

[toc]

목차


- [1부: 좋은 코드](#1부-좋은-코드)
- [1장 안정성](#1장-안정성)
  - [아이템 1: 가변성을 제한하라](#아이템-1-가변성을-제한하라)
  - [아이템 2: 변수의 스코프를 최소화하라](#아이템-2-변수의-스코프를-최소화하라)
  - [아이템 3: 최대한 플랫폼 타입을 사용하지 말라](#아이템-3-최대한-플랫폼-타입을-사용하지-말라)
  - [아이템 4: inferred 타입으로 리턴하지 말라](#아이템-4-inferred-타입으로-리턴하지-말라)
  - [아이템 5: 예외를 활용해 코드에 제한을 걸어라](#아이템-5-예외를-활용해-코드에-제한을-걸어라)
  - [아이템 6: 사용자 정의 오류보다는 표준 오류를 사용하라](#아이템-6-사용자-정의-오류보다는-표준-오류를-사용하라)
  - [아이템 7: 결과 부족이 발생할 경우 null과 Failure를 사용하라](#아이템-7-결과-부족이-발생할-경우-null과-Failure를-사용하라)
  - [아이템 8: 적절하게 null을 처리하라](#아이템-8-적절하게-null을-처리하라)
  - [아이템 9: use를 사용하여 리소스를 닫아라](#아이템-9-use를-사용하여-리소스를-닫아라)
  - [아이템 10: 단위 테스트를 만들어라](#아이템-10-단위-테스트를-만들어라)
- [2장 가독성](#2장-가독성)
  - [아이템 11: 가독성을 목표로 설계하라](#아이템-11-가독성을-목표로-설계하라)
  - [아이템 12: 연산자 오버로드를 할 때는 의미에 맞게 사용하라](#아이템-12-연산자-오버로드를-할-때는-의미에-맞게-사용하라)
  - [아이템 13: Unit?을 리턴하지 말라](#아이템-13-Unit?을-리턴하지-말라)
  - [아이템 14: 변수 타입이 명확하게 보이지 않는 경우 확실하게 지정하라](#아이템-14-변수-타입이-명확하게-보이지-않는-경우-확실하게-지정하라)
  - [아이템 15: 리시버를 명시적으로 참조하라](#아이템-15-리시버를-명시적으로-참조하라)
  - [아이템 16: 프로퍼티는 동작이 아니라 상태를 나타내야 한다](#아이템-16-프로퍼티는-동작이-아니라-상태를-나타내야-한다)
  - [아이템 17: 이름 있는 아규먼트를 사용하라](#아이템-17-이름-있는-아규먼트를-사용하라)
  - [아이템 18: 코딩 컨벤션 지켜라](#아이템-18-코딩-컨벤션-지켜라)
- [2부: 코드 설계](#2부-코드-설계)
- [3장 재사용성](#3장-재사용성)
  - [아이템 19: knowledge를 반복하지 말라](#아이템-19-knowledge를-반복하지-말라)
  - [아이템 20: 일반적인 알고리즘을 반복해서 구현하지 말라](#아이템-20-일반적인-알고리즘을-반복해서-구현하지-말라)
  - [아이템 21: 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라](#아이템-21-일반적인-프로퍼티-패턴은-프로퍼티-위임으로-만들어라)
  - [아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라](#아이템-22-일반적인-알고리즘을-구현할-때-제네릭을-사용하라)
  - [아이템 23: 타입 파라미터의 섀도잉을 피하라](#아이템-23-타입-파라미터의-섀도잉을-피하라)
  - [아이템 24: 제네렉 타입과 variance 한정자를 활용하라](#아이템-24-제네렉-타입과-variance-한정자를-활용하라)
  - [아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라](#아이템-25-공통-모듈을-추출해서-여러-플랫폼에서-재사용하라)
- [4장 추상화 설계](#4장-추상화-설계)
  - [아이템 26: 함수 내부의 추상화 레벨을 통일하라](#아이템-26-함수-내부의-추상화-레벨을-통일하라)
  - [아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라](#아이템-27-변화로부터-코드를-보호하려면-추상화를-사용하라)
  - [아이템 28: API 안정성을 확인하라](#아이템-28-API-안정성을-확인하라)
  - [아이템 29: 외부 API를 랩(wrap)해서 사용하라](#아이템-29-외부-API를-랩(wrap)해서-사용하라)
  - [아이템 30: 요소의 가시성을 최소화하라](#아이템-30-요소의-가시성을-최소화하라)
  - [아이템 31: 문서로 규약을 정의하라](#아이템-31-문서로-규약을-정의하라)
  - [아이템 32: 추상화 규약을 지켜라](#아이템-32-추상화-규약을-지켜라)
- [5장 객체 생성](#5장-객체-생성)
  - [아이템 33: 생성자 대신 팩토리 함수를 사용하라](#아이템-33-생성자-대신-팩토리-함수를-사용하라)
  - [아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라](#아이템-34-기본-생성자에-이름-있는-옵션-아규먼트를-사용하라)
  - [아이템 35: 복잡한 객체를 생성하기 위한 DSL을 만들어라](#아이템-35-복잡한-객체를-생성하기-위한-DSL을-만들어라)
- [6장 클래스 설계](#6장-클래스-설계)
  - [아이템 36: 상속보다는 컴포지션을 사용하라](#아이템-36-상속보다는-컴포지션을-사용하라)
  - [아이템 37: 데이터 집합 표현에 data 한정자를 사용하라](#아이템-37-데이터-집합-표현에-data-한정자를-사용하라)
  - [아이템 38: 연산 또는 액션을 전달할 때 인터페이스 대신 함수 타입을 사용하라](#아이템-38-연산-또는-액션을-전달할-때-인터페이스-대신-함수-타입을-사용하라)
  - [아이템 39: 태그 클래스보다는 클래스 계층을 사용하라](#아이템-39-태그-클래스보다는-클래스-계층을-사용하라)
  - [아이템 40: equals의 규약을 지켜라](#아이템-40-equals의-규약을-지켜라)
  - [아이템 41: hashCode의 규약을 지켜라](#아이템-41-hashCode의-규약을-지켜라)
  - [아이템 42: compareTo의 규약을 지켜라](#아이템-42-compareTo의-규약을-지켜라)
  - [아이템 43: API의 필수적이지 않는 부분을 확장 함수로 추출하라](#아이템-43-API의-필수적이지-않는-부분을-확장-함수로-추출하라)
  - [아이템 44: 멤버 확장 함수의 사용을 피하라](#아이템-44-멤버-확장-함수의-사용을-피하라)
- [3부 효율성](#3부-효율성)
- [7장 비용 줄이기](#7장-비용-줄이기)
  - [아이템 45: 불필요한 객체 생성을 피하라](#아이템-45-불필요한-객체-생성을-피하라)
  - [아이템 46: 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라](#아이템-46-함수-타입-파라미터를-갖는-함수에-inline-한정자를-붙여라)
  - [아이템 47: 인라인 클래스의 사용을 고려하라](#아이템-47-인라인-클래스의-사용을-고려하라)
  - [아이템 48: 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라](#아이템-48-더-이상-사용하지-않는-객체의-레퍼런스를-제거하라)
- [8장 효율적인 컬렉션 처리](#8장-효율적인-컬렉션-처리)
  - [아이템 49: 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라](#아이템-49-하나-이상의-처리-단계를-가진-경우에는-시퀀스를-사용하라)
  - [아이템 50: 컬렉션 처리 단계 수를 제한하라](#아이템-50-컬렉션-처리-단계-수를-제한하라)
  - [아이템 51: 성능이 중요한 부분에는 기본 자료형 배열을 사용하라](#아이템-51-성능이-중요한-부분에는-기본-자료형-배열을-사용하라)
  - [아이템 52: mutable 컬렉션 사용을 고려하라](#아이템-52-mutable-컬렉션-사용을-고려하라)

---

# 1부: 좋은 코드


# 1장 안정성

코틀린은 안전성이 뛰어나다.

코틀린을 안전하게 사용하기 위한 방법들에 대해서 코틀린이 제공하는 기능과 올바르게 사용하는 방법을 알아보자.

## 아이템 1: 가변성을 제한하라

가변성이 발생하는 코드는 프로그래밈을 이해하고 디버그하기가 힘들어진다.

var를 사용하거나 mutable 객체를 사용하면 상태를 가질 수 있다. 

* 그러나 상태를 갖는 부분들의 관계를 이해해야 하기 때문에 상태 변경이 많아지면 이를 추적하는것이 힘들어진다.

* 가변성(mutability)이 있으면 시점에 따라 값이 달라질 수 있으므로 코드의 실행을 추론이나 예측하기 어렵다.

* 모든 상태와 조합을 테스트해야하므로 테스트하기 어렵다. 

때문에 코틀린에서는 가변성을 제한할 수 있다

- 읽기 전용 프로퍼티 val (val은 불변을 의미하는것은 아니다)
- 가변 컬렉션(mutable)과 읽기 전용(immutable) 컬렉션 구분하기
- data class의 copy



**val는 읽기 전용 프로퍼티지만, 변경할 수 없음을 의미하는 것은 아니다.** 

만약 완전히 변경할 필요가 없다면, final 프로퍼티를 사용하는 것이 좋다

* 참조에 대한 불변성(immutable reference)만을 보장하며, 참조하는 객체의 내부 상태에 대한 불변성(immutable state)은 보장하지 않는다는 의미이다.

```kotlin
data class MutableData(var data: Int)

fun main() {
    val myData = MutableData(1)

    println(myData.data)  // 출력: 1

    // val은 재할당할 수 없지만,
    myData = MutableData(999) // 에러 
    // myData = MutableData(2)  // 이런 코드는 컴파일 에러 발생

    // 객체의 내부 상태는 변경 가능
    myData.data = 2
    println(myData.data)  // 출력: 2
}
```

**가변 컬렉션(mutable)과 읽기 전용(immutable) 컬렉션 구분하기**

프로퍼티도 읽고 쓸 수 있는 프로퍼티와 읽기 전용 프로퍼티로 구분되며, 컬렉션도 읽고 쓸 수 있는 컬렉션과 읽기 전 컬렉션으로 구분된다.

* Collection과 MutableCollection,  List와 MutableList

하지만 "읽기 전용"이라고 해서 그 내부의 값이 절대 변경될 수 없는 것은 아니다. 

컬렉션 내부의 실제 객체는 가변적일 수 있으며, 참조를 통해 접근해서 변경할 수 있다. 

`"읽기 전용"`이라는 것은 해당 `컬렉션 인터페이스가 변경 연산을 지원하지 않는다`는 것만을 의미한다.

```kotlin
예를 들면, Iterables<T>.map과 Iterables<T>.filter와 같은 함수들은 내부적으로 ArrayList를 반환

public inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {
    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)
}
```

* 내부적으로 인터페이스를 사용하므로 실제 컬렉션을 리턴할 수 있으며, 플랫폼 고유의 컬렉션을 사용할 수 있다. 이는 코틀린이 내부적으로 immutable하지 않은 컬렉션을 외부적으로 immutable하게 보이게 만들어서 얻어지는 안정성이다. 

이말은 즉슨, 코틀린은 `자바와 호환성을 유지하기 위해 자바의 컬렉션과 연동`되는데 `자바 컬렉션은 가변적(mutable)`이다. 

그런데 `읽기 전용 컬렉션 인터페이스 (List 등)을 제공`함으로써, <u>실제 내부적으로 컬렉션은 가변적일 수 있지만</u>,

 '읽기 전용' 인터페이스를 통해 접근하게 되면 해당 컬렉션에 변경을 가하는 메서드를 사용할 수 없게되는것이다! 

때문에 이러한 방식으로 코틀린은 (자바의)변경 가능한 컬렉션을 안전하게(불변으로) 사용하도록 도와준다.

* 자바와의 호환성도 지키고, 불변으로도 제공할 수 있게 도와주는것이다. 

 `그러나 이는 개발자가 강제로 다운캐스팅을 할 때 문제가 된다`

```kotlin
@Test
internal fun `down casting 위반`() {
    val list = listOf(1, 2, 3) // 불변 List. 자바의 Array.ArrayList 인스턴스를 리턴한다. 
    
    if (list is MutableList) { // 강제로 다운캐스팅 
        list.add(1) // java.lang.UnsupportedOperationException 오류 발생
    }
}
```

* 읽기 전용이라는 규약을 무시하고 추상화를 무시하는 행위이다. 
* 변경은 가능하지만 Arrays.ArrayList는 이러한 연산을 구현하고 있지 않아 위와 같은 오류가 발생한다. 

만약 읽기 전용(immutable)에서 mutable로 변경해야 한다면 list.toMutableList를 활용 해야 한다.(copy 를 통해서) 

**데이터 클래스의 Copy**

String이나, Int 처럼 내부적인 상태를 변경하지 않는 immutable 객체를 많이 사용하는데 이유가 있다

1. 한 번 정의된 상태가 유지되므로, <u>코드를 이해하기 쉽습니</u>다.
2. immutable 객체는 공유했을 때도 <u>충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있</u>습니다.
3. immutable 객체에 대한 <u>참조는 변경되지 않으므로, 쉽게 캐시할 수 있습니다.</u>
4. immutable 객체는 방어적 복사본을 만들 필요가 없습니다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 됩니다.
5. immutable 객체는 다른 객체를 만들 때 활용하기 좋습니다. <u>immutable 객체는 실행을 더 쉽게 예측할 수 있습니다.</u>
6. immutable 객체는 s<u>et, map의 키로 사용할 수 있습니</u>다. 이는 set, map은 내부적으로 해시 테이블을 사용하고, 해시 테이블은 처음 요소를 넣을 때 요소의 값을 기반으로 버킷을 결정하기 때문입니다.

data 한정자의 copy 메서드는 모든 기본 생성자 프로퍼티가 같은 새로운 객체를 만들어 낼 수 있다.

```kotlin
data class User(
        val name: String,
        val surname: String,
) {
  fun withSurname(surname: String) = User(name, surname)
    
  override fun toString(): String {   
    return "User(name='$name', surname='$surname')"
  }
  
}

var user = User("Maja", "Markiewicz")
user = user.copy(surname = "Moskla")
println(user) // User(name='Maja', surname='Moskla')
```

**변경 가능한 리스트**

방법 1. mutable 컬렉션

방법 2. var로 선언

``` kotlin
val list1: MutableList<Int> = mutableListOf()
var list2: List<Int> = listOf


list1.add(1) // 이건 
list1 +=1 // 위와 같음 -> list1.plusAssign(1)로 변경됌

list2 = list2 + 1 //이건
list2 += 1 // -> list2 = list1.plus(1)로 변경됌 

```

**변경 가능 지점 노출하지 말기**

mutable 객체를 외부에 노출하지 말자.

```kotlin
data class User(val name: String)

  
class UserRepository {
  private val storedUsers: MutableMap<Int, String> = mutableMapOf()

  fun loadAll(): MutableMap<Int, String> {
    return storedUsers
  }
}

val userRepository = UserRepository()
val storedUsers = userRepository.loadAll()
storedUsers[4] = "Kirill" 
```

loadAll을 사용해서 private 상태인 UserRepositroy를 수정할 수 있게 되버린다.

때문에 읽기 전용 객체로 업캐스트 하여 가변성을 제한하자.

```kotlin
class UserRepository {
  private val storedUsers: MutableMap<Int, String> = mutableMapOf()

  fun loadAll(): Map<Int, String> { // 업캐스트 
    return storedUsers
  }
}
```



## 아이템 2: 변수의 스코프를 최소화하라



## 아이템 3: 최대한 플랫폼 타입을 사용하지 말라



## 아이템 4: inferred 타입으로 리턴하지 말라



## 아이템 5: 예외를 활용해 코드에 제한을 걸어라



## 아이템 6: 사용자 정의 오류보다는 표준 오류를 사용하라



## 아이템 7: 결과 부족이 발생할 경우 null과 Failure를 사용하라



## 아이템 8: 적절하게 null을 처리하라



## 아이템 9: use를 사용하여 리소스를 닫아라



## 아이템 10: 단위 테스트를 만들어라


# 2장 가독성

## 아이템 11: 가독성을 목표로 설계하라



## 아이템 12: 연산자 오버로드를 할 때는 의미에 맞게 사용하라



## 아이템 13: Unit?을 리턴하지 말라



## 아이템 14: 변수 타입이 명확하게 보이지 않는 경우 확실하게 지정하라



## 아이템 15: 리시버를 명시적으로 참조하라



## 아이템 16: 프로퍼티는 동작이 아니라 상태를 나타내야 한다



## 아이템 17: 이름 있는 아규먼트를 사용하라



## 아이템 18: 코딩 컨벤션 지켜라



# 2부: 코드 설계


# 3장 재사용성



## 아이템 19: knowledge를 반복하지 말라



## 아이템 20: 일반적인 알고리즘을 반복해서 구현하지 말라



## 아이템 21: 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라



## 아이템 22: 일반적인 알고리즘을 구현할 때 제네릭을 사용하라



## 아이템 23: 타입 파라미터의 섀도잉을 피하라



## 아이템 24: 제네렉 타입과 variance 한정자를 활용하라



## 아이템 25: 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라



# 4장 추상화 설계



## 아이템 26: 함수 내부의 추상화 레벨을 통일하라



## 아이템 27: 변화로부터 코드를 보호하려면 추상화를 사용하라



## 아이템 28: API 안정성을 확인하라



## 아이템 29: 외부 API를 랩(wrap)해서 사용하라



## 아이템 30: 요소의 가시성을 최소화하라



## 아이템 31: 문서로 규약을 정의하라



## 아이템 32: 추상화 규약을 지켜라



# 5장 객체 생성



## 아이템 33: 생성자 대신 팩토리 함수를 사용하라



## 아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라



## 아이템 35: 복잡한 객체를 생성하기 위한 DSL을 만들어라



# 6장 클래스 설계



## 아이템 36: 상속보다는 컴포지션을 사용하라



## 아이템 37: 데이터 집합 표현에 data 한정자를 사용하라



## 아이템 38: 연산 또는 액션을 전달할 때 인터페이스 대신 함수 타입을 사용하라



## 아이템 39: 태그 클래스보다는 클래스 계층을 사용하라



## 아이템 40: equals의 규약을 지켜라



## 아이템 41: hashCode의 규약을 지켜라



## 아이템 42: compareTo의 규약을 지켜라



## 아이템 43: API의 필수적이지 않는 부분을 확장 함수로 추출하라



## 아이템 44: 멤버 확장 함수의 사용을 피하라



# 3부 효율성



# 7장 비용 줄이기



## 아이템 45: 불필요한 객체 생성을 피하라



## 아이템 46: 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라



## 아이템 47: 인라인 클래스의 사용을 고려하라



## 아이템 48: 더 이상 사용하지 않는 객체의 레퍼런스를 제거하라



# 8장 효율적인 컬렉션 처리



## 아이템 49: 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라



## 아이템 50: 컬렉션 처리 단계 수를 제한하라



## 아이템 51: 성능이 중요한 부분에는 기본 자료형 배열을 사용하라



## 아이템 52: mutable 컬렉션 사용을 고려하라





