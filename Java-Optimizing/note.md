# 자바 최적화 - 가장 빠른 성능을 구현하는 검증된 10가지 기법

# Table of Contents

- [1. 성능과 최적화](#1-성능과-최적화)
- [2. JVM 이야기](#2-jvm-이야기)
- [3. 하드웨어와 운영체제](#3-하드웨어와-운영체제)
- [4. 성능 테스트 패턴 및 안티패턴](#4-성능-테스트-패턴-및-안티패턴)
- [5. 마이크로벤치마킹과 통계](#5-마이크로벤치마킹과-통계)
- [6. 가비지 수집 기초](#6-가비지-수집-기초)
- [7. 가비지 수집 고급](#7-가비지-수집-고급)
- [8. GC 로깅, 모니터링, 튜닝, 툴](#8-gc-로깅-모니터링-튜닝-툴)
- [9. JVM의 코드 실행](#9-jvm의-코드-실행)
- [10. JIT 컴파일의 세계로](#10-jit-컴파일의-세계로)
- [11. 자바 언어의 성능 향상 기법](#11-자바-언어의-성능-향상-기법)
- [12. 동시 성능 기법](#12-동시-성능-기법)
- [13. 프로파일링](#13-프로파일링)
- [14. 고성능 로깅 및 메시징](#14-고성능-로깅-및-메시징)
- [15. 자바 9와 미래](#15-자바-9와-미래)





# 1. 성능과 최적화
## 1.3 성능은 실험과학이다


* 원하는 결과를 정의한다.
* 기존 시스템을 측정한다.
* 요건을 충족시키려면 무슨 일을 해야 할지 정한다.
* 개선 활동을 추진한다
* 다시 테스트한다.
* 목표가 달성됐는지 판단한다

이를 반복해서 성능향상을 하기위한 연구를 한다.

## 1.4 성능 분류

일반적인 기본 성능 지표

* 처리율(throughput)
* 지연(latency)
* 용량, 사용률, 효율, 확장성, 저하

### 처리율

시스템이 수행 가능한 작업 비율을 나타낸 지표. 보통 일정 시간 동안 완료한 작업 단위 수로 표시(TPS : 초당 처리 가능한 트랜잭션 수)

### 지연

하나의 트랜잭션을 처리하고 결과를 받을때까지 소요된 시간

### 용량

capacity는 시스템의 동시 처리 가능한 작업(트랜잭션) 갯수. 

시스템에 동시 부하가 증가할수록 처리율은 영향을 받는다. 

# 2. JVM 이야기
## 2.1 인터프리팅과 클래스로딩
JVM은 스택 기반의 해석 머신. 

JVM 인터프리터의 기본 로직은, 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와

독립적으로 프로그램 구성하는 OperationCode(기계어)를 하나씩 순서대로 `처리하는 while 루프안의 switch문`



main 시작시 사슬처럼 연결된 클래스로더가 작동함.

1. 제일 먼저 부트스트랩 클래스가 자바 런타임 코어 클래스를 로드. 

* 부트스트랩 클래스 로더의 주임무는, 다른 클래스로더가 시스템에 필요한 클래스를 로드할 수 있게 최소한의 필수 클래스(java.lang.Object, Class, Classloader)만 로드

2. 확장 클래스 로더가 생성. 부트스트랩 클래스로더를 자기 부모로 설정하고 필요할 때 클래스 로딩 작업을 부모로 넘김.

3. 애플리케이션 클래스로더 생성(확장 클래스로더의 자식). 지정된 classpath에 위치한 유저 클래스를 로드.



## 2.2 바이트코드 실행

## 2.3 핫스팟 입문
## 2.4 JVM 메모리 관리
## 2.5 스레딩과 자바 메모리 모델(JMM)
## 2.6 JVM 구현체 종류
## 2.7 JVM 모니터링과 툴링
## 2.8 마치며

# 3. 하드웨어와 운영체제
## 3.1 최신 하드웨어 소개
## 3.2 메모리
## 3.3 최신 프로세서의 특성
## 3.4 운영체제
## 3.5 단순 시스템 모델
## 3.6 기본 감지 전략
## 3.7 가상화
## 3.8 JVM과 운영체제
## 3.9 마치며

# 4. 성능 테스트 패턴 및 안티패턴
## 4.1 성능 테스트 유형
## 4.2 기본 베스트 프랙티스
## 4.3 성능 안티패턴 개요
## 4.4 성능 안티패턴 카탈로그
## 4.5 인지 편향과 성능 테스트
## 4.6 마치며

# 5. 마이크로벤치마킹과 통계
## 5.1 자바 성능 측정 기초
## 5.2 JMH 소개
## 5.3 JVM 성능 통계
## 5.4 통계치 해석
## 5.5 마치며

# 6. 가비지 수집 기초
## 6.1 마크 앤 스위프
## 6.2 핫스팟 런타임 개요
## 6.3 할당과 수명
## 6.4 핫스팟의 가비지 수집
## 6.5 병렬 수집기
## 6.6 할당의 역할
## 6.7 마치며

# 7. 가비지 수집 고급
## 7.1 트레이드오프와 탈착형 수집기
## 7.2 동시 GC 이론
## 7.3 CMS
## 7.4 G1
## 7.5 셰난도아
## 7.6 C4(아줄 징)
## 7.7 밸런스드(IBM J9)
## 7.8 레거시 핫스팟 수집기
## 7.9 마치며

# 8. GC 로깅, 모니터링, 튜닝, 툴
## 8.1 GC 로깅 개요
## 8.2 로그 파싱 툴
## 8.3 GC 기본 튜닝
## 8.4 Parallel GC 튜닝
## 8.5 CMS 튜닝
## 8.6 G1 튜닝
## 8.7 jHiccup
## 8.8 마치며

# 9. JVM의 코드 실행
## 9.1 바이트코드 해석
## 9.2 AOT와 JIT 컴파일
## 9.3 핫스팟 JIT 기초
## 9.4 코드 캐시
## 9.5 간단한 JIT 튜닝법
## 9.6 마치며

# 10. JIT 컴파일의 세계로
## 10.1 JITWatch란?
## 10.2 JIT 컴파일 개요
## 10.3 인라이닝
## 10.4 루프 펼치기
## 10.5 탈출 분석
## 10.6 단형성 디스패치
## 10.7 인트린직
## 10.8 온-스택 치환
## 10.9 세이프포인트 복습
## 10.10 코어 라이브러리 메서드
## 10.11 마치며

# 11. 자바 언어의 성능 향상 기법
## 11.1 컬렉션 최적화
## 11.2 List 최적화
## 11.3 Map 최적화
## 11.4 Set 최적화
## 11.5 도메인 객체
## 11.6 종료화 안 하기
## 11.7 메서드 핸들
## 11.8 마치며

# 12. 동시 성능 기법
## 12.1 병렬성이란?
## 12.2 JMM의 이해
## 12.3 동시성 라이브러리 구축
## 12.4 동시 라이브러리 정리
## 12.5 실행자와 태스크 추상화
## 12.6 최신 자바 동시성
## 12.7 마치며

# 13. 프로파일링
## 13.1 프로파일링 개요
## 13.2 샘플링과 세이프포인팅 편향
## 13.3 개발자용 프로파일링 툴
## 13.4 최신 프로파일러
## 13.5 할당 프로파일링
## 13.6 힙 덤프 분석
## 13.7 마치며

# 14. 고성능 로깅 및 메시징
## 14.1 로깅
## 14.2 성능에 영향이 적은 로거 설계하기
## 14.3 리얼 로직 라이브러리를 이용해 지연 줄이기
## 14.4 마치며

# 15. 자바 9와 미래
## 15.1 자바 9에서 소소하게 개선된 성능
## 15.2 자바 10과 그 이후 버전
## 15.3 자바 9 Unsafe 그 너머
## 15.4 발할라 프로젝트와 값 타입
## 15.5 그랄과 트러플
## 15.6 바이트코드의 향후 발전 방향
## 15.7 동시성의 향후 발전 방향
## 15.8 마치며