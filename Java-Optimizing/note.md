# 자바 최적화 - 가장 빠른 성능을 구현하는 검증된 10가지 기법

# Table of Contents

- [1. 성능과 최적화](#1-성능과-최적화)
- [2. JVM 이야기](#2-jvm-이야기)
- [3. 하드웨어와 운영체제](#3-하드웨어와-운영체제)
- [4. 성능 테스트 패턴 및 안티패턴](#4-성능-테스트-패턴-및-안티패턴)
- [5. 마이크로벤치마킹과 통계](#5-마이크로벤치마킹과-통계)
- [6. 가비지 수집 기초](#6-가비지-수집-기초)
- [7. 가비지 수집 고급](#7-가비지-수집-고급)
- [8. GC 로깅, 모니터링, 튜닝, 툴](#8-gc-로깅-모니터링-튜닝-툴)
- [9. JVM의 코드 실행](#9-jvm의-코드-실행)
- [10. JIT 컴파일의 세계로](#10-jit-컴파일의-세계로)
- [11. 자바 언어의 성능 향상 기법](#11-자바-언어의-성능-향상-기법)
- [12. 동시 성능 기법](#12-동시-성능-기법)
- [13. 프로파일링](#13-프로파일링)
- [14. 고성능 로깅 및 메시징](#14-고성능-로깅-및-메시징)
- [15. 자바 9와 미래](#15-자바-9와-미래)





# 1. 성능과 최적화
## 1.3 성능은 실험과학이다


* 원하는 결과를 정의한다.
* 기존 시스템을 측정한다.
* 요건을 충족시키려면 무슨 일을 해야 할지 정한다.
* 개선 활동을 추진한다
* 다시 테스트한다.
* 목표가 달성됐는지 판단한다

이를 반복해서 성능향상을 하기위한 연구를 한다.

## 1.4 성능 분류

일반적인 기본 성능 지표

* 처리율(throughput)
* 지연(latency)
* 용량, 사용률, 효율, 확장성, 저하

### 처리율

시스템이 수행 가능한 작업 비율을 나타낸 지표. 보통 일정 시간 동안 완료한 작업 단위 수로 표시(TPS : 초당 처리 가능한 트랜잭션 수)

### 지연

하나의 트랜잭션을 처리하고 결과를 받을때까지 소요된 시간

### 용량

capacity는 시스템의 동시 처리 가능한 작업(트랜잭션) 갯수. 

시스템에 동시 부하가 증가할수록 처리율은 영향을 받는다. 

# 2. JVM 이야기
## 2.1 인터프리팅과 클래스로딩
JVM은 스택 기반의 해석 머신. 

JVM 인터프리터의 기본 로직은, 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와

독립적으로 프로그램 구성하는 OperationCode(기계어)를 하나씩 순서대로 `처리하는 while 루프안의 switch문`



XXX.class파일의 main 시작시 사슬처럼 연결된 클래스로더가 작동함.

1. 제일 먼저 부트스트랩 클래스가 자바 런타임 코어 클래스를 로드. 
   * 부트스트랩 클래스 로더의 주임무는, 다른 클래스로더가 시스템에 필요한 클래스를 로드할 수 있게 최소한의 필수 클래스(java.lang.Object, Class, Classloader)만 로드


2. 확장 클래스 로더가 생성. 부트스트랩 클래스로더를 자기 부모로 설정하고 필요할 때 클래스 로딩 작업을 부모로 넘김.

3. 애플리케이션 클래스로더 생성되고(확장 클래스로더의 자식). 지정된 classpath에 위치한 유저 클래스를 로드.
   * 시스템 클래스 로더라고 하면 안되고 애플리케이션 클래스로더하는것이 옳다. 




정리하자면

- **단계 1: 부트스트랩 클래스 로더**
  - **역할**: 자바의 핵심 라이브러리 클래스들을 로드합니다.
  - **특징**: 가장 기본적인 클래스 로더로, 모든 다른 클래스 로더의 최상위에 위치합니다.
  - **변화**: 자바 9 이후로, 클래스 로딩 방식이 모듈화되어 변경되었습니다.
- **단계 2: 확장 클래스 로더**
  - **역할**: 특정 플랫폼에 특화된 라이브러리(예: 네이티브 코드)를 로드합니다.
  - **예시**: 자바 8에서는 JavaScript 런타임인 Nashorn을 로드하는데 사용됩니다.
- **단계 3: 애플리케이션 클래스 로더**
  - **역할**: 사용자 정의 클래스 또는 추가된 라이브러리를 로드합니다.
  - **기능**: 특정 클래스가 시스템에 없을 경우, 클래스 경로에서 해당 클래스를 찾아 로드합니다.



자바는 프로그램 실행중 처음보는 클래스를 dependency에 로드한다 (의존체 )

각 클래스 로더는 부모-자식 관계를 가지며, 클래스 로드 요청을 받았을 때 자신이 로드할 수 없는 경우 부모 클래스 로더에게 요청을 전달하여 찾는다.. 이 과정을 통해, 요청은 최상위인 부트스트랩 클래스 로더까지 올라갈 수 있다.

- 최상위 로더까지 클래스를 찾지 못하면 `ClassNotFoundException` 예외가 발생.

* **자바에서 클래스는 패키지명을 포함한 풀 클래스명과, 자신을 로드한 클래스로더 2가지 정보로 식별된다.** 

## 2.2 바이트코드 실행

javac가 자바 소스코드를 바이트코드 파일인 .class로 바꾼다.

* 자바소스코드를 컴파일해서 클래스파일은 만든다.

JVM은 클래스를 로드할 때 올바른 형식을 준수하는지 빠짐없이 검사한다.

JVM 클래스 파일 구조는 다음으로 이루어져 있다.

| 컴포넌트                    | 설명                                                         | 추가 설명                                                    |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 매직 넘버 (Magic Number)    | OXCAFEBABE                                                   | 클래스 파일임을 식별하는 고유의 코드                         |
| 클래스 파일 포맷 버전       | 클래스 파일의 메이저/마이너 버전                             | JVM 호환성을 보장하기 위해 필요                              |
| 상수 풀 (Constant Pool)     | 클래스 상수들이 모여 있는 위치                               | 코드에서 사용되는 다양한 상수와 심볼의 참조를 저장           |
| 액세스 플래그 (Access Flag) | 추상 클래스, 정적 클래스 등 클래스 종류를 표시 (public, final인지 ) | 클래스의 접근 제어와 관련된 플래그                           |
| this 클래스                 | 현재 클래스명                                                | 클래스 파일이 정의하는 현재 클래스의 이름                    |
| 슈퍼클래스 (Superclass)     | 슈퍼클래스(부모클래스)명                                     | 현재 클래스의 부모 클래스의 이름                             |
| 인터페이스 (Interface)      | 클래스가 구현한 모든 인터페이스                              | 클래스가 구현하고 있는 인터페이스 목록                       |
| 필드 (Field)                | 클래스에 들어 있는 모든 필드                                 | 클래스 내 정의된 변수들                                      |
| 메서드 (Method)             | 클래스에 들어 있는 모든 메서드                               | 클래스에 정의된 함수 또는 메서드                             |
| 속성 (Attribute)            | 클래스가 지닌 모든 속성(예: 소스 파일명 등)                  | 클래스와 관련된 추가 정보, 예를 들어 디버그 정보, 소스 파일명 등 |

* 모든 클래스 파일은 OXCAFEBABE라는 매직 넘버, 즉 이 파일이 클래스 파일임을 나타내는 4바 이트 16진수로 시작

다음코드를 컴파일하면

```java
public class HelloWorld {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.println("Hello World");
        }
    }
}
```

다음 바이트코드가 나온다

```java
Compiled from "HelloWorld.java"
public class HelloWorld {
  public HelloWorld();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: iconst_0
       1: istore_1
       2: iload_1
       3: bipush        10
       5: if_icmpge     26
       8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      11: ldc           #3                  // String Hello World
      13: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      16: iinc          1, 1
      19: goto          2
      22: return
}

```

## 2.3 핫스팟 입문

### JIT 컴파일이란?

자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작된다.

* 프로그램이 최대로 성능을 내려면 네이티브 기능을 활용해 CPU에서 직접 프로그램을 실행시켜야 한다

자바의 JIT(Just-In-Time, 적시, 그때그때 하는) 컴파일은 자바 프로그램이 실행될 때 바이트코드를 기계어로 변환하는 과정이다.

바이트코드를 네이티브 코드(기계어)로 컴파일 한다. 

### JIT 컴파일의 작동 방식

1. **코드 로딩**: 자바 애플리케이션을 실행하면 JVM은 먼저 자바 클래스 파일들을 로드하고, 이 파일들을 포함하는 바이트코드를 인터프리터를 통해 실행합니다.
2. **성능 분석**: 인터프리터는 실행 중에 각 코드 부분의 성능을 분석합니다. 자주 실행되는 코드 블록(핫스팟이라고 불림)을 식별합니다.
3. **JIT 컴파일**: 핫스팟으로 식별된 코드는 JIT 컴파일러에 의해 기계어로 컴파일됩니다. 이 과정에서 최적화가 수행되어, 해당 코드 블록의 실행 속도가 향상됩니다.
4. **실행**: 일단 JIT 컴파일러에 의해 기계어로 번역된 코드는 직접 실행됩니다. 이후 해당 코드가 실행될 때마다 JVM은 기계어로 번역된 코드를 직접 실행하여 성능이 개선됩니다.

### JIT 컴파일의 장점

- **성능 향상**: JIT 컴파일은 프로그램의 실행 속도를 향상시키며, 특히 반복적으로 사용되는 코드에서 그 효과가 두드러집니다.
- **런타임 최적화**: 실행 시간에 프로그램의 실제 사용 패턴에 따라 최적화를 수행할 수 있어, 전통적인 컴파일 방식보다 더 효율적인 경우가 많습니다.
- **동적 어댑티브 최적화**: 프로그램의 실행 환경과 사용 패턴에 맞추어 지속적으로 최적화를 조정할 수 있습니다.

### JIT 컴파일의 단점

- **초기 부하**: JIT 컴파일 과정은 실행 초기에 추가적인 처리 시간을 필요로 합니다. 따라서, 프로그램이 짧게 실행되거나 한 번만 실행되는 경우, JIT 컴파일의 이점이 크게 나타나지 않을 수 있습니다.
- **메모리 사용량 증가**: JIT 컴파일 과정에서 생성된 기계어 코드를 저장하기 위해 추가적인 메모리가 필요합니다.



## 2.4 JVM 메모리 관리

자바는 가비지 수집으로 힙메모리를 자동 관리한다.

* 가비지 수집이란 불필요한 메모리 회수하거나 재사용하는 불확정적 프로세스다



## 2.5 스레딩과 자바 메모리 모델(JMM)

1990년대 후반부터 자바의 멀티스레드 방식은 다음 세 가지 기본 설계 원칙에 기반합니다.

- ﻿﻿자바 프로세스의 모든 스레드는 가비지가 수집되는 하나의 공용 힙을 가진다.
- ﻿﻿한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스할 수 있다.
- ﻿﻿기본적으로 객체는 변경 가능하다. 즉, 객체 필드에 할당된 값은 프로그래머가 애써 final 키워드로 불변 표시하지 않는 한 바뀔 수 있다.



## 2.7 JVM 모니터링과 툴링
JVM 모니터링 기술

* 자바 관리 확장 (JMX) : JVM과 애플리케이션을 제어하고 모니터링하는 툴. 메서드 호출 및 매개변수 변경 가능 
* 자바 에이전트 : 자바로 작성된 툴 컴포넌트. 메서드 바이트코드를 조작한다
  * JVM에 시작플래그를 추가해서 설치한다. `-javaagent:<에이전트 Jar 파일이 위치한 경로>=<옵션>`
* JVM 툴 인터페이스
* 서비스어빌리티 에이전트

# 4. 성능 테스트 패턴 및 안티패턴
## 4.1 성능 테스트 유형
### 지연 테스트(Latency test)

종단 트랜잭션에 걸리는 시간은?



### 처리율 테스트(Throughput test)

현재 시스템이 처리 가능한 동시 트랜잭션 개수는?



### 부하 테스트(Load test)

특정 부하를 시스템이 감당할 수 있는가?

-> 애플리케이션 트래픽이 상당할것으로 예상되는 특정 비즈니스 이벤트(광고, 소셜미디어이벤트, 바이럴콘텐츠)를 대비

### 스트레스 테스트(Stress test)

이 시스템의 한계점은 어디까지인가?

시스템 여력 테스트.

일정한 수준의 특정 처리율을 시스템에 계속 걸어놓는다.

측정값이 나빠지기 시작하기 직전 값이 최대 처리율 



### 내구성 테스트(Endurance test)

시스템을 장시간 실행할 경우 성능 이상 증상이 나타나는가?

메모리 누수, 캐시 오염, 메모리 단편화 등을 테스트 

### 용량 계획 테스트(Capacity planning test)

리소스를 추가한 만큼 시스템이 확장되는가?



### 저하 테스트(Degradation)

시스템이 부분적으로 실패할 경우 어떤 일이 벌어지나?

페일오버 테스트. 

부분 실패 테스트 중에는 카오스 멍키Chtos Monkey (혼돈의 원숭이)라는 하위 유형이 있습니다.

넷플릭스에서 자사 인프라의 견고함을 검증하려고 수행한 프로젝트명에서 유래됐죠.

카오스 멍키의 요지는, 진짜 복원성 있는 아키텍처에서는 어느 한 컴포넌트가 잘못돼도 다른 컴포넌트까지 연쇄적으로 무너뜨리면서 전체 시스템에 부정적 영향을 끼치는 일은 없어야 한 다는 겁니다.

**실제로 운영 환경에 떠 있는 라이브 프로세스를 하나씩 랜덤하게 죽이면서 검증하죠.**

## 4.2 기본 베스트 프랙티스

성능 튜닝 시 주안점을 두어야 할 부분은 다음 세 가지 기본 원칙에 따라 결정합니다.

- ﻿﻿나의 관심사가 무엇인지 식별하고 그 측정 방법을 고민한다.
- ﻿﻿최적화하기 용이한 부분이 아니라. 중요한 부분을 최적화한다.
- ﻿﻿중요한 관심사를 먼저 다룬다.

## 테스트 환경 구축 

가급적이면 운영환경과 똑같이 복제해야 한다

서버 (CPU 수, OS, 자바 버전), 웹 서버, DB, 로드 밸런서, 서드파티 서비스 등 

성능을 평가하는 지표는 코드 관점에서만 생각해서도 안 되고, 시스템을 전체적으로 바라보며 고객과 경영진에게 중요한 측정값을 고려해야 합니다. 이렇게 최적화하려는 핵심 지표를 성능 비기능 요건Nonf uncional Requiremen (NFR)이라고 합니다.

어떤 목표는 아주 명확합니다.

- ﻿﻿95% 백분위percenille 트랜잭션 시간을 100밀리초 줄인다.
- ﻿﻿기존 하드웨어 처리율을 5배 높일 수 있게 시스템을 개선한다.
- ﻿﻿평균 응답 시간을 30% 줄인다.

조금 모호한 목표도 있습니다.

- ﻿﻿일반 고객을 서비스하는 리소스 비용을 50% 줄인다.
- ﻿﻿애플리케이션 클러스터 성능이 50% 떨어져도 시스템이 응답 목표를 25% 이내로 유지한다.
- ﻿﻿고객 '이탈률cop -off rate'을 25밀리초 지연당 2.5% 낮춘다.

# 5. 마이크로벤치마킹과 통계
## 5.1 자바 성능 측정 기초


## 5.2 JMH 소개

JMH는 자바를 비롯해 JVM을 타깃으로 하는 언어로 작성된 나노/마이크로/밀리/매크로 벤치마크

를 제작, 실행, 분석하는 자바 도구입니다.



## 5.3 JVM 성능 통계

## 5.4 통계치 해석
## 5.5 마치며

# 6. 가비지 수집 기초
## 6.1 마크 앤 스위프
## 6.2 핫스팟 런타임 개요
## 6.3 할당과 수명
## 6.4 핫스팟의 가비지 수집
## 6.5 병렬 수집기
## 6.6 할당의 역할
## 6.7 마치며

# 7. 가비지 수집 고급
## 7.1 트레이드오프와 탈착형 수집기
## 7.2 동시 GC 이론
## 7.3 CMS
## 7.4 G1
## 7.5 셰난도아
## 7.6 C4(아줄 징)
## 7.7 밸런스드(IBM J9)
## 7.8 레거시 핫스팟 수집기
## 7.9 마치며

# 8. GC 로깅, 모니터링, 튜닝, 툴
## 8.1 GC 로깅 개요
## 8.2 로그 파싱 툴
## 8.3 GC 기본 튜닝
## 8.4 Parallel GC 튜닝
## 8.5 CMS 튜닝
## 8.6 G1 튜닝
## 8.7 jHiccup
## 8.8 마치며

# 9. JVM의 코드 실행
## 9.1 바이트코드 해석
## 9.2 AOT와 JIT 컴파일
## 9.3 핫스팟 JIT 기초
## 9.4 코드 캐시
## 9.5 간단한 JIT 튜닝법
## 9.6 마치며

# 10. JIT 컴파일의 세계로
## 10.1 JITWatch란?
## 10.2 JIT 컴파일 개요
## 10.3 인라이닝
## 10.4 루프 펼치기
## 10.5 탈출 분석
## 10.6 단형성 디스패치
## 10.7 인트린직
## 10.8 온-스택 치환
## 10.9 세이프포인트 복습
## 10.10 코어 라이브러리 메서드
## 10.11 마치며

# 11. 자바 언어의 성능 향상 기법
## 11.1 컬렉션 최적화
## 11.2 List 최적화
## 11.3 Map 최적화
## 11.4 Set 최적화
## 11.5 도메인 객체
## 11.6 종료화 안 하기
## 11.7 메서드 핸들
## 11.8 마치며

# 12. 동시 성능 기법
## 12.1 병렬성이란?
## 12.2 JMM의 이해
## 12.3 동시성 라이브러리 구축
## 12.4 동시 라이브러리 정리
## 12.5 실행자와 태스크 추상화
## 12.6 최신 자바 동시성
## 12.7 마치며

# 13. 프로파일링
## 13.1 프로파일링 개요
## 13.2 샘플링과 세이프포인팅 편향
## 13.3 개발자용 프로파일링 툴
## 13.4 최신 프로파일러
## 13.5 할당 프로파일링
## 13.6 힙 덤프 분석
## 13.7 마치며

# 14. 고성능 로깅 및 메시징
## 14.1 로깅
## 14.2 성능에 영향이 적은 로거 설계하기
## 14.3 리얼 로직 라이브러리를 이용해 지연 줄이기
## 14.4 마치며

# 15. 자바 9와 미래
## 15.1 자바 9에서 소소하게 개선된 성능
## 15.2 자바 10과 그 이후 버전
## 15.3 자바 9 Unsafe 그 너머
## 15.4 발할라 프로젝트와 값 타입
## 15.5 그랄과 트러플
## 15.6 바이트코드의 향후 발전 방향
## 15.7 동시성의 향후 발전 방향
## 15.8 마치며