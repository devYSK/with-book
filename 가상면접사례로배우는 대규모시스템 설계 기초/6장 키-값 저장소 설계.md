# 6장 키-값 저장소 설계

[toc]



키-값 저장소(key-value store)는 비 관계형 데이터베이스(NoSQL)다.

이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 한다.

키 값 쌍에서의 키는 유일해야 하며 해당 키 값은 키를 통해서만 접근할 수 있다.

키는 일반 텍스트일 수도 있고 해시 값일 수도 있다.

성능상의 이유로 키는 짧을수록 좋다.

- 일반 텍스트 키 : “last_logged_in_at”
- 해시 키 : 253DDEC4

값은 문자열, 리스트, 객체 일수도 있다.

* 아마존 다이나모, memcached, 레디스 등이 있다.



## 키 값 저장소에서 키의 길이가 짧을수록 성능상 이점이 있는 이유

키의 길이가 짧을수록 전체 시스템의 메모리, 네트워크, 디스크 I/O, 캐싱 등의 효율이 향상되므로 성능상 이점이 있다.

1. **메모리 효율**: 키의 길이가 짧으면 같은 수의 키를 저장하기 위해 필요한 메모리 공간이 줄어든다. 
2. **검색 속도**: 키의 길이가 짧을수록 키를 비교하는 데 걸리는 시간이 짧아진다. 특히 해시 테이블과 같은 자료구조에서 키를 검색할 때, 키의 길이가 길면 길이만큼 비교해야 하므로 검색 속도가 느려질 수 있다.
3. **네트워크 효율**: 클라이언트와 서버 사이에서 데이터를 주고받을 때 키의 길이가 짧으면 전송해야 할 데이터의 크기가 작아진다. 따라서 네트워크 대역폭을 효율적으로 사용할 수 있으며, 응답 시간도 개선된다.
4. **디스크 I/O 효율**: 디스크에 저장할 때도 키의 길이가 짧으면 디스크 공간을 더 효율적으로 사용할 수 있으며, 디스크에서 읽고 쓰는 속도도 향상된다.
5. **캐싱 효율**: 키의 길이가 짧으면 캐시에 더 많은 키를 저장할 수 있으므로 캐시 히트율이 향상될 수 있다.

# 문제 이해 및 설계 범위 확정

### 키-값 저장소 설계 요구사항

다음의 특성을 갖는 키-값 저장소를 설계해보자.

- 키-값 쌍의 크기는 10KB 이하
- 큰 데이터 저장 가능
- 높은 가용성(장애 시에도 빠르게 응답)
- 높은 규모 확장성(트래픽 양에 따라 자동 서버 증설 및 삭제 가능)
- 데이터 일관성 수준 조절 가능
- 응답 지연시간(latency) 최소

# 단일 서버 키-값 저장소

먼저 한 대의 서버만 사용하는 키-값 저장소를 설계해보자.

메모리에 해시 테이블로 키-값 쌍을 모두 저장하는 것은 어떨까?

이 방법은 빠르지만, 모든 데이터를 메모리에 저장하는 것은 현실적으로 불가능하다.

이 문제점을 해결하는 방법은 다음과 같다.

- 데이터 압축
- 데이터를 메모리와 디스크에 분할하여 저장

단일 키-값 저장소는 한계가 있으므로, 분산 저장소를 고려해야 한다.

# 분산 키-값 저장소

분산 해시 테이블이라고도 불린다.

키-값 쌍을 여러 서버에 분산시키는 탓이다.

분산 시스템 설계시에는 `CAP 이론`을 알아야 한다.

## **CAP 이론 (Consistency, Availability, Partition Tolearnace thorem)**

CAP 이론은 분산 컴퓨팅 시스템에서의 특정한 트레이드오프를 설명하는 이론이며

* 데이터 일관성(consistency), 
* 가용성(availability), 
* 파티션 감내성 혹은 결함성 (partition tolerance) 

라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하고, 

이들 가운데 두 가지를 충족하려면 나머지 하나는 반드시 희생 되어야 한다는 정리이다.

- 일관성(consistency)
  - 클라이언트는 어떤 노드에 접속 했느냐에 관계 없이 항상 같은 데이터를 읽어야 한다. 즉, 시스템의 모든 읽기 작업은 최신의 쓰기 작업을 반영해야한다.
- 가용성(availability)
  - 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받아야 한다. 어떠한 경우에도 요청에 대한 응답이 지연되어서는 안된다.
- 파티션 감내성(partition tolerance)
  - 네트워크에 파티션이 생겨 고립되더라도, 두 노드 사이 통신 장애가 발생해도, 시스템은 계속 동작해야 한다.

<img src="./images/6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8//image-20230806222225460.png" width = 500 height = 450>

키값 저장소는 앞서 제시한 세 가지 요구사항 가운데 어느 두 가지를 만족하 느냐에 따라 다음과 같이 분류할 수 있다.

- ﻿﻿CP 시스템: 일관성과 파티션 감내를 지원하는 키-값 저장소. `가용성을 희생`한다.
- ﻿﻿AP 시스템: 가용성과 파티션 감내를 지원하는 키값 저장소. `데이터 일관성 을 희생`한다.
- ﻿﻿CA 시스템: 일관성과 가용성을 지원하는 키값 저장소. 파티션 감내는 지원 하지 않는다. 

그러나 통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.
그러므로 `실세계에 CA 시스템은 존재하지 않는다.`

* CP, AP만 존재할 수 있다.

## 이상적 상태

<img src="./images/6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8//image-20230806222431845.png" width = 400 height = 400>

이상적 환경이라면, 네트워크가 파티션되는 상황은 절대로 일어나지 않을것이다. (제발...)

* 네트워크가 파티션되는 상황이란, 네트워크의 일부분이나 노드들 간의 연결이 끊어져 서로 통신할 수 없는 상태를 의미

- 첫번째 노드(n1)와 n2, n3가 서로 연결되어 있다.
- 데이터 일관성과 가용성 모두 만족한다.

## 실세계 분산 시스템

분산 시스템은 파티션 문제를 피할 수 없다. 

그리고 파티션 문제가 발생하면 우리는 일관성(C) 과 가용성(A) 사이에서 하나를 선택해야 한다

* 파티션 감내성은 무조건 챙겨야 하기 때문이다.

<img src="./images/6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8//image-20230806222744454.png" width = 500 height =500>

n3에 장애가 발생하여 n1, n2와 통신하지 못하는 상태.

- 만약 n3에 장애가 발생한다면, 클라이언트가 n1, n2에 기록한 데이터가 n3에 전달되지 않는다.
- 따라서, 일관성을 만족하지 못한다.

가용성 대신 일관성을 선택한다면 (CP 시스템) 데이터 불일치 문제를 피하기 위해 n1, n2에 대한 쓰기 연산을 중단 시켜야 하는데

그러면 가용성(A)가 깨진다.

* 은행권은 보통 일관성을 양보하지 않는다. 큰문제가 발생하기 때문이다. 그래서 매번 오류를 반환한다

하지만 일관성 대신 가용성을 선택한 시스템(AP 시스템)은 설사 낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용해야 한다. 

아울러 n1과 n2는 계속 쓰기 연산을 허용할 것이고, 파티션 문제가 해결된 뒤에 새 데이터 를 n3에 전송할 것이다.

# 시스템 컴포넌트 - 키-값 저장소 구현에 사용될 핵심 컴포넌트 들 및 기술들

- 데이터 파티션(partition)
- 데이터 다중화(replication)
- 일관성(consistency)
- 일관성 불일치 해소(inconsistency resolution)
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로(write path)
- 읽기 경로(read path)



## 데이터 파티션(partition)

대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다. 

`가장 단순한 해결책은 데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것`



**데이터를 파티션 단위로 나눌 때는 다음 두가지 문제를 중요하게 따져봐야 한다.**

- 데이터를 여러 서버에 고르게 분산할 수 있는가
- 노드를 추가 하거나 삭제할 때 데이터의 이동을 최소화할 수 있는가?

안정 해시(consistent hash)는 이런 문제를 푸는 적합한 기술이다.

안정 해시를 사용하여 데이터를 파티션하면 좋은 점은 다음과 같다.

- ﻿﻿규모 확장 자동화(automatic scaling): 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제 되도록 만들 수 있다.
- ﻿﻿다양성(heterogeneity): 각 서버의 용량에 맞게 가상 노드(virtual node, 상 세한 내용은 5장 참조)의 수를 조정할 수 있다.
  -  다시 말해, 고성능 서버는 더 많은 가상 노드를 갖도록 설정할 수 있다.

## 데이터 다중화(replication)

높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으 로 다중화(replication)할 필요가 있다. 

* N은 튜닝 가능한 값

데이터를 N개 서버에 비동기적으로 다중화하려고 할 때, N개의 서버를 어떻게 선택할까?

키를 해시 링 위에 배치하여 그 지점으로부터 시계 방향으로 링을 순회하여 만나는 첫 N개 서버에 데이터 사본을 보관한다.

아래 예제는 N=3 으로 설정하여 key0이 s1, s2, s3 에 사본이 저장된다.

```plaintext
 s0 (key0)-> s1 -> s2 -> s3 --> ...
```

* 안정성을 담보하기 위해 데이터의 사본은 다른 센터의 서버에 보관하고, 센터들은 고속 네트워크로 연결한다.

## 데이터 일관성(consistency)

`여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.` 

`정족수 합의 프로토콜`을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다. 

이 프로토콜은 3가지 값이 필요하다.

- ﻿﻿N = 사본 개수.
- ﻿﻿W= 쓰기 연산에 대한 정족수.
  -  쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 웅답을 받아야 한다.
  - W가 3이라면, 쓰기를 수행할 때 적어도 3개의 서버가 쓰기 연산을 성공적으로 처리했다는 응답을 보내야 한다.
  - W의 값을 높게 설정하면 쓰기 연산의 신뢰도가 증가하지만, 성능은 저하될 수 있다.
- ﻿﻿R = 읽기 연산에 대한 정족수. 
  - 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 한다.
  - R이 2라면, 읽기를 수행할 때 적어도 2개의 서버가 응답해야 읽기 연산이 성공한 것으로 간주된다.
  - R의 값을 낮추면 읽기 연산의 성능이 향상되지만, 데이터의 신뢰도는 저하될 수 있다.

> w = 1 의 의미는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야 한다는 뜻

W, R, N의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾아야 한다. 

이것은 상황에 따라 다르며, 다음과 같이 분류할 수 있다.

- ﻿R=1, W=N: 빠른 읽기 연산에 최적화된 시스템
  - 읽기 연산은 단 한 개의 서버로부터 응답만 받으면 되므로 매우 빠르다.
  - 쓰기 연산은 모든 N개의 서버에 성공해야 하므로 상대적으로 느리다.
- ﻿W=1, R=N: 빠른 쓰기 연산에 최적화된 시스템
  - 쓰기 연산은 단 한개의 서버로부터 응답만 받으면 되므로 매우 빠르다
  - 읽기 연산은 모든 N개의 서버에 성공해야 하므로 상대적으로 느리다
- ﻿﻿W + R > N: 강한 일관성이 보장됨 (보통 N=3, W=R=2)
  - W와 R의 합이 N보다 크므로, 쓰기와 읽기 사이에 겹치는 서버가 최소한 하나 이상 있어야 하며, 이로 인해 최신의 값을 읽을 수 있게 된다.
- ﻿﻿W + R <= N: 강한 일관성이 보장되지 않음
  - W와 R의 합이 N보다 작거나 같으면, 일부 쓰기 연산은 읽기 연산이 감지하지 못할 수 있다.



## 일관성 모델 (consistency model)

비즈니스의 특성과 요구사항에 따라서 일관성의 정도를 결정해야 한다.

일관성 수준의 정도는 다음과 같다.

- 강한 일관성(strong consistency)
  - 모든 읽기는 가장 최근에 갱신된 결과를 반환한다. 절대로 오래된 데이터를 보지 못한다.
- 약한 일관성(weak consistency)
  - 모든 읽기가 가장 최근에 갱신된 결과를 반환하지 못 할 수도 있다.
- 최종 일관성(eventual consistency)
  - 약한 일관성 중 하나의 형태다
  - 갱신 결과가 결국에는 모든 사본에 동기화(반영)된다.



강한 일관성을 달성하는 일반적인 방법은, 모든 사본에 현재 쓰기 연산의 결과 가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지하는 것이다

**주의할 점은, 강한 일관성 모델은 고가용성 시스템에는 적합하지 않다는 것이다. 왜 일까?**

* 고가용성 시스템에서, 새로운 요청의 처리가 중단되고 지연되기 때문이다.

어떤 DB가 최종 일관성 모델일까?

- 다이나모와 카산드라가 있다.

## 비 일관성 해소 기법

### 데이터 버저닝

데이터를 다중화할 때 피할 수 없는 문제는?

- 가용성은 보장되지만 사본 간 일관성을 지키기가 어렵다는 점
- 이를 해결하기 위한 것이 버저닝이다.

데이터 버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것을 의미한다.

* 따라서 각 버전의 데이터는 변경 불가능(immutable)하다.

두 클라이언트가 동시에 같은 키 값으로 두 개의 사본 저장소에 쓰기 작업을 한다면 어떤 문제가 발생할까?

- 특정 키에 대해 값이 2가지로 충돌된다.

이를 해결하기 위한 것이 벡터 시계(vector clock)이다.

### 벡터 시계

벡터 시계란, [서버, 버전]의 순서 쌍을 데이터에 매단것.

* 어떤 버전이 선행인지 후행인지 충돌이 있는지 판별하는데 쓰인다 

- 벡터 시계의 표현법
  - Data ( [서버1, 버전1], [서버2, 버전2], ... [서버n, 버전n] )

만일 데이터를 서버에 기록하면 시스템을 아래 작업 가운데 하나를 수행해야 한다.

- [서버1, 버전1]가 있으면 버전1을 하나 증가시킨다.
- 없다면, 새 항목 [서버1, 버전1]을 생성한다.

어떤 버전 X와 Y 사이에 충돌이 있는지 보려면, Y의 벡터 시계 구성 요소 가운데 X의 벡터 시계 동일 서버(data[X, ?]) 보다 작은 값을 갖는 것이 있는지 보면 알 수 있다.

```
예를 들어, D([s0, 1], [s1, 2)와 D([s0, 2], [s1, 1])는 서로 충돌한다.

- 동일 서버 (s1)에 의 버전보다 낮은 D[s1, 1]이 있기 때문이다.
```

**벡터 시계의 단점**

- 충돌 감지 및 해소로직이 클라이언트가 수행해야 하므로 클라이언트 구현이 복잡해진다.
- [서버: 버전] 순서쌍의 개수가 빠르게 증가한다.

## 데이터 센터 장애 처리

데이터 센터 장애를 대응하려면 여러 데이터 센터에 다중화하는 것이 일반적이다.

## 시스템 아키텍처 다이어그램 - 키 값 저장소

<img src="./images/6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8//image-20230806225832632.png" width = 700 height = 400>

- 클라이언트는 API( get(key), put(key, value) ) 와 통신한다.
- 중재자는 클라이언트에게 키-값 저장소에 대해 proxy 역할을 한다.
- 노드는 안정 해시의 해시 링 위에 분포된다.
- 노드를 자동으로 추가 삭제할 수 있도록 시스템은 분산된다.
- 데이터는 여러 노드에 다중화 된다.
- SPOF(Single Point of Failure)는 존재하지 않는다.(모든 노드가 같은 책임을 지므로)

# 카산드라의 쓰기 및 읽기 과정

쓰기 요청이 특정 노드에 전달되는 과정

## 카산드라의 쓰기 경로(write path)

<img src="./images/6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8//image-20230806225931936.png" width = 600 height = 350>

1. 쓰기 요청이 커밋 로그 파일에 기록된다.
2. 데이터가 메모리 캐시에 기록된다.
3. 메모리 캐시가 가득차거나 사전에 정의된 어떤 임계치에 도달하면 데이터는 디스크에 있는 [SSTable](https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/)에 기록된다. SSTable은 Sorted-String Table의 약어로, <키, 값>의 순서쌍으로 정렬된 리스트 형태로 관리하는 테이블이다.

## 카산드라의 읽기 경로(read path)

읽기 요청이 특정 노드에 전달되는 과정

### **데이터가 메모리 캐시에 있는 경우**

읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 살핀다.

<img src="./images/6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8//image-20230806230114272.png" width = 650 height = 350>

메모리에서 바로 결과를 반환한다.

### 데이터가 메모리 캐시에 없는 경우

<img src="./images/6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%8C%E1%85%A5%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8//image-20230806230202797.png" width = 650 height = 350>

1. 가장 먼저 데이터가 메모리 캐시에 있는지 살핀다.
2. 데이터가 메모리에 없다면? 다른 노드가 가지고 있다는 의미다.
3. 블룸필터(Bloom Filter)를 검사한다.
4. 블룸필터는 어떤 SSTable에 키가 보관됐는지 검사한다.
5. SSTable에서 데이터를 가져와 클라이언트에게 반환한다.

> 블룸 필터(Bloom Filter)는 공간 효율적인 자료구조로, 집합에서 어떤 요소가 멤버인지 아닌지를 테스트하는 데 사용되며,
> 캐시 뒤에 있는 데이터베이스에서 특정 키의 존재를 빠르게 확인하려는 경우에 사용된다.
>
> 블룸 필터는 특정 요소가 집합에 있을 수는지만, 그 요소가 집합에 반드시 있다고는 말할 수 없다. 
> 다시 말해, 블룸 필터가 어떤 요소가 집합에 없으면 없는거지만, 집합에 있다고 말하면 그것은 오류일 수 있는것이다.



# 키-값 데이터 저장소 설계 요약

분산 키-값 저장소의 문제들과 해당 문제를 해결하기 위한 기술들을 정리해보자.

| 목표/문제                    | 기술                                        |
| ---------------------------- | ------------------------------------------- |
| 대규모 데이터 저장           | 안정 해시를 사용하여 서버에 부하 분산       |
| 읽기 연산에 대한 가용성 보장 | 여러 데이터센터에 다중화                    |
| 쓰기 연산에 대한 가용성 보장 | 버저닝 및 벡터 시계를 사용하여 충돌 해소    |
| 데이터 파티션                | 안정 해시                                   |
| 점진적 규모 확장성           | 안정 해시                                   |
| 다양성(heterogeneity)        | 안정 해시                                   |
| 조절 가능한 데이터 일관성    | 정족수 합의(quorum consensus)               |
| 일시적 장애 처리             | 느슨한 정족수 프로토콜 및 단서 후 임시 위탁 |
| 영구적 장애 처리             | 머클 트리                                   |
| 데이터 센터 장애 대응        | 여러 데이터센터에 다중화                    |
