# 7장 분산 시스템을 위한 유일 ID 생성기

[toc]

분산 시스템에서 사용될 유일 ID를 생성한다고 생각했을 때 가장 먼저 떠오르는건 `auto_increment` 속성이 설정된 관계형 데이터베이스의 기본 키를 쓰면 되지 않을까? 하고 생각할 수 있다.

하지만 분산 환경에서 이 접근법은 통하지 않는다.

데이터베이스 서버 한 대로는 그 요구를 감당할 수 없을뿐더러, 여러 데이터베이스 서버를 쓰는 경우에는 지연시간을 낮추기가 무척 힘들 것이다.

1. **SPOF (Single Point of Failure)**: `auto_increment`를 사용하는 하나의 데이터베이스 서버에 문제가 발생하면 ID를 생성할 수 없다. 이것은 시스템 전체의 가용성을 저하시킬 수 있습니다.
2. **확장성 문제**: 단일 데이터베이스 서버에서 ID를 생성하면 그 서버의 처리 능력 한계에 도달하게 된다. 분산 환경에서는 수많은 요청이 동시에 발생할 수 있으므로 단일 서버의 처리 능력을 초과할 수 있다.
3. **데이터베이스 분할 (Sharding) 문제**: 여러 데이터베이스 서버를 사용하는 경우 각 서버에서 동일한 ID를 생성하는 문제가 발생할 수 있다. 이 문제를 해결하기 위해서는 추가적인 동기화 메커니즘이 필요하다
   1. **중복 ID 발생**: 여러 데이터베이스 서버(Shard)에서 동시에 ID를 생성하면 동일한 ID가 생성될 위험이 있습니다. 예를 들어, 두 Shard에서 `auto_increment`를 사용하면 두 서버 모두 같은 순서로 ID를 생성할 가능성이 있습니다.
   2. **동기화 문제**: 중복된 ID 없이 각 Shard에서 ID를 생성하기 위해서는 서버 간에 동기화 메커니즘을 도입해야 합니다. 예를 들어, 중앙 집중식 ID 생성 서비스를 두어 모든 Shard에서 ID를 요청하게 할 수 있습니다. 하지만 이러한 중앙 서비스는 시스템 전체의 병목이 될 수 있습니다.
   3. **ID 생성 지연**: 서버 간 동기화를 통해 ID를 생성하려면 네트워크 지연, 서버 처리 지연 등으로 인해 ID 생성에 추가적인 시간이 소요될 수 있습니다.
4. **지연시간**: 여러 데이터베이스 서버 간의 동기화가 필요한 경우, 새로운 ID를 생성하거나 검증하는 데 필요한 지연시간이 증가하게 됩니다. 특히 글로벌 환경에서 여러 데이터 센터가 관련된 경우 더욱 그렇습니다.
5. **불연속 ID**: ID가 삭제되거나, 생성에 실패하게 되면 빈번한 불연속 ID가 발생할 수 있습니다. 이는 일부 애플리케이션에서 문제가 될 수 있습니다



# 요구사항

- ID는 유일하고 정렬 가능해야 한다
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 시간(발급 날짜)에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다.

# 유일 ID 만드는 방법들

- 다중 마스터 복제(multi-master replication)
- UUID(universally Unique Identifier)
- 티켓 서버(ticket server)
- 트위터 스노우플레이크(twiiter snowflake) 접근법



##  다중 마스터 복제(multi-master replication)

<img src="images/7장 분산 시스템을 위한 유일 ID 생성기 설계//image-20230827223357307.png" width = 600 height = 300>

* DB의 auto increment 기능을 활용하여 다음 ID를 구할 때 1만큼 증가시키지 않고 k 만큼 증가시킨다.
  * k는 사용중인 데이터베이스 서버의 수다

* 간단하게 적용할 수 있는 방식이고, 한 데이터 센터에서 어느정도 확장도 가능하다

하지만 이 방법은 다음과 같은 중대한 단점이 있다.

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다.
- ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수는 없다.
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 추가 동작을 만들기 어렵다.



## UUID

<img src="./images/7장 분산 시스템을 위한 유일 ID 생성기 설계//image-20230827223705942.png">

UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수이며 32자리의 16진수로 표현된다 다.

UUID 값은 충돌 가능성이 지극히 낮다.

중복 UUID가 생길 확률을 50%로 끌어 올릴려면 10억 개의 UUID를 100년 동안 계속해서 만들어야 한다.

| 이름                  | 길이(바이트) | 길이(16진수) | 설명                                                         |
| --------------------- | ------------ | ------------ | ------------------------------------------------------------ |
| time_low              | 4            | 8            | UUID의 처음 8자리. 시간의 저수 부분입니다.                   |
| time_mid              | 2            | 4            | UUID의 중간 4자리. 시간의 중간 값을 나타냅니다.              |
| time_hi_and_version   | 2            | 4            | 상위 2자리는 시간의 고수 부분이며, 나머지 2자리는 버전을 나타냅니다. |
| clock_seq_and_variant | 2            | 4            | 첫 2자리는 클럭 순차 값을 나타내며, 나머지 2자리는 변형을 나타냅니다. |
| node                  | 6            | 12           | 노드 값을 나타냅니다. 버전 1에서는 MAC 주소로 사용됩니다.    |

UUID값은 `09c93e62-50b4-468d-bf8a-c07e1040bfb2`와 같은 형태를 띤다.

UUID는 서버 간 조율 없이 각 서버가 독립적으로 생성한다.



**장점**

- UUID를 만드는 것은 단순하다. 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.

**단점**

- ID가 128비트로 길다. 이전의 ID 요구사항은 64비트이다.

- ID를 시간순으로 정렬할 수 없다.

  - 그러나 이건 시간 기반 uuid를 생성할 수도 있기도 하다.

  1. **버전 1 (기반 시간)**: 현재의 타임스탬프와 MAC 주소를 사용하여 생성됩니다.
  2. **버전 2 (DCE 보안)**: 버전 1과 유사하지만, POSIX UID 또는 GID 정보를 포함합니다.
  3. **버전 3 (이름 기반, MD5 해시)**: 주어진 이름(문자열)에 대해 MD5 해시를 사용하여 생성됩니다.
  4. **버전 4 (랜덤)**: 무작위 값으로 생성됩니다. 이 버전의 UUID 생성은 높은 확률로 유일합니다.
  5. **버전 5 (이름 기반, SHA-1 해시)**: 주어진 이름(문자열)에 대해 SHA-1 해시를 사용하여 생성됩니다.

- ID에 숫자가 아닌 값이 포함될 수 있다.



## 티켓 서버(ticket server)

<img src="./images/7장 분산 시스템을 위한 유일 ID 생성기 설계//image-20230827224238749.png">

티켓 서버란 분산 시스템에서 중앙 집중식으로 `순차적이고 고유한 ID("티켓")`을 생성하여 다른 서비스나 애플리케이션에 제공하는 서버

플리커(flicker)는 분산 기본 키를 만들어 내기 위해 이 기술을 이용하였다.

**장점**

- 유일성이 보장되는 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.

**단점**

- 티켓 서버가 SPOF(Single-Point-of-Failure)가 된다. 이 서버에 장애가 발생하면, 해당 서버를 이용하는 모든 시스템이 영향을 받는다. 
- 티켓 서버는 대량의 요청을 처리하기 위해 최적화될 수 있으며, 필요에 따라 클러스터로 확장될 수 있지만  데이터 동기화 같은 새로운 문제가 발생할 것이다.



## 트위터 스노우플레이크 접근법

<img src="./images/7장 분산 시스템을 위한 유일 ID 생성기 설계//image-20230827224505216.png">

이 접근법은 분할정복을 적용하여 생성해야 하는 ID 구조를 여러 절로 분할하였다.

- 사인(sign) 비트 : 1비트를 할당한다. 지금으로서는 쓰임새가 없지만 나중을 위해 유보해 둔다. 음수와 양수를 구별하는 데 사용할 수 있을 것이다.
- 타임스탬프 : 41비트를 할당한다. 기원 시각(epoch) 이후로 몇 밀리초가 경과햇는지를 나타내는 값이다. 본 설계안의 경우에는 기원 시각으로 트위터 스노플레이크 구현에서 사용하는 값 1288834974657(Nov 04, 2010, 01:42:54 UTC에 해당)을 이용할 것이다.
- 데이터센터 ID: 5비트를 할당한다. 따라서 2^5 = 32개 데이터센터를 지원할 수 있다.
- 서버 ID : 5비트를 할당한다. 따라서 데이터센터당 32개 서버를 사용할 수 있다.
- 일련번호 : 12비트를 할당한다. 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1만큼 증가시킨다. 이 값은 1밀리초가 경과할 때마다 0으로 초기화 된다.

그러나 Snowflake 접근법에는 몇 가지 고려사항이 있다:

- **시계 동기화**: 시스템 시계가 잘못 설정(뒤로 설정된다던가)되면 번호가 ID 충돌의 위험이 있다. 시계 동기화와 관련된 문제를 처리하기 위한 로직이 필요하다.
- **롤오버**: 41비트의 타임스탬프 부분이 사용된 시간 동안 충분하지 않게 될 경우 약 69년 동안만 사용 가능하다. 다 사용한 경우  롤오버를 고려해야 한다.

데이터센터 ID와 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 시스템 운영 중에는 바뀌지 않는다.

데이터센터 ID나 서버 ID를 잘못 변경하게 되면 ID 충돌이 발생할 수 있으므로, 그런 작업을 해야 할 때는 신중해야 한다.

타임스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값이다.



### 타임 스탬프 - 스노우 플레이크

타임스탬프는 앞서 살펴본 ID 구조에서 가장 중요한 41비트를 차지하고 있다.

타임스탬프는 시간이 흐름에 따라 점점 큰 값을 갖게 되므로, 결국 ID는 시간 순으로 정렬 가능하게 될 것이다.

다음의 그림은 앞서 살펴본 ID 구조를 따르는 값의 이진 표현 형태로부터 UTC 시각을 추출하는 예제다.

이 방법을 역으로 적용하면 어떤 UTC 시각도 상술한 타임스탬프 값으로 변환할 수 있다.

![image-20230827225045942](./images/7장 분산 시스템을 위한 유일 ID 생성기 설계//image-20230827225045942.png)

1. **이진수 ID**: `0-00100010101001011010011011000101101011000-01010-01100-000000000000`

   이 ID는 여러 부분으로 나뉘어져 있는데 중간의 큰 부분은 타임스탬프이다

2. **타임스탬프 추출**: `00100010101001011010011011000101101011000` 이진수를 십진수로 변환하면 `297616116568`가 된다.

3. **트위터 기원 시각 추가**: Twitter Snowflake에서는 특정 기준 시각 (epoch)으로부터 경과한 시간을 나타내는 타임스탬프를 사용한다. 여기에서는 트위터 기원 시각을 더하여 `1586451091225` 밀리초를 얻는다.

4. **UTC 시각 변환**: `1586451091225` 밀리초는 `Apr 09 2020 16:51:31UTC`에 해당한다. 이는 대부분의 프로그래밍 언어에서 타임스탬프를 UTC 시각으로 쉽게 변환할 수 있다.

간단히 말하자면, Snowflake ID의 타임스탬프 부분을 추출하고, 트위터의 기준 시간을 더하여 실제 UTC 시각을 얻은 것이다.

41비트로 표현할 수 있는 타임스탬프의 최대값은 2^41 - 1 = 2199023255551 밀리초다.

이 값은 대략 69년이며 69년동안만 정상 동작하는데, 기원시각을 현재에 가깝게 맞춰서 오버플로가 발생하는 시점을 늦춰 놓은 것이다.

* 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 다른 것으로 이전해야 한다.



일련번호는 12비트이므로, 2^12 = 4096개의 값을 가질 수 있다.

어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다.

# **4단계, 마무리 **- 더 논의할 거리

더 논의할 거리

- 시계 동기화(Clock synchronization)
  - 여러 서버가 물리적으로 독립된 여러 장비에서 돌아가게 되면 서버 시간이 다를 수 있기 때문에 위 방식이 동작하지 않을 수 있다.
  - NTP(Network Time Protocol) 같은 수단을 통해 서버간 시간을 동기화 시킬 수 있다.
- 어플리케이션에 맞게 구조 변경
  - 트위터 스노우플레이크는 bit 구조가 딱 정해진게 아니므로 어플리케이션마다 적절히 변경시켜 적용하면 된다.
  - 동시성이 낮고 수명이 긴 애플리케이션을 개발하려면  일련번호(Sequence)를 줄이고, Timestamp를 늘리는 것이 효과적일 수 있다.
- 고가용성
  - ID 생성기는 필수적인 컴포넌트(mission critical)이므로 고가용성을 제공해야만 한다.



### 스노우 플레이크 구현체

twitter는 Github에 snowflake 구현을 archive 해놓았다. Scala로

* 다음은 자바 코드 : https://github.com/beyondfengyu/SnowFlake

ksuid 라는 UUID 생성 라이브러리도 있다.

* https://github.com/segmentio/ksuid

### ulid

* https://github.com/huxi/sulky/blob/master/sulky-ulid/src/main/java/de/huxhorn/sulky/ulid/ULID.java

* 충돌 가능성 적음 : https://zendesk.engineering/how-probable-are-collisions-with-ulids-monotonic-option-d604d3ed2de

ULID (Universally Unique Lexicographically Sortable Identifier)는 분산 시스템에서 사용되는 고유 식별자를 생성하기 위한 방법 중 하나입니다. ULID는 UUID와 유사한 용도로 사용되지만, 특정한 장점들을 가지고 있습니다.

ULID의 주요 특징

1. **렉시코그래픽 정렬 가능**: ULID는 생성된 순서대로 정렬될 수 있다. 즉, 시간에 따라 정렬이 가능하며, 이는 데이터베이스나 로그 파일에서 시간 순서대로 식별자를 정렬할 필요가 있는 경우에 유용하다.
2. **128비트 크기**: UUID와 동일한 크기를 가지며, 충분한 고유성을 제공한다.
3. **URL 안전**: ULID는 URL에서 안전하게 사용될 수 있는 문자만 포함합니다.
4. **타임스탬프 포함**: ULID의 처음 48비트는 밀리초 단위의 타임스탬프를 나타낸다.
5. **충돌 위험 최소화**: ULID의 나머지 부분은 무작위로 생성되어, 충돌 위험을 최소화한다.

![image-20230827230114383](./images/7장 분산 시스템을 위한 유일 ID 생성기 설계//image-20230827230114383.png)

ULID (Universally Unique Lexicographically Sortable Identifier)의 구조는 크게 두 부분으로 나뉜다

예를 들어, "01ARYZ6S410000000000000000"라는 ULID는:

- "01ARYZ6S41": 타임스탬프 부분
- "0000000000000000": 무작위 부분

1. **타임스탬프 (Timestamp)**
   - 길이: 48비트
   - 밀리초 단위의 타임스탬프로, 대략적으로 8,925년 동안 사용 가능하다.
   - ULID의 첫 10자리를 차지하며, 1밀리초의 정밀도로 생성 시간을 표시하다.
2. **무작위 부분 (Randomness)**
   - 길이: 80비트
   - 각각의 ULID가 고유하게 만들어지도록 도와주는 무작위 값입니다.
   - ULID의 나머지 16자리를 차지합니다.

ULID는 Crockford의 base32 인코딩을 사용하여 표현된다. 

이로 인해 각 ULID 값은 26개의 소문자, 6개의 숫자 (0-9의 숫자 중 1, 8, 9를 제외) 그리고 몇몇 특수 문자로 구성되는 26자리의 문자열로 나타낼 수 있다.





