# 9장 옵티마이저와 힌트



[toc]



# 9.1 옵티마이저 개요

쿼리를 분석하고 실행 계획을 수립하여 데이터를 어떻게 가져올 것인지 결정하는 MySQL의 두뇌가 옵티마이저이다.

## 쿼리 실행 절차

MySOL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있다.

1. ﻿﻿사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
2. ﻿﻿﻿SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. ﻿﻿﻿두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.



**SQL 파싱 단계** : ﻿﻿사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.

* SQL 파서 모듈이 처리한다. 문법적으로 잘못되었다면 여기서 걸러진다. 



**최적화 및 실행 계획 수립 단계** : SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.

* 불필요한 조건 제거 및 복잡한 연산의 단순화
* 여러 테이블 조인이 있는경우 어떤 순서로 테이블 읽을지 결정
* 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
* 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정



## 옵티마이저의 종류

옵티마이저는 데이터베이스의 두뇌이다.

* 비용 기반 최적화(Cost-based optimizer, CBO) 방법
  *  쿼리를 처리할 여러 실행 계획을 고려하고 각 계획의 "비용"을 평가하여 실행할 계획을 선택한다.
  * 비용은 일반적으로 각작업의 비용(부하) 등을 디스크 I/O, CPU 시간, 메모리 사용 등 여러 요소를 종합적으로 고려한 것
  * 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 쿼리를 실행
* 규칙 기반 최적화 방법(Rule-based optimizer, RBO, 초기 버전의 오라클 DBMS에서 많이 사용)
  * 대상 테이블의 레코드 건수나 카디널리티 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
  * 통계 정보(레코드, 컬럼값 분포도, 카디널리티)를 조사하지 않고 실행 계획을 수립하기 때문에 거의 항상 같은 실행계획을 수립한다.
  * 과거, CPU가 느린 시절 비용 계산 과정이 부담스럽다는 이유로 사용되던 방법이다.
  * 하지만 사용자 데이터 분포도는 매우 다양하기 때문에 규칙 기반 최적화는 오래전부터 거의 사용되지 않는다.

RBO는 CBO에 비해 단순하고 예측 가능하다는 장점이 있지만, 최적의 실행 계획을 찾기 위한 유연성이 떨어질 수 있다. 

오라클과 같은 일부 초기 버전의 데이터베이스 관리 시스템에서는 RBO를 사용했으나, 대부분의 현대 시스템은 CBO를 선호하고 사용한다.



# 9.2 기본 데이터 처리

## 풀 테이블 스캔과 풀 인덱스 스캔

###  풀 테이블 스캔을 사용하는 경우

*  테이블의 `레코드 건수가 너무 작아서` 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)

*  WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 `적절한 조건이 없는 경우`

*  인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 `조건 일치 레코드 건수가 너무 많은 경우`(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

### InnoDB와 MyISAM의 다른 풀 테이블 스캔 처리 방식

MyISAM과 InnoDB는 풀 테이블 스캔 처리 방식이 다르다.

테이블 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 풀스캔 하는 작업은 많은 디스크 I/O가 필요하다.

그래서 풀 테이블 스캔 시 한꺼번에 여러 블록이나 페이지를 읽어온다.

**MyISAM**

MyISAM은 풀 테이블 스캔 작업을 실행할 때 페이지를 하나씩 읽어 오는 방식을 사용한다. 이로 인해 디스크에서 많은 양의 I/O 작업이 발생하며, 이는 큰 테이블에서 특히 비효율적일 수 있다.



**InnoDB**

InnoDB 스토리지 엔진은 "리드 어헤드(Read ahead)" 기능을 사용하여 풀 테이블 스캔을 최적화한다. 

* 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는것 을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다. ->  I/O 성능을 향상

풀 테이블 스캔시 실행되면 처음 몇 데이터 페이지는 포그라운드 스레드가 처리하고,

특정 시점부터 백그라운드 스레드가 바톤터치하면서 한번에 4개, 8개씩 읽으면서 64개의 페이지까지 읽어 버퍼 풀에 저장해두고 

포그라운드 스레드가 미리 버퍼 풀에 준비된 데이터를 가져다 사용하여 쿼리 최적화를 한다.

정리하자면

1. **포그라운드 스레드**: 쿼리를 처리하는 주 스레드가 디스크에서 처음 몇 페이지를 직접 읽고나서
2. **백그라운드 스레드의 활성화**: 특정 시점에서 백그라운드 스레드가 활성화되어, 미리 더 많은 데이터 페이지를 읽기 시작하여 포그라운드 스레드가 데이터를 기다리는 시간을 줄인다.
3. **리드 어헤드**: 백그라운드 스레드는 점차적으로 더 많은 페이지를 읽는다 (예: 4개, 8개, 최대 64개까지). 이렇게 읽은 페이지들은 메모리에 있는 버퍼 풀에 저장된다.
4. **포그라운드 스레드의 계속된 처리**: 포그라운드 스레드는 쿼리 처리를 계속하면서, 필요한 데이터가 이미 버퍼 풀에 준비되어 있으면, 디스크에서 직접 읽지 않고 빠르게 가져와 사용한다.

### 풀 인덱스 스캔을 사용하는 경우

리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다.

ex) 쿼리 예제

```mysql
SELECT COUNT(*) FROM employees;
```

풀 테이블 스캔할것같지만 실제로는 풀 인덱스 스캔할 경우가 높다.

이 쿼리는 단순히 레코드의 `건수` 만 필요로 하기 때문이다.

이런 경우에는 디스크를 읽는것보다 인덱스를 읽는것이 용량이 적기 때문에 인덱스를 읽는다.

* 인덱스에서만으로도 충분히 가져올 수 있는 데이터 건수이다.

그러나 다음과 같이, 인덱스에는 없고 레코드에만 있는 칼럼이 필요한 경우의 경우에는 풀 인덱스 스캔을 활용 못하고 풀 테이블 스캔을 한다

* 인덱스를 사용하더라도 인덱스에 없는 열의 데이터를 찾기 위해 실제 테이블에 액세스해야 할 가능성이 높다

```mysql
SELECT * FROM employee
```

## 병렬 처리

여기서 설명하는 병렬 처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미한다.

MySQL 8.0에서는 `innodb.parallel_read_threads`라는 시스템 변수를 이용해,

하나의 쿼리를 최대 몇 개 의 스레드를 이용해서 처리할지를 변경할 수 있다

MySQL 8.0 버전에서는 `아무런 WERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만` 병렬로 처리할 수 있다.

## ORDER BY 처리(Using filesort)



Filesort는 MySQL에서 사용되는 정렬 알고리즘이며, 주로 `ORDER BY`나 `GROUP BY` 절에서 정렬이 필요할 때 활용된다.

정렬을 처리하는 방법은 

* 인덱스를 이용하는 방법과 

* 쿼리가 실행될 때 `Filesort`라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.

|                   | 장점                                                         | 단점                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **인덱스 이용**   | - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다. | - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.<br> - 인덱스 때문에 디스크 공간이 더 많이 필요하다.<br> - 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다. |
| **Filesort 이용** | - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다.<br />- 정렬해야 할 레코드가 많지 않으면 메모리에서 Filrsort가 처리되므로 충분히 빠르다 | - 정렬 작업이 쿼리 실행시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답속도가 느리다 |



모든 레코드 정렬이 항상 FileSort가 필요한것은 아니고 인덱스를 이용할수도 있지만 다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다.

- ﻿﻿정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- ﻿﻿GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- ﻿﻿UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- ﻿﻿랜덤하게 결과 레코드를 가져와야 하는 경우

**인덱스를 사용할 수 있는 경우**

1. ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속해야 한다.
2. ORDER BY 절의 순서가 인덱스와 일치해야 한다.
3. WHERE 절에 첫 번째 읽는 테이블에 대한 조건이 있다면, ORDER BY절도 같은 인덱스를 사용할 수 있어야 한다.

**Filesort를 사용하는 경우**

- `ORDER BY` 절이 쿼리에 포함되어 있고, 해당 정렬 순서가 인덱스와 일치하지 않는 경우.
- `GROUP BY` 절이 쿼리에 포함되어 있고, 해당 그룹화 순서가 인덱스와 일치하지 않는 경우.

MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼 에 Jsing filesort” 메시지가 표시되는지 여부로 판단할 수 있다.

```
+----------------+
| Extra          |
+----------------+
| Using filesort |
+----------------+
```

File Sort는 레코드가 많아질수록 쿼리의 응답 속도가 현저히 떨어지게 된다.

`MySQL은 인덱스를 통해 정렬을 할 수 없다면 FileSort를 사용한다.` 

* 임시 테이블을 사용한 정렬도 FileSort에 해당한다.

File Sort를 사용하는 경우도 2가지로 나눌 수 있다.

- 드라이빙 테이블만 정렬 ("Using filesort")
- 임시 테이블을 이용한 정렬 ("Using temporary, Using filesort")

드라이빙 테이블만 정렬된다는 방식은 조회하는 테이블 중 먼저 액세스되는 테이블만 SortBuffer에서 정렬해서 나머지 테이블들과 조합하는 방식이다.

### 소트 버퍼 (sort buffer)

**소트 버퍼** : MySQL에서 정렬을 수행하기 위해 할당받아서 사용하는 별도의 임시 메모리 공간

소트 버퍼는 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드 크기에 따라 가변적으로 증가하지만, 

`sort_buffer_size` 라는 변수로 최대 사용 가능 사이즈를 정할 수 있다.

* 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다

정렬해야 할 레코드가 소트 버퍼로 할당된 메모리공간보다 크면 MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데,

이 과정에서 임시 저장을 위해 디스크를 사용한다

* 메모리의 소트버퍼에서 정렬을 수행하고 그 결과를 디스크에 임시 기록
* 다음 레코드를 가져와서 정렬해서 반복적으로 디스크에 임시 기록
* 이처럼 각 버퍼 크기(소트버퍼 크기)만큼 정렬된 레코드를 다시 병합해야 하는데 이 병합 작업을 `멀티 머지(multi-merge)`라고 한다

> 만약 sort buffer가 충분하지 않으면, MySQL은 임시 파일을 디스크에 작성하여 정렬을 수행하게 된다. 
>
> 이는 Filesort 작업이라고 하며, 메모리 내에서 정렬하는 것보다 일반적으로 더 느리다.
>
> \- disk를 이용하기 때문이다

소트 버퍼(메모리 버퍼 크기)를 크게 설정해도 달라지지 않는다. 

다음 쿼리는 2,844,047 레코드를 모두 읽어 정렬한다

* to_date 칼럼에 인덱스가 없기 때문에, 쿼리 처리시에 정렬 작업(소트 버퍼 작업)이 필요하다

```mysql
SELECT * FROM salaries
ORDER BY to_date
LIMIT 999999999, 1;
```

* 저자 말로는 소트 버퍼 크기가 256KB에서 8MB 사이에서 최적의 성능을 보였다고 한다.

* 또한, 경험상 일반적인 트랜잭션 처리용 MySQL 소트 버퍼의 크기는 56KB ~ 1MB이 적절해보인다고 한다. 

왜 메모리 크기(sort_buffer_size 시스템 변수값)이 커도 빨라지지 않을까?

MySQL은 메모리를(4.1.3 메모리 할당 및 사용 구조 참조) 글로벌 메모리 영역, 세션(로컬)메모리 영역으로 나눠 생각할 수 있는데

소트 버퍼는 여러 클라이언트가 공유해서 사용하는 공간이 아닌 세션 메모리 영역에 해당한다.

즉 커넥션(세션)이 많을수록 정렬 작업이 많아지면 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미한다.

소트 버퍼의 크기를 10MB 이상으로 설정하면 대량의 레코드를 정렬하는 여러 쿼리가 여러 커넥션에서 동시에 실행되면서 오히려 OOM도 유발할 수 있다.

그러나  `소트 버퍼를 크게 설정해서 빠른 성능을 얻을 수는 없지만 디스크의 읽기와 쓰기 사용량은 줄일 수 있다`

* 만약, 대량 데이터의 정렬이 필요한 경우 `해당 세션`의 소트 버퍼(sort_buffer_size) 크기만 일시적으로 늘려 쿼리 실행 후 줄이는 것도 좋은 방법이다.

### 정렬 알고리즘

레코드 정렬 시 레코드 전체를 소트 버퍼에 담을지, 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라 두가지 정렬 모드로 나눌 수 있다.

* 싱글 패스(single - pass)
* 투 패스 (two - pass)

정렬수행 쿼리가 어떤 정렬 모드를 사용하는지 옵티마이저 트레이스 기능으로 확인할 수 있다.

```mysql
--// 옵티마이저 트레이스 활성화
SET OPTIMIZER_TRACE="enabled=on",END_MARKERS_IN_JSON=on;
SET OPTIMIZER_TRACE_MAX_MM_SIZE=1000000;

--// 쿼리 실행
SELECT * FROM employees ORDER BY last_name LIMIT 100000, 1;

-- // 트레이스 내용 확인
SELECT * FROM INFORMATION_SCHEMA. OPTIMIZER_TRACE \G
```

트레이스 내용 결과

```json
{
  "filesort_priority_queue_optimization": {
    "limit": 100001
  }, /* filesort_priority_queue_optimization */,
  "filesort_execution": [    
  ] /* filesort_execution */,
  "filesort_summary": {
    "memory_available": 262144,
    "key_size": 32,
    "row_size": 169,
    "max_rows_per_buffer": 1551,
    "num_rows_estimate": 936530,
    "num_rows_found": 300024,
    "num_initial_chunks_spilled_to_disk": 82,
    "peak_memory_used": 262144,
    "sort_algorithm": "std::stable_sort",
    "sort_mode": "<fixed_sort_key, packed_additional_fields>"
  } /* filesort summary */
}
```

* `filesort summary` 섹션의 sort_algorithm에 정렬 알고리즘이 표시된다.
  * `"sort_algorithm": "std::stable_sort"` : 안정 정렬.  입력에서 동일한 값의 원소가 정렬 후에도 원래의 상대적인 순서를 유지하는 정렬 방법
    * 결과의 순서를 보장하는데 사용될 수 있으며, 이는 결과 집합 내의 동일한 값들 사이의 상대적인 순서를 유지해야 할 때 중요
    * 평균적인 경우 시간 복잡도는 O(n log n)
* `"sort_mode": "<fixed_sort_key, packed_additional_fields>"` :  FileSort 작업의 정렬 방법에 대한 세부 정보
  * **`fixed_sort_key`**: 정렬 키가 고정 길이 라는 의미. 고정 길이 정렬 키는 처리 과정에서 메모리 사용을 예측하고 관리하기 쉬워 효율성이 높다.
  * **`packed_additional_fields`**: 정렬 작업을 수행할 때 필요한 추가 데이터가 공간 효율적으로 메모리에 배열되어 있다는 의 미

MySQL 서버의 정렬 방식은 3가지가 있다.

- ﻿﻿`<sort_key, rowid) - 투 패스 방식`: 정렬 키와 레코드의 로우 아이디(ROW ID)만 가져와서 정렬하는 방식
  - 이후, 정렬된 로우 아이디를 기반으로 실제 레코드를 디스크에서 가져오는 단계가 있어, 메모리 사용량이 상대적으로 적으나 두 번의 패스가 필요하기 때문이 처리 시간이 좀 더 걸린다
- ﻿`<sort_key, additional_fields> - 싱글 패스 방식` : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
  - 모든 데이터를 메모리에 한 번에 가져오기 때문에 디스크에서 레코드를 다시 읽어올 필요가 없으므로 투 패스 방식보다 빠를 수 있다.
  - 그러나 모든 레코드 데이터를 메모리에 저장해야 하므로 메모리 사용량이 많아질 수 있으며, 칼럼들은 고정 사이즈로 저장되기 때문에 메모리 낭비가 발생할 수 있다.
- ﻿﻿`<sort_key, packed_additional_fields> - 싱글 패스 방식`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼 들은 가변 사이즈로 메모리 저장
  - 필요한 만큼의 메모리만 사용하므로 공간 효율이 더 좋다.
  - 이 방식은 추가 필드가 효율적으로 패킹되기 때문에 메모리 사용량과 성능 사이의 좋은 균형을 제공할 수 있다.

> 하지만 MySQL 8.0에서도 여전히 특정 조건에서는 투 패스(Two-pass) 정렬 방식을 사용한다.

## 정렬 알고리즘 - 싱글 패스 방식과 투 패스 방식

### 싱글 패스 정렬 방식

소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식

```mysql
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```

<img src="./images/9장 옵티마이저와 힌트/image-20230813134109714.png" width = 800 height = 500>

처음 employees 테이블을 읽을 때 정렬에 필요하지 않은 last_name 칼럼 까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행한다. 

그리고 정렬이 완료되면 정렬 버퍼의 내용을 그대 로 클라이언트로 넘겨준다

### 투 패스 정렬 방식

정렬 대상 칼럼과 PK 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어서 SELECT할 칼럼을 가져오는 정렬 방식

```mysql
SELECT emp_no, first_name, last_name
FROM employees
ORDER BY first_name;
```

<img src="./images/9장 옵티마이저와 힌트//image-20230813134309512.png" width = 800 height = 500>

처음 employess 테이블을 읽을 때 정렬에 필요한 first_name 컬럼과 프라이머리 키인 emp_no만 읽어서 정렬을 수행한다.

다음 정렬이 완료되면 employess 테이블을 한번 더 읽어 나머지 칼럼(last_name)을 가져와 결과를 클라이언트로 넘긴다.

### 싱글 패스 vs 투 패스

과거 투 패스 방식은 두번 읽어야 하기 때문에 불합리 하지만 싱글 패스는 이런 불합리가 없다.(1번만 읽으면 됌)

그러나 싱글 패스 방식은 모든 데이터를 가져오기 때문에 더 많은 소트 버퍼 공간이 필요하다.

최근 MySQL서버는 일반적으로 싱글 패스를 사용하지만 다음의 경우는 **투 패스 정렬 방식**을 사용한다.

- ﻿﻿`레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때`
- ﻿﻿`BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함할 때`
  - BLOB이나 TEXT 너무 크다..

> SELECT 쿼리에서 꼭 필요한 컬럼만 조회하자 (*) 쓰지 말고.
> 안쓰는 컬럼까지 모두 읽어와 하니까 정렬 버퍼(소트 버퍼)에서 비효율적으로 사용할 가능성이 크기 때문이다. 
>
> SELECT 쿼리에서 꼭 필요한 칼럼만 조회하도록 쿼리를 작성하는 것이 좋다고 권장하는 것은 바로 이런 이유 때문이다.



## 정렬 처리 방법 - ORDER BY

쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 정렬이 처리된다. 

* 일반적으로 아래쪽에 있는 정렬 방법으로 갈수록 `처리 속도는 떨어진다.`

| 정렬 처리 방법                                  | 실행 계획의 Extra 칼럼 내용                       |
| ----------------------------------------------- | ------------------------------------------------- |
| 인덱스를 사용한 정렬                            | 별도 표기 없음                                    |
| 조인에서 드라이빙 테이블만 정렬                 | “using filesort” 메시지가 표시됨                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "using temporary; using filesort” 메시지가 표시됨 |

옵티마이저가 정렬 처리를 어떻게 할지 판단하는 방법

1. 인덱스를 이용할 수 있을지 검토한다 - 인덱스를 이용한 정렬
   * 인덱스를 이용할 수 있면 Filesort 과정 없이 인덱스 이용해서 결과 반환
2. 인덱스를 이용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 filesort로 정렬 처리
   * 이때 옵티마이저는 정렬 대상 레코드 최소화 하기 위해 다음 2가지 방법 중 하나를 선택한다
     * 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
     * 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

### 인덱스를 이용한 정렬

인덱스를 사용할 수 있는 경우

1. 반드시 ORDER BY에 명시된 ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
   * 조인이 사용된 경우 드라이빙 테이블에 속해야 한다,
   * 드라이빙 테이블 : 조인 작업에서 첫번째로 읽히는 테이블. 레코드 수가 더 적은 테이블이 더 효율적일 수 있다.
   * 드리븐 테이블 : 드라이빙 테이블에 조인되는 다음 테이블 
2. ORDER BY 절의 순서가 인덱스와 일치해야 한다.

3. WERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 `그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.` 



B-Tree 계열의 인덱스가 아닌 `해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다`.

* R-Tree도 B-Tree 계열이지만, 특성상 이 방식을 사용할 수 없다

* 여러 테이블이 조인되는 경우에는 네스티드-루프(Nested-loop) 방식의 조인에서만 위 조건이 맞아야 사용할 수 있다.

<img src="./images/9장 옵티마이저와 힌트//image-20230813141916247.png" width = 600 height = 350>

인덱스를 이용해 정렬이 처리되는 경우에는 `실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 되므로` 

MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지는 않는다.

ORDER BY 절이 없어도 인덱스 레인지 스캔해서 나온 결과는 같은 순서대로 출력된다.

* 혹시 ORDER BY 절을 포함하면 MySQL 서버가 별도로 정렬 작업을 한 번 더 할까 봐 걱정하지 말자. 옵티마이저가 불필요한 정렬작업을 다시 하지 않는다.

`인덱스를 사용한 정렬이 가능한 이유는 B-Tree 인덱스가 키 값으로 정렬돼 있기 때문이다`

### 조인의 드라이빙 테이블만 정렬 - using Filesort

조인이 수행되면 레코드 건수, 크기가 불어나므로 조인 실행 전 첫 번째 테이블을 정렬한 다음 조인을 실행하는 것이 차선책이다.

이 방법으로 정렬이 처리되려면 조인에서 드라이빙 테이블의 칼럼만으로 ORDER BY 절을 작성해야 한다.

```mysql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY e.last_name;
```

우선 WHERE 절이 다음 2가지 조건을 갖추고 있기 때문에 옵티마이저는 employees 테이블을 드라이빙 테이블로 선택할 것이다.

- ﻿﻿WHERE 절의 검색 조건(emp_no BETWEEN 100001 AND 100010")은 employees 테이블의 PK를 이용해
   검색하면 작업량을 줄일 수 있다.
- ﻿﻿드리븐 테이블(salaries)의 조인 칼럼인 emp_no 칼럼에 인덱스가 있다.

검색은 인덱스 레인지 스캔으로 처리할 수 있지만 

`ORDER BY 절에 e.last_name은 empLoyees 테이블의 PK 또는 인덱스가 아니므로 인덱스를 이용한 정렬은 불가능하다.`

<img src="./images/9장 옵티마이저와 힌트//image-20230813143141889.png" width = 700 height = 500>

1. ﻿﻿﻿인덱스를 이용해 "emp_no BETWEEN 100001 AND 100010" 조건을 만족하는 9건을 검색
2. ﻿﻿﻿검색 결과를 Last_name 칼럼으로 정렬을 수행(Filesort)
3. ﻿﻿﻿정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 86건의 최종 결과를 가져옴(그림 9.5의 오른 쪽에 있는 번호는 레코드가 조인되어 출력되는 순서를 의미).

이 경우 SortBuffer로 테이블을 하나 옮겨서 정렬하는 작업이 필요하지만 임시 테이블을 이용하는 방법보다는 낫다.

### 임시 테이블을 이용한 정렬 - Using temporary, Using filesort

2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.

항상 조인의 결과 를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다. 

이 방법은 정렬의 3가지 방법 가운데 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다

```mysql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```

* ORDER BY 절 정렬 칼럼이 드라이빙이 아닌 드리븐 테이블이다(s.salary)

때문에 정렬이 수행되기 전에 salaries 테이블을 읽어야 하므로 조인된 데이터를 가지고 정렬할 수 밖에 없다.

```
| id | table | type  | key     | Extra                              |
|----|-------|-------|---------|------------------------------------|
| 1  | e     | s     | range   | Using where; Using temporary; Using filesort |
| 1  | s     | range | PRIMARY | NULL                               |
```

 Extra 칼럼에 “Using temporary; Using filesor"라는 코멘트가 표시된다.

이는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미한다.

 <img src="./images/9장 옵티마이저와 힌트//image-20230813144709892.png" width = 600 height = 600>

임시테이블을 이용한 정렬은 모든 테이블의 결과를 임시 테이블에 넣고 정렬을 수행하므로 가장 느리다. 특히 레코드가 많아지면 임시 테이블이 디스크에 저장되면서, 대규모 서비스에서 치명적인 I/O 부하가 발생한다.

이 경우 Application Layer나 Presentation Lyaer에서 정렬을 해서 뷰에 노출하는 것을 고려할 수 있다.

 

**다음은 임시 테이블이 필요한 경우이다.**

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTICT가 사용된 쿼리
- UNION ALL이 사용된 쿼리
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

해당 6가지 경우 중 1~3 번째 경우에는 Extra 칼럼에 "Using Temporary"가 표시된다. 

반면 4~6 번째 경우에는 Extra 칼럼에 "Using Temporary"가 표시되지 않지만 임시 테이블이 사용된다. 

**주의사항**

내부 임시 테이블이 크기가 커서 디스크에 생성되면 성능 이슈가 발생한다.

내부 임시 테이블이 디스크에 생성되었는지 여부를 파악하려면 아래의 명령어로 가능하다.

```
SHOW SESSION STATUS LIKE 'Create_tmp%';
```

해당 쿼리의 결과로 생성된 임시 테이블의 상태를 파악할 수 있다.

```
+--------------------------+------------+
| Variable_name            | Value      |
+--------------------------+------------+
| Created_tmp_disk_tables  | 0          |
| Created_tmp_tables       | 8340       |
| Created_tmp_files        | 60         |
...
+--------------------------+------------+
```

## 정렬 처리 방법의 성능 비교

ORDER BY나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 레코드를 `LIMIT` 건수 만큼만 가져와서는 처리할 수 없.

조건을 만족하는 레코드를 모두 가져오고, 정렬을 수행하거나 grouping하고 나서 limit 으로 건수를 제한한다.

> WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다.

인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동할 수밖에 없는지 "스트리밍 처리"와 버퍼링 처리"라는 2가지 방식으로 알아볼 수 있다.

### 스트리밍 방식(Streaming)

서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식을 의미한다.

쿼리가 스트리밍 방식으로 처리될 수 있다면 클라이언트는 MySOL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업(정렬, 그룹핑 등)을 시작할 수 있다

스트리밍 방식으로 처리되는 쿼리는 많은 레코드를 조회하느냐 상관 없이 빠른 응답 시간을 보장해주며

LIMIT 에도 성능 향상을 기대할 수 있다. 전체적으로 가져오는 레코드 건수가 줄어들기 때문이다.

### 버퍼링 방식(Buffering)

ORDER BY나 GROUP BY 같은 처리는 쿼리의 결과를 스트리밍 처리할 수 없다.

조건에 일치하는 모든 레코드를 가져온 후 정렬하거나 그룹핑하고 보내야 하기 때문이다.

때문에 MYSQL 서버에서 작업하는 동안 클라이언트는 아무것도 못하기 때문에 응답속도가 느려지며 스트리밍 반대 표현으로 버퍼링 이라고 한다.

<img src="./images/9장 옵티마이저와 힌트//image-20230813145406197.png" width = 600 height = 300>

* 버퍼링 방식 쿼리는 결과를 모으고 일괄 가공해야 하므로 모든 결과를 스토리지 엔진에서 가져올때까지 대기해야 하므로 느리다.
  * LIMIT으로 결과 건수를 제한해도 느리다. 일단 그룹핑이나 정렬을 해야하기 때문 

> JDBC는 MySQL 서버로부터 받는 레코드를 일단 내부 버퍼에 모두 담아둔다. 
> 그리고 마지막 레코드가 전달될 때까지 기다렸다가 모든 결과를 전달받으면 그때서야 클라이언트의 애플리케이션에 반환한다.
>  즉, MySQL 서버는 스트리밍 방식으로 처리해서 반환하지만 클라이언트의 JDBC 라이브러리가 버퍼링하는 것이다.
>
>
> R2DBC는 전체 레코드 집합을 모두 버퍼링하는 대신에 스트림으로 데이터를 처리한다.
> JDBC가 전체 결과 세트를 메모리에 로드하는 것과 달리, R2DBC는 각 레코드가 사용 가능해지는 즉시 애플리케이션에 전달할 수 있으며, 이는 메모리 사용량을 크게 줄이고 처리 지연 시간을 최소화한다.

JDBC 라이브러리가 자체적으로 레코드를 버퍼링하는 이유는 
이 방식 이 전체 처리(Throughput) 시간이 짧고 MySQL 서버와의 `통신 횟수가 적어 자원 소모가 줄어들기 때문이다.`
JDBC 라이브러리와 MySQL 서버가 대화형으로 데이터를 주고받는 것이 아니라 MySQL 서버는 데이터의 크기에 관계없이 무조건 보내고, JDBC MySQL 서버로부터 전송되는 데이터를 받아서 저장만 하므로 `불필요한 네트워크 요청이 최소화되기 때문에 전체 처리량이 뛰어나다.`



* 인덱스를 이용한 정렬 처리
* 드라이빙 테이블을 이용한 정렬 처리 - Using FileSort
* 임시 테이블을 이용한 정렬 - Using temporary, Using filesort

중 인덱스를 사용한 정렬 방식만 스트리밍 형태 처리이며 파일 정렬이나 임시테이블은 버퍼링 형태 처리방식이다.



### 조인과 함께 ORDER BY 절과 LINIT 절이 사용될 경우 정렬 처리 방법별 차이점

```mysql
SELECT *
FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1 = 2.col1
ORDER BY t1.co12
LIMIT 10;
```

* tb_test1 : 100건
* tb_test2 : 1,000건
* tb_test1의 레코드 1건당 tb_test2의 레코드가 10건

**tb_test1이 드라이빙 되는 경우**

| 정렬 방법                     | 읽어야 할 건수                                               | 조인 횟수 | 정렬해야 할 대상 건수                                     |
| ----------------------------- | ------------------------------------------------------------ | --------- | --------------------------------------------------------- |
| 인덱스 사용                   | tb_test1: 1건<br>tb_test2: 10건                              | 번        | 0건                                                       |
| 조인의 드라이빙 테이블만 정렬 | tb_test1: 100건<br>tb_test2: 10건                            | 100번     | 100건 <br />(tb_test1 테이블의 레코드 건수만큼 정렬 필요) |
| 임시 테이블 사용 후 정렬      | tb_test1: 100건<br>tb_test2: 1000건<br />(tb test1 테이블의 레코드 건수만큼 조인 발생) | 1,000건   | 1,000건 <br />조인된 결과 레코드 건수를 전부 정렬해야 함  |

**t2_test2가 드라이빙 되는 경우**

| 정렬 방법                     | 읽어야 할 건수                      | 조인 횟수                                                  | 정렬해야 할 대상 건수                                      |
| ----------------------------- | ----------------------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- |
| 인덱스 사용                   | tb_test2: 10건<br>tb_test1: 10건    | 10번                                                       | 0건                                                        |
| 조인의 드라이빙 테이블만 정렬 | tb_test2: 1000건<br>tb_test1: 10건  | 10번                                                       | 1000건 <br />(tb_test2 테이블의 레코드 건수만큼 정렬 필요) |
| 임시 테이블 사용 후 정렬      | tb_test2: 1000건<br>tb_test1: 100건 | 1,000번<br />(tb test1 테이블의 레코드 건수만큼 조인 발생) | 1000건 <br />(조인된 결과 레코드 건수를 전부 정렬해야 함)  |

가능하다면 

드라이빙 테이블이 더 적은 테이블로 유도,
인덱스를 사용한 정렬로 유도하고, 
그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하자.

### 정렬 관련 상태 변수

지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 
소트 버퍼 간의 병합 작업(멀티 머지는 몇 번이나 발생했는지 확인가능하다.

```mysql
FLUSH STATUS;

SHOW STATUS LIKE 'Sort%';
```

| Variable name     | Value  |
| ----------------- | ------ |
| Sort_merge_passes | 13     |
| Sort_range        | 0      |
| Sort_rows         | 300024 |
| Sort_scan         | 1      |

- ﻿﻿Sort_merge_passes :  멀티 머지 처리 횟수
- ﻿﻿Sort_range :  인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- ﻿﻿Sort_scan :  풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수. 
  - Sort_scan과 Sort_range는 둘 다 정렬 작업 횟수를 누적하고 있는 상태 값
- ﻿﻿Sort_rows :  지금까지 정렬한 전체 레코드 건수

이 예제의 결과를 해석해 보면 대략 다음과 같은 내용을 알아낼 수 있다.

- ﻿﻿풀 테이블 스캔의 결과를 1번(Sort_scan 상태 변수 값) 정렬
- ﻿﻿단위 정렬 작업의 결과를 13번(Sort_merge_passes 상태 변수 값) 병합 처리
- ﻿﻿전체 정렬된 레코드 건수는 300,024건(Sort._ Tows 상태 변수 값

### MySQL의 JDBC 드라이버를 사용할 때 스트리밍 방식으로 결과를 가져오려면

1. **Statement를 생성할 때 스트리밍을 활성화**:

 `Statement` 객체를 생성할 때 `ResultSet.TYPE_FORWARD_ONLY` 및 `ResultSet.CONCUR_READ_ONLY` 플래그를 사용하고, `fetchSize`를 `Integer.MIN_VALUE`로 설정하여 스트리밍을 활성화

```java
Statement statement = connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, //
                                                ResultSet.CONCUR_READ_ONLY); //
statement.setFetchSize(Integer.MIN_VALUE);
ResultSet resultSet = statement.executeQuery("SELECT * FROM your_table");
```

1. **URL 연결 문자열에 스트리밍 관련 속성 추가**: 연결 문자열(jdbc url)에 특정 속성을 추가하여 스트리밍 모드를 활성화 
   * 해당 드라이버 및 데이터베이스 버전에 따라 다를 수 있으므로, 문서를 참고
2. **사용 주의점**: 스트리밍 모드에서는 한 번에 하나의 `ResultSet`만 열릴 수 있으므로, 다른 쿼리를 실행하기 전에 먼저 `ResultSet`을 완전히 처리해야 한다. 또한, 커넥션을 닫거나 재사용하기 전에 `ResultSet`을 닫아야 메모리 누수를 방지할 수 있다.

스트리밍 방식으로 처리하면 대량의 데이터를 효율적으로 처리할 수 있지만, 사용 방법에 주의해야 하며, 
애플리케이션 로직에 따라 적합한지 여부를 평가해야 한다.

**In Spring Boot**

**`application.properties` 파일에 설정 추가**: 스트리밍 방식을 사용하려면 JDBC URL에  추가 파라미터 지정 

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/your_database?useCursorFetch=true
```

**JPA**: JPA를 사용하면 `Query` 객체를 생성하고 `setHint` 메서드를 사용하여 힌트를 지정해 스트리밍을 활성화할 수 있다.

```java
Query query = entityManager.createNativeQuery("SELECT * FROM your_table");
query.setHint(QueryHints.HINT_FETCH_SIZE, Integer.MIN_VALUE);
```

## GROUP BY 처리

GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다.

* 인덱스 스캔 방법과 
* 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법 으로 나뉜다. 

그리고 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용한다.

### 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)

GROUP BY가 인덱스를 통해 처리되는 쿼리 는 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가적인 정렬 작업이나 내부 임시 테이블 은 필요하지 않다

쿼리의 실행 계획에서는 Extra 칼럼에 별도로 GROUP BY 관련 코멘트`(Using index for group-by)` 나

임시 테이블 사용 또는 정렬 관련 코멘트`(using temporary, Using filesort”)` 가 표시되지 않는다.

* GROUP BY가 인덱스를 사용해서 처리된다 하더라도 그룹 함수(Aggregation function) 등 의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다



### 루스 인덱스 스캔을 이용하는 GROUP BY

루스(Loose) 인덱스 스캔 방식은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미한다.

실행 계획의 Extra 칼럼에 `“Using index for group-by"` 코멘트가 표시된다.

```mysql
EXPLAIN
	SELECT emp_no
	FROM salaries
	WHERE from_date='1985-03-01'
	GROUP BY emp_no;
```

```
+----+----------+-------+---------+------------------------------------+
| id | table    | type  | key     | Extra                              |
+----+----------+-------+---------+------------------------------------+
| 1  | salaries | range | PRIMARY | Using where; Using index for group-by |
+----+----------+-------+---------+------------------------------------+
```

쿼리 처리 실행 순서

1. ﻿﻿﻿(emp_no, from_date) 인덱스를 차례대로 스캔하면서 emp_no의 첫 번째 유일한 값(그룹 키) "10001"을 찾아낸다.
2. ﻿﻿﻿(emp_no, from_date) 인덱스에서 emp_no가 '10001'인 것 중에서 from_date 값이 '1985-03-01 ' 인 레코드만 가져온다. 이 검색 방법은 1번 단계에서 알아낸 ' 10001' 값과 쿼리의 WHERE 절에 사용된 " from date= 1985-03-01'" 조건을 합쳐서 "emp_no=10001 AND from_date=' 1985-03-01 '" 조건으로 (emp_ no, from_date) 인덱스 를 검색하는 것과 거의 흡사하다.
3. ﻿﻿﻿(emp_no, from_date) 인덱스에서 emp_no의 그다음 유니크한(그룹 키) 값을 가져온다.
4. ﻿﻿﻿3번 단계에서 결과가 더 없으면 처리를 종료하고, 결과가 있다면 2번 과정으로 돌아가서 반복 수행한다.

**GROUP BY 쿼리에서 루스 인덱스 스캔을 사용할 수 없는 경우**

**MIN()과 MAX() 이외의 집합 함수가 사용된 경우**

```mysql
SELECT col1, SUM (col2) FROM tb_test GROUP BY col1;
```

* 루스 인덱스 스캔은 MIN() 또는 MAX()와 같이 특정 범위 내에서 최소 또는 최대 값을 찾을 수 있는 집합 함수와 함께만 사용가능
* 루스 인덱스 스캔은 인덱스의 특정 구간을 빠르게 스캔하면서 그 구간의 최소 또는 최대 값을 찾을 수 있는 방식인데. SUM과 같은 함수는 인덱스의 특정 구간 내 모든 값을 계산해야 하므로 루스 인덱스 스캔을 사용할 수 없다

**GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않는 경우**

```mysql
SELECT col1, col2 FROM tb_test GROUP BY col2, col3;
```

* 루스 인덱스 스캔은 인덱스의 왼쪽부터 오른쪽으로 진행되는데. GROUP BY 절이 인덱스의 왼쪽 컬럼부터 일치하지 않으면, 인덱스 스캔을 통해 효율적으로 데이터를 찾을 수 없으므로 루스 인덱스 스캔을 적용할 수 없다.

**SELECT 절의 칼럼이 GROUP BY와 일치하지 않는 경우**

```mysql
SELECT col1, col3 FROM tb_test GROUP BY col1, col2;
```

* SELECT 절의 칼럼과 GROUP BY 절의 칼럼이 정확히 일치하지 않으면, 그룹화 된 결과의 정확한 표현이 어렵기 때문이다.

이외에도

* **WHERE 절의 조건이 인덱스의 첫 번째 컬럼을 포함하지 않을 경우**
* **GROUP BY 절의 컬럼이 연속되지 않은 인덱스 컬럼일 경우**

* **GROUP BY 절과 ORDER BY 절이 일치하지 않을 경우:**

에 사용 불가하다 



### 임시 테이블을 사용하는 GROUP BY

GROUP BY의 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 임시 테이블을 사용한다

```mysql
EXPLAIN
	SELECT e.last_name, AVG(s.salary)
	FROM employees e, salaries s
	WHERE s.emp_no = e.emp_no
	GROUP BY e.last_name;
```

* 인덱스가 아닌 e.last_name으로 그룹핑 하기 때문이다.

MySQL 8.0부터 GROUP BY가 필요한 경우 내부적으로 GROUP BY 절의 칼럼들로 구성된 유니크 인덱스를 
가진 다음과 같은 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행한다.

```mysql
CREATE TEMPORARY TABLE ... (
	last_name VARCHAR(16), 
  salary INT,
	UNIQUE INDEX ux_lastname (last name)
):
```

그리고 조인의 결과를 한 건씩 가져와 임시 테이블에서 중복 체크를 하면서 임시테이블로 INSERT 또는 UPDATE를 실행한다.

## DISTNCIT 처리

DISTNCIT는 두가지로 구분할 수 있따.

* MIN(), MAX(), COUNT() 같은 집합 함수와 함께 사용되는 경우
* 집합 함수가 없는 경우

집합 함수와 같이 DISTINCT가 사용되는 쿼리의 실행 계획에서 DISTINCT가 인덱스를 사용하지 못 할 때는 항상 임시 테이블이 필요하다

* 하지만 실행 계획의 Extra 칼럼에는 'Tsing temporary” 메시지가 출력되지 않는다. -> 이건 주의해야 할 필요가 있다.

### SELECT DISTINCT

단순히 SELECT되는 레코드 중에서 유니크한 레코드만 가져오고자 하면 SELECT DISTINCT 형태의 쿼리 문장을 사용한다

* 이 경우에는 GROUP BY와 동일한 방식으로 처리된다

```mysql
SELECT DISTINCT emp no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no;
-- 이 둘은 내부적으로 같은 처리를 한다.
```

SELECT 절에 사용된 DISTINCT 키워드는 조회되는 모든 칼럼에 영향을 미치지 여러 칼럼 중에서 일부 칼럼만 유니크하게 조회하는 것은 아니다.

* 집합함수와 함께 사용된 DISTNCT와는 다르다.



### 집합함수와 함께 사용된 DISTNCT - MIN(), MAX(), COUNT()같은

MIN(), MAX(), COUNT() 같은 집합 함수 내에서 DISTINCT를 사용하면 SELECT DISTNCT와는 다르게 처리된다.

집합 함수 내에서 사용된 DISTINCT는 `집합 함수의 인자로 전달된 칼럼값이 유니크한 것`들을 가져온다.

```mysql
EXPLAIN 
	SELECT COUNT(DISTINCT s.salary)
	FROM employees e, salaries s
	WHERE e.emp_no = s.emp_no
	AND e.emp_no BETWEEN 100001 AND 100100:
```

* 이 쿼리는 내부적으로는 "COUNT(DISTINCT s.salary)”를 처리하기 위해 임시 테이블을 사용하지만 실행 계획에는 임시 테이블을 사용한다는 메시지는 표시되지 않는다.

* 위 쿼리의 경우 employees, salaries 테이블을 조인한 결과에서 salary 칼럼 값만 저장하기 위한 임시 테이블을 만들어서 사용

```mysql
CREATE TEMPORARY TABLE temp_table (
    salary int
    UNIQUE INDEX (salary)
);
```

* 이때 임시 테이블의 salary 칼럼에는 유니크 인덱스가 생성되기 때문에 레코드 건수가 많아진다면 상당히 느려질 수 있는 형태의 쿼리다.
  * 유니크 인덱스를 사용하게 되면, 레코드를 삽입할 때마다 해당 값이 테이블 내에서 유니크한지 확인해야 하므로 느려진다.

**만약 COUNT(DISTINCT) 쿼리를 하나 더 추가하게 된다면?** 

```mysql
EXPLAIN 
	SELECT COUNT(DISTINCT s.salary)
	SELECT COUNT(DISTNCIT e.last_name)
	FROM employees e, salaries s
	WHERE e.emp_no = s.emp_no
	AND e.emp_no BETWEEN 100001 AND 100100:
```

* s.salary 칼럼의 값을 저장하는 임시 테이블과 e. last_name 칼럼의 임시 테이블이 필요하므로 2개의 임시 테이블을 사용한다.

* 그러니까 임시테이블 때문에 디스크 I/O, 데이터 복사, 추가 작업(테이블 생성, 데이터 INSERT UPDATE 등)이 일어나므로 매우 느려질 수 있는 부분이다.



위 컬럼들은 모두 인덱스가 없는 컬럼들이다.

**인덱스가 있는 컬럼에 대해 DISTINCT 처리를 수행하면 임시 테이블 없이 최적화된 처리를 수행할 수 있다.**

```mysql
SELECT COUNT (DISTINCT emp_no) FROM employees;
SELECT COUNT (DISTINCT emp_no) FROM dept_emp GROUP BY dept_no;
```

```
 id | table   | type  | key     | rows   | Extra      
----|---------|-------|---------|--------|------------
  1 | dept_emp| index | PRIMARY | 331143 | Using index
```

다음으로 주의할점은 

DISTINCT가 `집합 함수 없이 사용된 경우`와 `집합 함수 내에서 사용된 경우` 쿼리의 결과가 달라진다. 

다음 3개 쿼리의 차이를 잘 기억해두자.

```mysql
-- // 1
SELECT DISTINCT first_name, last_name -- 1
FROM employees
WHERE emp no BETWEEN 10001 AND 10200;

-- // 2
SELECT COUNT (DISTINCT first_name), COUNT(DISTINCT last_name)
FROM employees
WHERE emp_no BETWEEN 10001 AND 10200;

-- // 3
SELECT COUNT(DISTINCT first_name, last_name)
FROM employees
WHERE emp_no BETWEEN 10001 AND 10200;
```

**인덱스가 없다는 가정 하에 셋의 처리를 비교해보자.**

1. first_name과 last_name의 둘을 합쳐 GROUP BY와 동일한 형식으로 처리한다.

   * `GROUP BY first_name, last_name`
   * 인덱스가 없기 때문에 풀 테이블 스캔하고 emp_no로 필터링한다. 또한 정렬과 중복 제거를 수행하기 위해, 내부적으로 임시 테이블을 사용한다. 

   * 처리 방식: `first_name`과 `last_name`의 조합을 중복 제거하여 가져온다.

2. first_name, last_name 각각에 고유한 값의 개수를 계산하기 위해 2개의 임시 테이블을 사용한다.

   * `first_name` 칼럼의 값을 저장하는 임시 테이블과 `last_name` 칼럼의 2개의 임시 테이블을 사용
   * 풀테이블 스캔 하고 enp_no로 필터링한다. 

   * 처리 방식: `first_name`의 유니크한 값의 수와 `last_name`의 유니크한 값의 수를 인덱스가 없으면 임시테이블로 계산한다.

3. first_name과 last_name 둘을 합쳐 고유한 조합의 개수를 계산하기 위해 임시테이블 1개를 사용한다

   * 두 칼럼의 조합을 고려해야 하므로, 쿼리 2보다 복잡한 처리가 필요할 수 있다.
   * 인덱스가 없기 때문에 풀 테이블 스캔하고 emp_no로 필터링한다. 또한 정렬과 중복 제거를 수행하기 위해, 내부적으로 (first_name + last_name) 을 유니크 키로 하는 임시 테이블을 사용한다. 

## 내부 임시 테이블 사용

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블(Internal temporary table)을 사용한다.

* Internal 임시 테이블은 "CREATE TEMPORARY TABLE" 명령으로 만든 임시 테이블과는 다르다.

**internal temporary table(엔진이 그룹핑이나 정렬시 몰래 만듬) vs create temporary table(사용자가 만듬) 차이**

**internal temporary table(내부 임시 테이블)**

- **자동 생성**: 복잡한 쿼리 작업 중에 MySQL 엔진에 의해 자동으로 생성. 일반적으로 `JOIN`, `ORDER BY`, `GROUP BY`, `UNION`, `DISTINCT` 등과 같은 연산에서 사용.
- **수명**: 쿼리가 완료되면 자동으로 삭제.
- **접근성**: 사용자가 직접 접근하거나 수정할 수 없으며, MySQL 엔진만이 내부적으로 사용.
- **저장 형식**: 메모리에 생성됐다가 테이블이 커지면 디스크에 저장

**create temporary table(사용자 임시 테이블)**

- **수동 생성**: 사용자가 `CREATE TEMPORARY TABLE` 문을 사용하여 명시적으로 생성
- **수명**: 세션 종료시, 또는 연결이 끊어지면 삭제됩니다.
- **접근성**: 사용자가 생성한 임시 테이블이므로, 해당 세션 내에서는 일반 테이블처럼 쿼리 및 조작이 가
- **명명 충돌**: 같은 세션 내에서는 동일한 이름의 임시 테이블을 생성할 수 없으며, 다른 세션과는 이름이 충돌하지 않는다.

### 메모리 임시 테이블과 디스크 임시 테이블

MySQL 8.0 버전부터는 메모리는 TempTable이라는 스토리지 엔진을 사용하고, 디스크 에 저장되는 임시 테이블은 InnoDB 스토리지 엔진을 사용한다.

* 스토리지 엔진을 테이블에 MEMORY 또는 TempTable을 사용할 수 있는데 기본값은 TempTable
* MEMORY 스토리지 엔진은 VARB INARY나 VARCHAR 같은 가변 길이 타입을 지원하지 못하므로 최대 길이로 할당해서 메모리 낭비가 심해진다.

> 메모리 임시 테이블을 위해서 MEMORY 스토리지 엔진을 사용한다면 다음의 두 시스템 변수도 같이 적절한 값으로 제어하자.
>
> - ﻿﻿tmp_table_size
> - ﻿﻿max_heap_table_size

임시 테이블의 크기가 1GB보다 커지는 경우 MySOL 서버는 메모리의 임시 테이블을 디스크로 기록하게 되는데, 이때 MySQL 서버는 다음의 2가지 디스크 저장 방 식 중 하나를 선택한다.

* MMAP 파일로 디스크에 기룩

*  InnoDB 테이블로 기록
  * 트랜잭션을 지원한다.

MysQL 서버가 MMAP 파일로 기록할지 InnoDB 테이블로 전환할지는 temptable_use_mmap 시스템 변수로 설정 

* 기본값은 ON

*  `메모리의 TempTable 크기가 1GB를 넘으면 MySQL서버는 메모리의 TempIable을 MMAP 파일로 전환`
  * 메모리의 TempTable을 MMAP 파일로 전환하는 것은 InnoDB 테이블로 전환하는 것보다 오버헤드가 적다!
* 디스크에 생성되는 임시 테이블은 `tmpdir 시스템 변수`에 정의된 디렉터리에 저장된다.

> MySQL 서버는 디스크의 임시 테이블을 생성할 때, 파일 오픈 후 즉시 파일 삭제를 실행한다. 그리고 데이터를 디스크에 저장하기 위해 해당 임시 테이블을 사용한다. 이렇게 함으로써 MySQL 서버가 종료되거나 해당 쿼리가 종료되면 임시 테이블은 즉시 사라지게 보장하는 것이다.

내부 임시 테이블이 처음부터 디스크에 생성되는 경우에는

* GROUP BY 또는 DISTINCT가 매우 크거나 
* 복잡한 서브 쿼리 및 복잡한 조인 및 정렬 작업

internal_tmp.disk_storage_engine 시스템 변수에 설정된 스토리지 엔진이 사용되며 기본값은 InnoDB다

### 임시 테이블이 필요한 쿼리

* ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리

- ﻿﻿ORDER BYL GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- ﻿﻿DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- ﻿﻿UNION이나 UNION DISTINCT가 사용된 쿼리(select_ type 칼럼이 UNION RESULT인 경우)
- ﻿﻿쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

이 밖에도 인덱스를 사용하지 못할 때는 내부 임시 테이블을 생성해야 할 때가 많다.

쿼리의 실행 계획에서 임시 테이블을 사용하는지는 Extra 칼럼에 “using temporary”라는 메시지가 표시되는지 확인하면 된다.

* 해당 6가지 경우 중 1~3 번째 경우에는 Extra 칼럼에 "Using Temporary"가 표시된다. 

* 3~5 번째 경우에는 Extra 칼럼에 "Using Temporary"가 표시되지 않지만 임시 테이블이 사용된다. 
  * 쿼리의 실행 계획에서 `select_type이 DERIVED인` 쿼리는 유니크 인덱스가 없는 내부 임시 테이블이 생성된다

`일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 처리 성능이 상당히 느리다.`

### 임시테이블이 디스크에 생성되는 경우

다음 조건에는 디스크 기반의 임시 테이블을 사용한다

- ﻿﻿UNION이나 UNION ALL에서 S`ELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼`이 있는 경우
- ﻿﻿GROUP BY나 DISTINCT 칼럼에서 `512바이트 이상인 크기의 칼럼`이 있는 경우
- ﻿﻿메모리 임시 테이블의 크기가 
  - MEMORY 스토리지 엔진에서 tmp_table_size 또는 max_heap_table_size 시스템 변수보다 큰 경우
  - TemoTable 스토리지 엔진에서 temptable_max_ram 시스템 변수 값보다 큰 경우

> 8.0.13 버전부터는 BLOB이나 TEXT 칼럼도 메모리에 임시 테이블을 생성할 수 있다.
> 그러나 TempTable 스토리지 엔진에서만이고 MEMORY 스토리지 엔진은 안됀다.

### 임시테이블 관련 상태 변수

임시 테이블이 디스크에 생성됐는지 메모리에 생성됐는지 확인하려면 
MySOL 서버의 상태 변수(SHOW SESSTON STATUS LIKE 'Created_tmp%' ;)를 확인해 보면 된다.

```mysql
FLUSH STATUS;

SELECT first_name, last_name
FROM employees
GROUP BY first_name, last_name;

SHOW SESSION STATUS LIKE 'Created_tmp%';
```

1. 테스트 쿼리를 실행하기 전에 먼저 "FLUSH STATUS" 명령을 실행해 현재 세션의 상태 값을 초기화
2. 그리고 SELECT 쿼리를 실행한 후, 다시 상태 조회 명령을 실행
   * ﻿﻿Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값. 내부 임시 테이블이 메모리에 만들어졌는지 디스크에 만들어졌는지를 구분하지 않고 모두 누적한다.
   * ﻿﻿Created_tmp_disk_tables: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값

```
+------------------------+-------+
| Variable name          | Value |
+------------------------+-------+
| Created_tmp_disk_tables| 1     |
| Created_tmp_tables     | 1     |
+------------------------+-------+
```

* 임시 테이블이 1개 생성됐는데, "Created_tmp_disk_tables" 상태 변수 값의 변화를 보면 해당 임시 테이블이 디스크에 만들어진것을 확인 가능하다



# 9.3 고급 최적화

옵티마이저가 실행 계획을 수립할 때 `통계 정보`와 `옵티마이저 옵션`을 결합해서 최적의 실행 계획을 수립한다.

옵티마이저 옵션의 종류

* 조인 관련된 옵티마이저 옵션
* 옵티마이저 스위치

## 옵티마이저 스위치 옵션

옵티마이저 스위치 옵션은 `optimizer_switch` 시스템 변수를 이용해서 제어하는데,

 optimizer_switch 시스템 변수에는 여러 개의 옵션을 세트로 묶어서 설정하는 방식으로 사용한다.

| 옵티마이저 스위치 이름              | 기본값 | 설명                                                    |
| ----------------------------------- | ------ | ------------------------------------------------------- |
| batched_key_access                  | off    | BKA 조인 알고리즘을 사용할지 여부 설정                  |
| block_nested_loop                   | on     | Block Nested Loop 조인 알고리즘을 사용할지 여부 설정    |
| engine_condition_pushdown           | on     | Engine Condition Pushdown 기능을 사용할지 여부 설정     |
| index_condition_pushdown            | on     | Index Condition Pushdown 기능을 사용할지 여부 설정      |
| use_index_extensions                | on     | Index Extension 최적화를 사용할지 여부 설정             |
| index_merge                         | on     | Index Merge 최적화를 사용할지 여부 설정                 |
| index_merge_intersection            | on     | Index Merge Intersection 최적화를 사용할지 여부 설정    |
| index_merge_sort_union              | on     | Index Merge Sort Union 최적화를 사용할지 여부 설정      |
| index_merge_union                   | on     | Index Merge Union 최적화를 사용할지 여부 설정           |
| MRR                                 | on     | MRR 최적화를 사용할지 여부 설정                         |
| mrr_cost_based                      | on     | 비용 기반의 MRR 최적화를 사용할지 여부 설정             |
| semijoin                            | on     | 세미 조인 최적화를 사용할지 여부 설정                   |
| firstmatch                          | on     | FirstMatch 세미 조인 최적화를 사용할지 여부 설정        |
| loosescan                           | on     | LooseScan 세미 조인 최적화를 사용할지 여부 설정         |
| materialization                     | on     | Materialization 최적화를 사용할지 여부 설정             |
| subquery_materialization_cost_based | on     | 비용 기반의 Materialization 최적화를 사용할지 여부 설정 |

옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변수이다 

* MySQL 서버 전체적으로 또는 현재 커넥션에 대해서만 다음과 같이 설정할 수 있다.

```mysql
-- // MySQL 서버 전체적으로 옵티마이저 스위치 설정
SET GLOBAL optimizer_switch='index_merge=on, index_merge_union=on,..';

-- //현재 커넥션의 옵티마이저 스위치만 설정
SET SESSION optimizer_switch='index_merge=on,index _merge_union=on,..';

-- // "SET_VAR" 옵티마이저 힌트를 이용해 현재 쿼리에만 설정
SELECT /*+ SET_VAR(optimizer_switch='condition_fanout_filter=off') */
...
FROM ...
```

### MRR(Multi-Range Read)과 배치 키 액세스(batched_key_access)

기존까지 지원하던 조인 방식은 네스티드 루프 조인이였다

* 드라이빙 테이블에서 한건 읽어 드리븐 테이블의 일치하는 레코드를 찾아 조인을 수행하는 알고리즘

조인 처리는 MySQL 엔진이 처리하지만 실제 레코드를 검색하고 읽는 부분은 InnoDB 스토리지 엔진이 담당한다.

* 레코드를 찾고 읽는 스토리지 엔진에서는 아무런 최적화를 수행할수가 없었다.
* 일반적인 Nested Loop 조인(NLJ) 의 경우 Driving Table(선행 테이블)에서 조회되는 값으로 조인되는 Driven Table을 접근하게 되며 조인시 데이터 저장 순서대로 조회를 하는 것이 아니기 때문에 랜덤 액세스, 랜덤 I/O가 발생한다.

이를 보완하기 위해 MRR을 응용해서 실행되는 BKA 조인이 나왔다

* MRR : Random I/O를 Sequential I/O로 처리할 수 있도록 도와주는 기능

**BKA 조인(Bached Key Access join)**

드라이빙 테이블의 레코드를 읽어 드리븐 테이블과의 조인을 즉시 실행하지 않고, 조인 대상을 버퍼링 한 후 조인 버퍼에 레코드가 가득 차면 MySQL 엔진이 버퍼링된 레코드들을 스토리지 엔진으로 한번에 요청하여 조인을 수행

<p align="center">
  <img src="./images/9장 옵티마이저와 힌트//image-20230813210231569.png" align="left">
  <img src="./images/9장 옵티마이저와 힌트//image-20230813210632978.png" align="right">
  <figcaption align="center">출처 : https://blog.naver.com/seuis398/70159183472</figcaption>
</p>



* 먼저  Driving Table 에서 조회되는 값들을 먼저 조인 버퍼(join_buffer_size)를 채운다.

* 버퍼가 채워지면 정렬을 한 후, BKA 알고리즘은 버퍼의 모든 행에 대해 조인 할 Driven Table에 액세스하기 위한 키(rowid(primary key))를 채운다

* rowid(primary key) 값으로 조인되는 테이블(Joined Table)을 대상으로 **Multi Range Read(MRR)** **연산을 수행**한다.

  결과 값을 조인 버퍼(join_buffer_size)에 채워진 드라이빙 테이블 값과 연결하여 한번에 읽어온다(시퀀셜 액세스)

> 결국 BKA 조인은 랜덤 액세스를 줄이고 시퀀셜 액세스를 이용해 디스크 I/O의 효율성을 높이기 위한 것이다. 
> 여러 레코드를 한 번에 처리하므로,디스크 헤드의 이동이 줄어들고, 데이터를 일괄 처리함으로써 
>  디스크에서 데이터를 읽는 작업이 더 효율적이게 되므로 전반적인 성능이 향상된다.

왜 순차 액세스(시퀀셜)가 더 좋은지 다시한번 정리하자면,

- 회전 드라이브는 헤드를 앞뒤로 움직일 필요가 없고
- 각 디스크 페이지는 정확히 한 번만 읽히므로 디스크 캐시(또는 버퍼 풀)에 의존하여 동일한 페이지를 여러 번 읽지 않아도 된다
- 때문에 순차적으로 읽는것이 더 빠르다

참조하면 좋을곳 :

*  https://mariadb.com/kb/en/multi-range-read-optimization/

* https://dev.mysql.com/doc/refman/8.0/en/bnl-bka-optimization.html

BKA 조인 최적화는 기본적으로 비활성화 되어있다.

쿼리의 특성에 따라 BKA 조인이 큰 도움이 되는 경우도 있지만, 

BKA 조인을 사용하게 되면 `부가적인 정렬 작업`이 필요해지면서 오히려 성능에 안 좋은 영향을 미치는 경우도 있다.

MRR 활성화

```mysql
set optimizer_switch='mrr=on,batched_key_access=on';    
-- mrr은 별도로 설정해 주지 않아도 기본 활성화 되어 있다. BKA만 비활성화 되어있다.
```

* MySQL Cluster 환경에서는 Batched Key Access(BKA) 처리가 되는 경우에 매 Record 마다 ndbd 노드간 통신을 하지 않고, 버퍼에 채워진 데이터로 한번의 작업으로 조인처리를 하기 때문에 Round-trip Latency를 줄일 수 있다는 추가적인 장점도 존재한다

**언제 사용하면 좋을까?**

* 대용량 조인
* 드라이빙 테이블이 크지만 드리븐 테이블의 레코드와 매칭되는 레코드 수가 상대적으로 적은 경우

* 인덱스 사용 가능, 버퍼 메모리 충분한경우, 네트워크가 지연될 수 있는 경우

### 블록 네스티드 루프 조인(block_nested_loop_join)

MySOL 서버에서 사용되는 대부분의 조인은 네스티드 루프 조인(Nested Loop Join)인데, 

조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.

**NL 조인과 BNL조인의 가장 큰 차이** 

* 조인 버퍼(join_buffer_size 시스템 설정으로 조정되는 조인을 위한 버퍼)가 사용되는지 여부
* 조인에서 드라 이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되는지

조인 알고리즘에서 “Block”이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용됐다는 것을 의미하는데, 

조인 쿼리의 Extra 칼럼에 `"Using Join buffer"` 의 실행 계획은 조인 버퍼를 사용한다는 것을 의미 한다.

* 만약 드라이빙 테이블에서 일치하는 레코드가 1,000건이었는데, 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 드리븐 테이블에서 연결되는 레코드를 찾기 위해 1,000번의 풀 테이블 스캔을 해야 한다. 그래서 드리븐 테이블을 검색할 때 인덱스를 사용할 수 없는 쿼리는 상당히 느려진다.

<img src="./images/9장 옵티마이저와 힌트//image-20230813214117462.png" width = 800 height = 550>

다음 쿼리와 실행계획을 보자

```mysql
SELECT *
FROM dept_emp de, employees e
WHERE de.from_date> '1995-01-01' AND e.emp_no < 109004;

-- //
+----+--------------+-------+--------+--------------+--------------------------------------+
| id | select type  | table | type   | key          | Extra                                |
+----+--------------+-------+--------+--------------+--------------------------------------+
| 1  | SIMPLE       | de    | range  | ix_fromdate  | Using index condition                |
| 1  | SIMPLE       | e     | range  | PRIMARY      | Using join buffer (block nested loop)|
+----+--------------+-------+--------+--------------+--------------------------------------+
```

1. ﻿﻿﻿dept_emp 테이블의 ix_fromdate 인덱스를 이용해(from_date>'1995-01-01') 조건을 만족하는 레코드를 검색한다.
2. ﻿﻿﻿조인에 필요한 나머지 칼럼을 모두 dept_emp 테이블로부터 읽어서 조인 버퍼에 저장하다.
3. ﻿﻿﻿employees 테이블의 프라이머리 키를 이용해 (emp_no<109004) 조건을 만족하는 레코드를 검색한다.
4. ﻿﻿﻿3번에서 검색된 결과(employees)에 위 2번의 캐시된 조인 버퍼의 레코드(dept_emp)를 결합해서 반환한다.

이상한점을 찾아보자.

조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인것처럼 실행된다.

* 쿼리의 실행계획상에서는 드라이빙이 demp_emp, 드리븐이 employees이다
* 실제 드라이빙 테이블 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식이다.

* 이게 왜 그러냐면
  * 일반적인 Nested Loop Join에서는 드라이빙 테이블의 각 레코드에 대해 드리븐 테이블을 검색하고 조인을 즉시 수행하기 때문이다.
  * 여기서는 드라이빙 테이블을 먼저 다 읽고 드리븐 테이블을 조회하는것이다.

BNL 알고리즘의 원리를 정리하자면 Driving 테이블의 결과를 조인 버퍼에 저장하고 메모리 루프의 각 데이터 행을 전체 버퍼의 레코드와 비교하여 내부 루프의 스캔 횟수를 줄이는 것이다.

ex) 드라이빙 테이블 where 결과 후 1000개 행이 있고, 조인 버퍼에 100개 행이 들어갈 수 있다면?

* NL의 경우 Driving 테이블의 각 행마다 Driven 테이블을 전체 스캔해야 하므로, Driving 테이블에 1000개의 행이 있다면 Driven 테이블을 1000번 스캔해야 한다
* Driving 테이블에서 1000개의 행을 100개 단위로 버퍼에 저장하고 한 번에 비교한다면, Driven 테이블을 스캔하는 횟수는 1000 / 100 = 10번이 되는것이다.

> MySQL 8.0.18 버전부터는 해시 조인 알고리즘이 도입되어서 
> MySQL 8.0.20 버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않고! 
> 해시 조인 알고리즘을 사용하므로 MysQL 8.0.20 이후의 버전이라면 Extra에 Using Join Buffer 메시지는 표시되지 않을 수 있다.
>
> \- https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html

### 인덱스 컨디션 푸시다운(index_condition_pushdown)

인덱스 컨디션 푸시다운(Index Condition Pushdown, ICP)은 MySQL에서 행을 검색하는 쿼리 최적화 기법 중 하나로

스토리지 엔진에서 인덱스와 조건절을 이용해 걸러내서 , 필요하지 않은 레코드의 처리를 MySQL 엔진에서 줄이는 역할을 한다.

* 일반적인 쿼리 처리 과정에서는 인덱스 스캔 후 필터링 조건을 스토리지 엔진이 아닌 MySQL 서버 레벨에서 평가한다. 그래서 인덱스를 통해 얻은 레코드 중 일부는 조건에 맞지 않아 필터링되어 버려질 수 있다.

인덱스 컨디션 푸시다운을 사용하면, 이러한 조건의 일부를 `인덱스 스캔 과정에 푸시`하여 스토리지 엔진에서 미리 필터링할 수 있어

`불필요한 레코드의 전송과 처리를 줄일 수 있어, 쿼리 성능이 향상된다.`

* 즉 필터링 조건(where)의 일부를 스토리지 엔진(예: InnoDB)에서 미리 평가해서 MySQL 엔진에서는 조금 비교하는것이다
* 쿼리를 실행할 때, 스토리지 엔진은 해당 테이블의 인덱스를 통해 필요한 레코드를 가져오고, MySQL 엔진은 그 레코드들에 대해 WHERE 절에 명시된 필터링 조건을 적용하여 걸러낸다.

> 인덱스를 비교하는 작업은 실제 InnoDB 스토리지 엔진이 수행하지만 테이블의 레코드에서 
> first_name 조건을 비교하는 작업은 MySQL 엔진이 수행하는 작업이다

```mysql
SELECT * FROM emplovees WHERE last name= 'Acton' AND first name LIKE '%sal'
```

위 쿼리의 실행 계획을 확인해 보면 extra 칼럼에 "Using where"가 표시되는데, "using where"는 `InnoDB 스토리지 엔진이 읽어서` 반환해준 레코드가 인덱스를 사용할 수 없는 WHERE 조건에 일치하는지 검사하는 과정이다.

```
+----+--------------+-----------+-------+--------------------+------+------------------+
| id | select_type  | table     | type  | key                | key_len | Extra           |
+----+--------------+-----------+-------+--------------------+------+------------------+
| 1  | SIMPLE       | employees | ref   | ix_lastname_firstname | 66     | Using where     |
+----+--------------+-----------+-------+--------------------+------+------------------+
```

**인덱스 컨디션 푸시다운이 작동하지 않는다면**

만약 last_name = 'Acton'이 10만건인데, 그중에서 단 1건만 first_name like '%sal' 이라면 필요없는 레코드 읽기가 99,999번 발생한 것이다.

* 99,999건의 쓸모없는 데이터를 추가적으로 MySQL 엔진으로 보내서 필터링 하는 작업을 해버린 것

<img src="./images/9장 옵티마이저와 힌트//image-20230813222110836.png" width = 800 height = 400>

* 이미 한번 읽은 ix_lastname_firstname의 인덱스의 first_name 컬럼을 이용해서 `%sal`을 비교하여 걸러내면 되는데, 걸러내지 않고 MySQL 엔진에서 using where로 처리해버리는 불상사가 일어난것. 
* 때문에 스토리지 엔진에서 불필요하게 추가적으로 테이블 읽기를 수행한다.

**인덱스 컨디션 푸시다운을 사용 한다면**

<img src="./images/9장 옵티마이저와 힌트//image-20230813222334597.png" width = 700 height = 400>

* 스토리지 엔진이 ix_lastname_firstname의 인덱스의 first_name 컬럼값을 비교해서 미리 걸러서 해당하는 값만 반환한다.

쿼리의 실행 계획을 확인해 보면 다음과 같이 Extra 칼럼에 “Using where”가 없어지고 “Using index condition”이 출력되는 것을 확인할 수 있다.

```mysql
+----+--------------+-----------+------+--------------------+----------+--------------------+
| id | select_type  | table     | type | key                | key_len  | Extra              |
+----+--------------+-----------+------+--------------------+----------+--------------------+
| 1  | SIMPLE       | employees | ref  | ix_lastname_firstname | 66       | Using index condition |
+----+--------------+-----------+------+--------------------+----------+--------------------+
```

* Using index condition 을 사용하는것을 볼 수 있다.-> 성능이 훨 좋다 짱짱

### 인덱스 확장(use_index_extensions)

`use_index_extensions` 옵티마이저 옵션은 InnoDB 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션이다.

인덱스 확장 기능을 사용하면, 쿼리의 성능을 향상시키기 위해 복합 인덱스를 추가로 생성할 필요가 없게 되며, 기존의 단일 컬럼 인덱스만으로도 효율적인 쿼리 처리가 가능해진다.

예를들어 다음과 같은 테이블이 있을 때

```mysql
CREATE TABLE dept_emp ( 
  emp_no INT NOT NULL, 
  dept_no CHAR(4) NOT NULL, 
  from_date DATE NOT NULL, 
  to_date DATE NOT NULL, 
  PRIMARY KEY (dept_no, emp_no),
	KEY ix_fromdate (from_date)
) ENGINE=InnoDB;
```

* PK : dept_no, emp_no - 복합키
* 세컨더리 인덱스 : ix_from_date
* 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 Pk인 dept_no와 emp no 칼럼을 순서대로(프라이머리 키에 명시된 순서) 포함한다. 그래서 최종적으로 ix_fromdate 인덱스는 (from_date, dept_no, emp_no) 조합으로 인덱스를 생성한 것과 흡사하게 작동할 수 있게 된다.

만약 다음 쿼리를 실행했을 때

```mysql
SELECT COUNT(*) 
FROM dept_emp 
WHERE from_date='1987-07-25' AND dept_no='d001';
```

옵티마이저가 인덱스 확장을 고려하지 않으면 dept_no 칼럼만 이용해서 가져와서 더 많이 걸러야 한다.

인덱스 확장을 사용하면 내부적으로 (from_date, dept_no, emp_no) 조합 중 (from_date, dept_no)를 사용하여 

스토리지 엔진에서 데이터를 더 많이 걸러 가져오게 된다. 

```mysql
EXPLAIN SELECT COUNT(*) FROM dept_emp WHERE from_date='1987-07-25' AND dept_no='d001';

+----+-------------+----------+------+--------------+---------+------------+
| id | select_type | table    | type | key          | key_len | ref        | 
+----+-------------+----------+------+--------------+---------+------------+
| 1  | SIMPLE      | dept_emp | ref  | ix_fromdate  | 19      | const,const|
+----+-------------+----------+------+--------------+---------+------------+
```

* 실제로 실행 계획의 key_len 칼럼은  인덱스를 구성하는 칼럼 중에서 어느 칼럼까지 사용 했는지를 바이트 수로 보여주는데 from_date key byte 크기 + dept_no key byte 크기 를 더한 값이 나온다. 
* ref는 하나가 아닌 두 개의 키 부분을 사용하기 때문에 참조 값이 const에서 const, const로 변경된다

또한 인덱스 확장을 사용하면 정렬 작업(ORDER BY)도 인덱스를 활용해서 처리되므로 실행 계획에서 Using Filesort도 사용하지 않는다. 

### 인덱스 머지(index_merge)

인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다

* 여러 개의 인덱스를 병합하여 쿼리를 수행하는 방식
* WHERE 절에 있는 여러 조건을 독립적으로 평가하고 결과를 병합함으로써, 복잡한 쿼리에 대해 더 효율적인 실행 계획을 만들 수 있게 해준다.

쿼리에 사용된 각 각의 조건이 서로 다른 인덱스를 사용할 수 있고 `그 조건을 만족하는 레코드 건수가 많을 것으로 예상 될 때` MySQL 서버는 인덱스 머지 실행 계획을 선택한다.

인덱스 머지 기법은 3가지 세부 실행 계획으로 나눠볼 수 있다.

* `index_merge_intersection`: 각 인덱스에 대한 결과를 교집합으로 병합
* `index_merge_sort_union`: 각 인덱스에 대한 결과를 정렬된 합집합으로 병합

- `index_merge_union`: 각 인덱스에 대한 결과를 합집합으로 병합

### index_merge_intersection - 인덱스 머지 교집합

여러 인덱스 스캔의 결과를 교집합으로 병합한다. 

각 인덱스 스캔의 결과가 AND 조건으로 연결되는 경우에 이 방식을 사용하여 최적화한다

ex) employees 테이블의 first_name 칼럼과 emp_no 칼럼 모 두 각각의 인덱스(ix_ firstname, PRIMARY)를 가지고 있다.

```mysql
EXPLAIN SELECT *
FROM employees
WHERE first name='Georgi' AND emp_no BETWEEN 10000 AND 20000;


+------------+-----------------------+------------+----------------------------------------+
| type       | key                   | key_len    | Extra                                  |
+------------+-----------------------+------------+----------------------------------------+
| index_merge| ix_firstname, PRIMARY | 62,4       | Using intersect(ix_firstname, PRIMARY);|
|            |                       |            | Using where                            |
+------------+-----------------------+------------+----------------------------------------+
```

* 실행 계획의 Extra 칼럼에 “Using intersect"라고 표시된 것은 이 쿼리가 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환했다는 것을 의미
* 만약 Georgi가 253건이고 emp_no 조건이 10,000개라면
  * name 인덱스만 사용하면 253건을 검색한 다음 emp_no 조건에 일치하는 레코드만 반환해야함
  * emo_no 인덱스만 사용하면 1만건을 읽어와 name = georgi인 애들만 반환해야함 
  * 그러나 실제 결과는 10건밖에 없다면?
* 즉, 실제 결과보다 두 조건 모두 상대적으로 많은 레코드를 가져와야 한다는 것을 아는 경우 인덱스 머지 교집합을 이용하여 둘 다 사용해서 적게 가져온다

**index_merge_intersection 비활성화 방법**

```mysql
-- // MySQL 서버 전체적으로 index_merge_intersection 최적화 비활성화
SET GLOBAL optimizer_switch='index_merge_intersection=off';

-- // 현재 커넥션에 대해 index_merge_intersection 최적화 비활성화
SET SESSION optimizer_switch='index_merge_intersection=off';

-- // 현재 쿼리에서만 index_merge_intersection 최적화 비활성화
EXPLAIN
SELECT /*+ SET_VAR(optimizer_switch='index _merge_intersection=off') */ *
FROM employees
WHERE first name='Georgi AND emp_no BETWEEN 10000 AND 20000;
```

### index_merge_union - 인덱스 머지 합집합

여러 인덱스 스캔의 결과를 합집합으로 병합. 

각 인덱스 스캔의 결과가 OR 조건으로 연결되는 경우에 이 방식을 사용하여 최적화한다.

ex) first_name, hire_date 컬럼에 각각 인덱스 존재

```mysql
SELECT *
FROM employees
WHERE first name='Matt' OR hire_date='1987-03-31';
```

실행계획

```mysql
+-------------+---------------------------+---------+---------------------------------------+
| key         | type                      | key_len | Extra                                 |
+-------------+---------------------------+---------+---------------------------------------+
| index_merge | ix_firstname,ix_hiredate  | 58,3    | Using union(ix_firstname,ix_hiredate) |
+-------------+---------------------------+---------+---------------------------------------+
```

* 'Using union (ix_firstname, ix_hiredate)' 이라는 것은 ix_firstname의 결과와 ix_hiredate를 이용한 검색 결과를 Union 알고리즘으로 병합하여 합집합으로 가져왔다는 것을 의미한다

* 각각 인덱스를 이용한 결과를 합치다 보면 중복될 수 있다.
* MySOL 서버는 두 집합에서 하나씩 가져와서 PK 값이 중복된지 서로 비교하면서 우선순위큐를 사용하여 중복을 제거한다

> 주의할점.
>
> 2개의 WHERE 조건 이 OR 연산자로 연결된 경우에는 둘 중 하나라도 제대로 인덱스를 사용하지 못하면 
> 항상 풀 테이블 스캔으로밖에 처리 하지 못한다.

### index_merge_sort_union - 인덱스 머지 정렬 후 합집합

인덱스 머지 작업을 하는 도중 정렬이 필요한 경우 인덱스 머지 최적화의 'Sort union' 알고리즘을 사용한다.

 ex) 예제 실행계획

```mysql

+-------------+---------------------------+---------+---------------------------------------+
| key         | type                      | key_len | Extra                                 |
+-------------+---------------------------+---------+---------------------------------------+
| index_merge | ix_firstname,ix_hiredate  | 58,3    | Using sort_union(ix_firstname,ix_hiredate) |
+-------------+---------------------------+---------+---------------------------------------+
```

인덱스 머지 최적화에서 중복 제지를 위해 강제로 정렬을 수행해야 하는 경우에는 실행 계획의 Extra 칼럼에 Tsing sort_union 문구가 표시된다.



## 세미 조인(semi join)

세미 조인 : 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리

ex) 세미 조인 쿼리 예시

```mysql
SELECT *
FROM employees e
WHERE e.emp_no IN
(SELECT de. emp_no FROM dept_emp de WHERE de. from_date='1995-01-01');
```

세미 조인 형태의 쿼리와 안티 세미 조인형태의 쿼리는 최적화 방법이 조금 차이가 있다.
 `"= (subquery)"` 형태와 `"IN (subquery)"` 형태의 세미 조인 쿼리 3가지 최적화 방법

- ﻿﻿세미 조인 최적화
- ﻿﻿IN-to-EXISTS 최적화
- ﻿﻿MATERIALIZATION 최적화

`"<> (subquery)" 형태`와 `"NOT IN (Subquery)"` 형태의 안티 세미 조인 쿼리  2가지의 최적화 방법

- ﻿﻿IN-toEXISTS 최적화 
- ﻿﻿MATERIALIZATION 최적화

> https://dev.mysql.com/doc/refman/8.0/en/semijoins.html

여기서는 서브쿼리 최적화 중에서 최근 도입된 세미 조인 최적화에 대해서만 살펴보겠다.

- ﻿﻿Table Pull-out
- ﻿﻿Duplicate Weed-out

- ﻿﻿First Match
- ﻿﻿Loose Scan
- ﻿﻿Materialization

### 테이블 풀 아웃 -(Table Pull out) 최적화 전략

Table pullout 최적화는 세미 조인의 서브쿼리에 사용된 테이블을

 outer 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화다

* IN(subquery) 형태의 세미 조인이 가장 빈번하게 사용되는 형태

```mysql
EXPLAIN
SELECT * FROM emplovees e
WHERE e. emp_no IN (SELECT de.emp_no FROM dept_emp de WHERE de.dept no='d009');
```

```mysql
+----+--------------+-------+--------+---------+-------+------------+
| id | select_type  | table | type   | key     | rows  | Extra      |
+----+--------------+-------+--------+---------+-------+------------+
| 1  | SIMPLE       | de     | ref   | PRIMARY | 46012 | Using index|
| 1  | SIMPLE       | e      | eq_ref| PRIMARY | 1     | NULL       |
+----+--------------+-------+--------+---------+-------+------------+
```

* Table pullout 최적화는 별도로 실행 계획의 Extra 칼럼에 “Using table pullout”과 같은 문구가 출력되지 않는다
* id 칼럼의 값이 모두 1이라는 동일한 값을 가진다는 것은 두 테이블이 서브쿼리 형태가 아니라 조인으로 처리됐음을 의미한다.

**Table pullout 최적 화의 몇 가지 제한 사항과 특성**

- ﻿﻿Table pullout 최적화는 세미 조인 서브쿼리에서만 사용 가능하다.
- ﻿﻿Table pullout 최적화는 서브쿼리 부분이 UNIQUE 인덱스나 PK 룩업으로 결과가 1건인 경우에만 사용 가능하다.
- ﻿﻿Table pullouto 적용된다고 하더라도 기존 쿼리에서 가능했던 최적화 방법이 사용 불가능한 것은 아니므로
   MySQL에서는 가능하다면 Table pullout 최적화를 최대한 적용한다.
- ﻿﻿Table pullout 최적화는 서브쿼리의 테이블을 아우터 쿼리로 가져와서 조인으로 풀어쓰는 최적화를 수행하는데, 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체는 없어진다.
- ﻿﻿MySQL에서는 "최대한 서브쿼리를 조인으로 풀어서 사용해라"라는 튜닝 가이드가 많은데, Table pullout 최적화는 사실 이 가이드를 그대로 실행하는 것이다. 이제부터는 서브쿼리를 조인으로 풀어서 사용할 필요가 없다.

### 퍼스트 매치(firstmatch) 최적화 전략

First Match 최적화 전략은 IN(subquery) 형태의 세미 조인을 EXISTS(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행된다

* 서브쿼리가 아니라 조인으로 풀어서 실행하면서 최적화

```mysql
EXPLAIN
SELECT *
FROM employees e WHERE e.first_name='Matt'
AND e.emp_no 
IN (
	SELECT t.emp_no FROM titles t
	WHERE t.from_date BETWEEN 1995-01-01' AND 1995-01-30'
);
```

실행 계획

```
+----+-------+-------+--------------+------+-------------------------------------------+
| id | table | type  | key          | rows | Extra                                     |
+----+-------+-------+--------------+------+-------------------------------------------+
| 1  | e     | ref   | ix_firstname | 233  | NULL     										             |
| 1  | t     | ref   | PRIMARY      | 1    |  Using where; Using index;  FirstMatch(e);|
+----+-------+-------+--------------+------+-------------------------------------------+
```

* id 컬럼 값이 모두 1인걸로 보아 IN절의 titles는 서브 쿼리 패턴으로 실행되지 않음
* PirstMatich(e) 문구는 employees 테이블의 레코드에 대해 titles 테이블에 일치하는 레코드 1건만 찾으면 더이상의 titles 테이블 검색을 하지 않는다는 것을 의미한다

FirstMatch 최적화 또한 특정 형태의 서브쿼리에서 자주 사용되는 최적화다. FirstMatch 최적화의 몇 가지 제한 사항과 특성을 살펴보자.

*  FirstMatch는 서브쿼리에서 하나의 레코드만 검색되면 더이상의 검색을 멈추는 단축 실행 경로(Short-cut path)이 기 때문에FirstMatch 최적화에서 서브쿼리는 그 서브쿼리가 참조하는 모든 `아우터 테이블이 먼저 조회된 이후에` 실행된다.

* FirstMatch 최적화가 사용되면 실행 계획의 Extra 칼럼에는 FirstMatch(table-N)” 문구가 표시된다.

* FirstMatch 최적화는 상관 서브쿼리(Correlated subquery)에서도 사용될 수 있다.
  * 상관 서브쿼리란 외부 쿼리(main query)의 한 레코드마다 반복적으로 실행되는 서브쿼리
  * 상관 서브쿼리는 외부 쿼리의 열 값을 참조하며, 외부 쿼리의 각 행마다 서브쿼리가 다시 계산된다.

- ﻿﻿FirstMatch 최적화는 GROUP BY나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다.

FirstMatch 최적화는 optimizer_switch 시스템 변수에서 semitjoin 옵션과 firstmatch 옵션이 모두 ON으로 활성화된 경우에만 사용할 수 있다. 

firstmatch 최적화만 비활성화하려면 `semijoin 옵티마이저 옵션은 ON` `firstmatch 옵티마이저 옵션만 OFF로 비활성화`하면 된다.

### 루스 스캔(loosescan)

루스 인덱스 스캔이랑 비슷한 읽기 방식을 사용하는데 GROUP BY 쿼리나 중복된 값을 제거하는 쿼리(DISTINCT)에서 효율적이다. 

루스 스캔은 인덱스를 이용하여 쿼리의 수행 시간을 최소화하려고 하는 방법이다.

```mysql
EXPLAIN
SELECT * 
FROM departments d 
WHERE d.dept_no IN (SELECT de.dept_no FROM dept_emp de );
```

<img src="./images/9장 옵티마이저와 힌트//image-20230814212454337.png" width = 700 height = 600>

```
+----+-------+--------+---------+-------+-------------------------+
| id | table | type   | key     | rows  | Extra                   |
+----+-------+--------+---------+-------+-------------------------+
| 1  | d     | index  | PRIMARY | 331143| Using index; LooseScan  |
| 1  | e     | ref    | PRIMARY | 1     | NULL                    |
+----+-------+--------+---------+-------+-------------------------+
```

Loosescan 최적화는 다음과 같은 특성을 가진다.

* 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 그다음 아우터 테이블을 드리븐으로 사용해서 조인을 수행한다. 
  * 서브쿼리 테이블을 먼저 즉 드라이빙
* 그래서 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화다.

 루스 인덱스 스캔 최적화는 다음과 같은 형태의 서브쿼리들에서 사용할 수 있다.

```mysql
SELECT .. FROM ... WHERE expr IN (SELECT keypart1 FROM tab WHERE ...)
SELECT .. FROM ... WHERE expr IN (SELECT keypart2 FROM tab WHERE keypart1 = '상수' ..)
```

### 구체화(Materialization)

Materialization 최적화는 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미다. 

* 구체화(Materialization)는 쉽게 표현하면 내부 임시 테이블을 생성한다는 것을 의미

*  일반적으로 메모리에서 하위 테이블 결과를 임시 테이블로 생성하여 쿼리 실행 속도를 높인다

**서브쿼리 구체화의 실행계획**

```
+----+----------------+------------+-------+--------+---------------------+
| id | select_type    | table      | type  | key    | ref                 |
+----+----------------+------------+-------+--------+---------------------+
| 1  | SIMPLE         | (subquery2)| ALL   | NULL        | NULL            |
| 1  | SIMPLE         | de         | eq_ref| PRIMARY     | <subquery2).emp_no|
| 2  | MATERIALIZED   | e          | ref   | ix_fromdate | const           |
+----+----------------+------------+-------+--------+---------------------+
```

* detp_emp(de)를 읽는 서브쿼리가 먼저 실행되어 그 결과로 임시테이블 subquery2가 만들어졌다.
* 그리고 subquery2와 employees 테이블을 조인해서 결과를 반환한다

Materialization 최적화는 optimizer_switch 시스템 변수에서 semijoin 옵션과 materialization 옵션이 모두 On으로 활성화된 경우에만 사용된다. MySQL 8.0 버전에서는 기본적으로 활성화 되어있다. 

Materialization 최적화만 비활성화하려면

semijoin 옵티마이저 옵션은 ON, materialization 옵티마이저 옵션만 OFF로 비활성화하면 된다.

### 중복 제거(Duplicated weed-out)

Duplicate Weedout은 세미 조인 서브쿼리를 일반적인 INNER J0IN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘

실제로 Duplicate Weedout 최적화 알고리즘은 원본 쿼리를 INNER JOIN + GROUP BY 절로 바꿔서 실행하는 것과 동일한 작업으로 쿼리를 처리한다

```mysql
-- // 최적화 전
EXPLAIN
SELECT * FROM employees e
WHERE e.emp_no IN (SELECT s.emp_no FROM salaries s WHERE s.salary > 150000);

-- // 최적화 후
SELECT e.*
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no AND s.salary > 150000
GROUP BY e.emp_no;
```

1. ﻿﻿﻿salaries 테이블의 ix_salary 인덱스를 스캔해서 salary > 150000을 검색해 empLoyees 조인을 실행
2. ﻿﻿﻿조인된 결과를 임시 테이블에 저장
3. ﻿﻿﻿임시 테이블에 저장된 결과에서 emp_no 기준으로 중복 제거
4. ﻿﻿﻿중복을 제거하고 남은 레코드를 최종적으로 반환

**실행계획**

```
+----+-----------+-------+-------+-----------+-----------------------------------------+
| id | select    | table | type  | key       | Extra                                   |
+----+-----------+-------+-------+-----------+-----------------------------------------+
| 1  | SIMPLE    | e     | range | ix_salary | Using where; Using index; Start temporary|
| 1  | SIMPLE    | t     | ref   | PRIMARY   | End temporary                           |
+----+-----------+-------+-------+-----------+-----------------------------------------+
```

* 사실 1번에서 조인을 수행하는 작업과 2번에서 임시 테이블로 저장하는 작업은 반복적으로 실행되는 과정
* 반복과정이 실행되는 라인에는 Start temporary, 끝나는 테이블의 실해예획에는 End temporary
* Start / End temporary 문구의 구간이 Duplicate Weedout 최적화의 처리 과정

Duplicate Weedout 최적화는 다음과 같은 장점과 제약 사항이 있다.

- ﻿﻿서브쿼리가 상관 서브쿼리라고 하더라도 사용할 수 있는 최적화다.
- ﻿﻿서브쿼리가 GROUP BY나 집합 함수가 사용된 경우에는 사용될 수 없다.
- ﻿﻿Duplicate Weedout은 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화할 수 있는 방법이 많다.

### 컨디션 팬아웃(condition_fanout_filter)

컨디션 팬아웃 필터는 필요한 데이터만 가져오기 위해 가능한 조인 조건을 미리 필터링하여 조인한다. 

조인을 실행할 때 `테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미친다`. 

예를 들어, A 테이블과 B 테이블을 조인할 때 

A 테이블에는 조건에 일치하는 레코드가 1만 건이고 B 테이블에는 일치하는 레코드 건수가 10건이라고 가정해보자.

* 만약 A 테이블을 드라이빙 테이블로 잡으면 B 테이블을 1만번 읽어야 하며 B 테이블을 드라이빙 테이블로 잡으면 10번만 읽으면 된다.

* 그래서 옵티마이저는 조인시가능하면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다.

> 참고
>
> 옵티마이저가 실행 계획을 수립할 때 테이블이나 인덱스의 통계 정보만 사용하는 것이 아니라 다음의 순서대로 사용 가능한 방식을 선택한다.
>
> 1. ﻿﻿﻿레인지 옵티마이저(Range optimizer)를 이용한 예측
> 2. ﻿﻿﻿히스토그램을 이용한 예측
> 3. ﻿﻿﻿인덱스 통계를 이용한 예측
> 4. ﻿﻿﻿추측에 기반한 예측(Guesstimates)

### 파생 테이블 머지 (derived_merge)

FROM절에 사용된 서브 쿼리를 파생 테이블이라고 한다.

derived_merge는 파생 테이블(하위 쿼리의 결과로 생성된 테이블)을 주 쿼리와 병합하는 과정이다.

파생 테이블 머지(`derived_merge`)는 SQL 쿼리의 최적화 기법 중 하나로, 파생 테이블(하위 쿼리의 결과로 생성된 테이블)을 주 쿼리와 병합하는 과정이다.

파생 테이블 머지를 사용하면, 하위 쿼리의 결과를 임시 테이블로 생성하는 대신, 하위 쿼리의 조건을 주 쿼리에 직접 적용하여 전체 쿼리를 더 효율적으로 실행할 수 있다

derived_table은 실행계획에서 derived라고 표시되면 인라인 뷰가 사용되는것이므로 튜닝할 수 있다. 

* derived를 없애자

```
+----+-------------+------------+------+----------------+
| id | select_type | table      | type | key            |
+----+-------------+------------+------+----------------+
|  1 | PRIMARY     | (derived2) | ref  | (auto_key0)    |
|  2 | DERIVED     | employees  | ref  | ix_firstname   |
+----+-------------+------------+------+----------------+
```

다음의 경우 옵티마이저가 자동으로 서브 쿼리를 외부 쿼리로 병합할 수 없으므로

가능하다면  튜닝하여 서브쿼리는 외부 쿼리로 수동으로 병합해서 작성하는 것이 쿼리의 성능 향상에 도움이 된다.

- ﻿﻿SUN() 또는 MIN(), MAX() 같은 집계 함수와 윈도우 함수(Window Function)가 사용된 서브쿼리
- ﻿﻿DISTINCT가 사용된 서브쿼리
- ﻿﻿GROUP BYL HAVINGO| 사용된 서브쿼리
- ﻿﻿LIMITOI 사용된 서브쿼리
- ﻿﻿UNION 또는 UNION ALL을 포함하는 서브쿼리
- ﻿﻿SELECT 절에 사용된 서브쿼리
- ﻿﻿값이 변경되는 사용자 변수가 사용된 서브쿼리

### 인비저블 인덱스(use invisible indexes)

특수한 종류의 데이터베이스 인덱스로, 인덱스가 있지만 옵티마이저에 의해 사용되지 않게 하는 기능이다.

`ALTER TABLE .. ALTER INDEX ... 1 VISIBLE 1 INVISIBLE`] 명령 으로 인덱스의 가용 상태를 변경할 수 있다.

```mysql
-- // 옵티마이저가 ix_hiredate 인덱스를 사용하지 못하게 변경
ALTER TABLE employees ALTER INDEX ix_hiredate INVISIBLE;

-- // 옵티마이저가 ix_hiredate 인덱스를 사용할 수 있게 변경
ALTER TABLE employees ALTER INDEX ix_hiredate VISIBLE:
```

인비저블 인덱스의 주요 특징과 사용 사례는 다음과 같다.

1. **성능 테스트**: 인덱스가 쿼리 성능에 미치는 영향을 평가하려면 인덱스를 임시로 비활성화한다. 인덱스를 삭제하지 않고 비활성화하면, 테스트 후에 쉽게 다시 활성화할 수 있다.
2. **점진적 변경**: 인덱스 변경이 애플리케이션에 미치는 영향을 천천히 평가하려는 경우에도 사용한다.
3. **문제 진단**: 특정 인덱스가 문제를 일으키는 경우, 인비저블 상태로 설정하여 문제를 진단하고 해결할 수 있다.
4. **인덱스 유지**: 인덱스를 완전히 삭제하지 않고 보존하려는 경우, 나중에 다시 활성화할 수 있도록 인비저블 상태로 설정할 수 있다.

### 스킵 스캔(skip_scan)

이 방법은 특히 복합 인덱스에서 유용하며, 쿼리의 WHERE 절이 인덱스의 첫 번째 열과 일치하지 않는 경우에 사용된다.

인덱스의 선행 칼 럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로도 인덱스를 사용할 수 있게 해준다

ex)

* (A, B, C) 로 구성된 복합 인덱스가 있을 때 A 칼럼에 대한 조건을 적지 않고 B,C 컬럼에 대한 조건만 있따면 원래는 이 인덱스를 사용할 수 없다.

* 이문제를 최적화 할 수 있는 기법이 스킵 스캔이다.

옵티마이저의 인덱스 스킵 스캔 최적화 기능은 다음과 같이 활성화 여부를 제어할 수 있다.

```mysql
-- // 현재 세션에서 인덱스 스킵 스캔 최적화를 활성화
SET optimizer_switch='skip_scan=on';

-- // 현재 세션에서 인덱스 스킵 스캔 최적화를 비활성화
SET optimizer_switch='skip_scan=off';

-- // 특정 테이블에 대해 인덱스 스킵 스캔을 사용하도록 힌트를 사용
SELECT /*+ SKIP_SCAN(employees)*/ COUNT(*)
FROM employees
WHERE birth date ='1965-02-01';

-- // 특정 테이블과 인덱스에 대해 인덱스 스킵 스캔을 사용하도록 힌트를 사용 
SELECT /*+ SKIP SCAN(employees ix gender birthdate)*/ COUNT (*)
FROM employees
WHERE birth_date)='1965-02-01';

-- // 특정 테이블에 대해 인덱스 스킵 스캔을 사용하지 않도록 힌트를 사용
SELECT /* NO SKIP SCAN(emplovees)*/ COUNT(*)
FROM emplovees
WHERE birth date)=1965-02-01:
```



### 해시 조인(hash_join)

해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는다.

네스티드 루프 조인은 마지막 레코드를 찾는 데까지는 시간이 많이 걸리지만 첫 번째 레코드를 찾는 것은 상대적으로 훨씬 빠르다. 

해시 조인은 최고 스루풋(Best Throughput, 처리시간) 전략에 적합하며, NL은 최고 응답속도(Best Response-time) 전략에 적합하다.

* 일반 웹 서비스 OLTP는 스루풋보다 응답속도가 중요하지만, 분석과 같은 서비스는 응답속도 보다는 전체 스루풋이 중요하다

MySQL 서버는 주로 조인 조건의 칼럼이 인덱스가 없다거나 조인 대상 테이블 중 일부의 레코드 건수가 매우 적은 경우 등에 대해서만 해시 조인 알고리즘을 사용하도록 설계돼 있다.

* 일반적으로 대용량 데이터 분석 보다는 OLTP 서비스에 사용되기 때문이다.

* 즉 MySQL 서버의 해시 조인 최적화는 네스티드 루프 조인이 사용되기에 적합하지 않은 경우를 위 한 차선책(Falback strategy) 같은 기능으로 생각하는 것이 좋다

MySQL 8.0.20 버전부터는 블록 네스티드 루프 조인은 더이상 사용되지 않고, 네스티드 루프 조인을 사용할 수 없는 경우에는 항상 해시 조인이 사용되도록 바뀌었다.

* BNL과 NO BNL과 같은 힌트들도 블록 네스티드 루프가 아닌 해시 조인을 유도하는 목적으로 사용된다.

해시조인을 쿼리를 처리하면 Extra 컬럼에 hash join 이라는 키워드를 확인할 수 있다.

* INDEX 힌트는 테스트를 위해NL이 사용되지 못하게 막은것

```mysql
EXPLAIN
SELECT *
	FROM employees e IGNORE INDEX(PRIMARY, ix_hiredate)
	INNER JOIN dept_emp de IGNORE INDEX(ix_empno_fromdate, ix_fromdate)
	ON de.emp_no=e.emp_no AND de.from_date e.hire_date;
```

```
+----+-------------+-------+------+-----------------------------------------+
| id | select_type | table | type | Extra                                   |
+----+-------------+-------+------+-----------------------------------------+
| 1  | SIMPLE      | de    | ALL  | NULL                                    |
| 1  | SIMPLE      |       | ALL  | Using where; Using join buffer (hash join)|
+----+-------------+-------+------+-----------------------------------------+
```

해시 조인은 빌드 단계와 프로브 단계로 나뉘어 처리된다

* 빌드 단계 : 조인 대상 테이블 중 상대적으로 레코드가 적은 테이블을 해시 테이블로 골라 메모리에 해시 테이블을 생성
* 프로브 단계 : 나머지 테이블의 레코드를 읽어 해시 테이블의 일치 레코드를 찾는 과정

위의 실행 계획에서는 어느 테이블이 빌드 테이블이고 어느 테이블이 프 로브 테이블인지 식별하기 어려우므로
`EXPLAIN FORMAT-TREE 명령` 또는 `EXPLAIN ANALYZE 명령`을 사용하면 조금 더 쉽게 구분할 수 있다

```
-> Inner hash join (e.hire_date = de.from_date), (e.emp_no = de.emp_no)
	(cost=9942694661.05 rows=331143)
-> Table scan on e (cost=0.08 rows=300252)
-> Hash
	-> Table scan on de (cost=33979.30 rows=331143)
```

해시조인은 메모리에서 모두 처리 가능한 경우와 모두 처리 못하는 경우로 나뉜다

**메모리에서 처리 가능한 경우**

<img src="./images/9장 옵티마이저와 힌트//image-20230814231740571.png" width = 800 height = 350>

해시 테이블을 메모리에 저장할 때 MySQL 서버는 `join_buffer_size` 시스템 변수로 크기를 제어할 수 있는 조인 버퍼를 사용한다. 

조인 버퍼의 기본 크기는 256KB인데, 해시 테이블의 레코드 건수가 많아서 조인 버퍼의 공간이 부족한 경우 하나의 청크가 조인 버퍼보다 작도록 청크로 분리한 다음 처리한다.

<img src="./images/9장 옵티마이저와 힌트//image-20230814231904997.png" width = 800 height =550>

* 이다음으로, 디스크에 저장된 빌드 테이블의 청크를 읽어 메모리 해시 테이블을 구축한 후
* 프로브 테이블의 청크를 읽어 메모리 해시 테이블과 조인한다.

이렇게 청크 단위로 조인하기 위해 MySOL 서버는 2차 해시 함수를 이용해 "빌드 테이블"과 "프로브 테이블"을 `동일 개수의 청크로` 쪼개

어 디스크로 저장한다

* 여기서 2차 해시 함수는  특정 해시 알고리즘이 아니라 해시 조인을 위한 해시 키 생성용 해시 함수와는 다른 해시 함수를 사용해서 청크를 분리한다는 의미



메모리에서 모두 처리 가능한 해시 조인 사용시 클래식 해시 조인 사용

해시 테이블이 조인 버퍼 메모리보다 큰 경우 그레이스 해시 조인을 활용한다.

### 인덱스 정렬 선호(prefer_ordering_index)

prefer_ordering_index는 특정 쿼리를 수행하는 데 있어, 인덱스 정렬을 사용하여 정렬을 피하거나 정렬 연산을 최소화하는 최적화 기법

MysQL 8.0.21 버전부터는 MySQL 서버 옵티마이저가 ORDER BY를 위한 인덱스에 너 무 가중치를 부여하지 않도록 `prefer_ordering_index` 옵티마이저 옵션이 추가됐다.

## 9.3.2 조인 최적화 알고리즘

MySQL에는 조인 쿼리의 실행 계획 최적화를 위한 알고리즘이 2개 있다.

ex) 4개 테이블 조인 예제

```mysql
SELECT *
FROM t1, t2, t3, t4
WHERE
...
```

### Exhaustive 검색 알고리즘

모든 가능한 조합의 비용을 탐색하여 최적의 조합 1개를 찾아 사용하는 방법

<img src="./images/9장 옵티마이저와 힌트//image-20230814232839065.png" width = 600 height =500>

루트 포스(brute force) 알고리즘으로도 알려져 있으며, 매우 단순하고 쉽지만 가능한 모든 경우의 수를 탐색해야 하므로, 문제의 크기가 커지면 커질수록 계산 복잡성이 기하급수적으로 증가한다.

장점은 정확한 해를 찾을 수 있다는 것이고, 단점은 문제의 크기가 커질수록 계산 시간이 급격히 증가한다는 것

### Greedy 검색 알고리즘

Exhausitive 검색 알고리즘의 시간이 너무 오래걸린다는 문제점을 해결하기 위해 도입된 조인 최적화 기법

<img src="./images/9장 옵티마이저와 힌트//image-20230814233018175.png" width = 900 height =600>

1. ﻿﻿﻿전체 N개의 테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
2. ﻿﻿﻿1번에서 `생성된 조인 조합 중`에서 `최소 비용의 실행 계획 하나를 선정`
3. ﻿﻿﻿2번에서 선정된 실행 계획의 첫 번째 테이블을 "부분 실행 계획(그림 9,20에서는 실행 계획 완료 대상으로 표현됨"
    의 첫 번째 테이블로 선정
4. ﻿﻿﻿전체 N-1개의 테이블 중(3번에서 선택된 테이블 제외)에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
5. ﻿﻿﻿4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 "부분 실행 계획"에 대입해 실행 비용을 계산
6. ﻿﻿﻿5번의 비용 계산 결과, 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 "부분 실행 계획"의 두 번째 테이블 로 선정
7. ﻿﻿﻿남은 테이블이 모두 없어질 때까지 4~6번까지의 과정을 반복 실행하면서 "부분 실행 계획"에 테이블의 조인 순서
    를 기록
8. ﻿﻿﻿최종적으로 "부분 실행 계획"이 테이블의 조인 순서로 결정됨

MySQL에서는 조인 최적화를 위한 시스템 변수로 `optimizer_prune_level`과 `optinizer_search_depth`가 제공된다.

* optinizer_search_depth의 기본값은 62
* 0으로 설정하면 옵티마이저가 자동으로 결정한다.
* optinizer_ prune_levelol = 1 로 설정되면 옵티마이저는 조인 순서 최적화에 경험 기반의 Heuristic 알고리즘을 사용한다
  * 특별한 요건이 없다면 0으로 설정하지 말자. 0으로 설정되면 쓰지 않아서 성능이 느려진다.

# 9.4 쿼리 힌트

MySQL 서버에서 사용 가능한 쿼리 힌트는 다음과 같이 2가지로 구분할 수 있다.

- ﻿﻿인덱스 힌트
- ﻿﻿옵티마이저 힌트

## 인덱스 힌트

이들은 모두 SQL의 문법에 맞게 사용해야 하기 때문에 사용하게 되면 ANSI-SOL 표준 문법을 준수하지 못하게 되는 단점이 있으므로

가능하다면 인덱스 힌트보다는 옵티마이저 힌트를 사용하자.

또한 인덱스 힌트는 SELECT, UPDATE에서만 사용할 수 있다. 

### STRAIGHT_JOIN

STRAIGHT JOIN은 옵티마이저 힌트인 동시에 조인 키워드이다. 

STRAIGHT_ JOEN은 SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다.

STRAIGHT_JOIN 힌트는 옵티마이저가 FROM 절에 명시된 테이블의 순서대로 조인을 수행하도록 유도하는데, 이 쿼리의 실행 계획을 보면 FROM 절에 명시된 테이블의 순서대로(employees -> dept_emp departments) 조인을 수행한다는 것을 알 수 있다.

```mysql
SELECT STRAIGHT_JOIN
	e.first_name, e.last_name, d.dept_name
FROM employees e, dept_emp de, departments d
WHERE e.emp_no = de. emp_no
AND d.dept_no = de.dept_no;

-- // 힌트 표기법을 다르기 했을뿐 둘은 같은 쿼리
SELECT /*! STRAIGHT_JOIN */
	e.first_name, e.last_name, d.dept_name
FROM employees e, dept_emp de, departments d
WHERE e.emp_no = de.emp_no
AND d.dept_no = de.dept_no;
```

```
+----+-------------+-------+------+-------------------+---------+-------+------+
| id | select_type | table | type | key               | rows    |     Extra    |
+----+-------------+-------+------+-------------------+---------+-------+------+
| 1  | SIMPLE      | e     | ALL  | NULL              | 300473  | NULL         |
| 1  | SIMPLE      | de    | ref  | ix_empno_fromdate |      1  | Using index  |
| 1  | SIMPLE      | d     | eq   | PRIMARY           |      1  | NULL         |
+----+-------------+-------+------+-------------------+---------+-------+------+
```

* FROM절에 명시된 순서대로 employee -> dept_emp -> departments 순으로 조인한다 

다음 기준에 맞게 조인 순서가 결정되지 않는 경우에만 STRAIGHT_JOIN 힌트로 조인 순서를 조정하는것이 좋다

- ﻿﻿임시 테이블(인라인 뷰 또는 파생된 테이블)과 일반 테이블의 조인: 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다.
  - 일반 테이블의 조인 칼럼에 인덱스가 없는 경우  레코드 건수가 작은 쪽을 먼저 읽도록 드라이빙으로 선택하는 것이 좋다. 
  - 옵티마이저가 실행 계획을 제대로 수립하지 못해서 심각한 성능 저하가 있는 경우에는 힌트를 사용하면 된다.
- ﻿﻿임시 테이블끼리 조인: 임시 테이블(서브쿼리로 파생된 테이블)은 항상 인덱스가 없기 때문에 어느 테이블을 먼저 드라이빙으로 읽어도 무관하므로 크기가 작은 테이블을 드라이빙으로 선택해주는 것이 좋다.

* 일반 테이블끼리 조인: 양쪽 테이블 모두 조인 칼럼에 인덱스가 있거나 양쪽 테이블 모두 조인 칼럼에 인덱스가 없는 경우 레`코드 건수가 적은 테이블을 드라이빙으로 선택해주는 것이 좋으며`, 그 이외의 경우에는 조인 칼럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋다.

여기서 언급한 레코드 건수라는 것은 `인덱스를 사용할 수 있는 WHERE 조건까지 포함해서 그 조건을 만족하는 레코드 건수`를 의미하는 것이지, `무조건 테이블 전체의 레코드 건수를 의미하는 것은 아니다.`

STRAIGHT_JOIN 힌트와 비슷한 역할을 하는 옵티마이저 힌트로는 다음과 같은 것들이 있다.

- ﻿﻿JOIN_FIXED_ORDER -> STRATIGHT_JOIN과 동일한 효과
- ﻿﻿JOIN ORDER
- ﻿﻿JOIN PREFIX
- ﻿﻿JOIN SUFFIX
  - 나머지 3개는 일부 테이블 조인 순서에 대해서만 제안하는 힌트

### USE INDEX / FORCE INDEX / IGNORE INDEX

STRAIGHT_JOIN 힌트와는 달 리 인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다.

인덱스 힌트는 크게 다음과 같이 3종류가 있다. 

* 3종류의 인덱스 힌트 모두 키워드 뒤에 사용할 인덱스 의 이름을 괄호로 묶어서 사용하며, 괄호 안에 아무것도 없거나 존재하지 않는 인덱스 이름을 사용할 경우에는 쿼리의 문법 오류로 처리된다. 
* 또한 별도로 사용자가 부여한 이름이 없는 프라이머리 키는 "PRIMARY”라고 명시하면 된다.

- ﻿﻿USE INDEX: 가장 자주 사용되는 인덱스 힌트로, MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장 하는 힌트.
  -  대부분의 경우 인덱스 힌트가 주어지면 옵티마이저는 사용자의 힌트를 채택하지만 항상 그 인덱스를 사용하는 것은 아니다.
- ﻿﻿FORCE INDEX: USE INDEX와 비교해서 다른 점은 없으며, `USE INDEX보다 옵티마이저에게 미치는 영향이 더 강한 힌트` 
  - 하지만 USE INDEX 힌트만으로도 옵티마이저에 대한 영향력이 충분히 크기 때문에 FORCE INDEX는 거의 사용할 필요가 없어 보인다.
- ﻿﻿IGNORE INDEX: 특정 인덱스를 사용하지 못하게 하는 용도로 사용하는 힌트다. 
  - 때로는 옵티마이저가 풀 테이블 스캔을 사용하도록 유도하기 위해 IGNORE INDEX 힌트를 사용할 수도 있다.

특별히 인덱스 힌트에 용도가 명시되지 않으면(사용 가능한 경우) 주어진 인덱스를 3가지 용도로 사용한다.

- ﻿﻿USE INDEX FOR JOIN: 여기서 J0IN이라는 키워드는 테이블 간의 조인뿐만 아니라 레코드를 검색하기 위한 용도까지 포함하는 용어다. MySQL 서버에서는 하나의 테이블로부터 데이터를 검색하는 작업도 JOIN이라고 표현하기 때문에 FOR JOIN이라는 이름이 붙은 것이다.
- ﻿﻿USE INDEX FOR ORDER BY: 명시된 인덱스를 ORDER BY 용도로만 사용할 수 있게 제한한다.
- ﻿﻿USE INDEX FOR GROUP BY: 명시된 인덱스를 GROUP BY 용도로만 사용할 수 있게 제한한다.

**사용법**

```mysql
SELECT * FROM employees WHERE emp_no=10001;
SELECT * FROM employees FORCE INDEX(primary) WHERE emp_no=10001;
SELECT * FROM employees USE INDEX(primary) WHERE emp_no=10001;
SELECT * FROM employees IGNORE INDEX(primary) WHERE emp_no=10001;
SELECT * FROM employees FORCE INDEX(ix_firstname) WHERE emp_no=10001;
```

### SQL_CALC_FOUND_ROWS

SOL_CALC_FOUND._ RONS 힌트가 포함된 쿼리의 경우에는 LIMIT을 만족하는 수만큼의 레코드를 찾았다고 하더라도 끝까지 검색을 수행한다.

* 일반적으로 사용하지 않는 것이 좋다.

* 디스크 랜덤 I/O가 발생되기 때문이다.

## 9.4.2 옵티마이저 힌트

### 옵티마이저 힌트 종류

옵티마이저 힌트는 영향 범위에 따라 다음 4개 그룹으로 나누어 볼 수 있다.

- ﻿﻿인덱스: 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
- ﻿﻿테이블: 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
- ﻿﻿쿼리 블록: 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트로서, 특정 쿼리 블록의 이름을 명시하는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
- ﻿﻿글로벌(쿼리 전체): 전체 쿼리에 대해서 영향을 미치는 힌트

| 힌트 이름                   | 설명                                                         | 영향 범위         |
| --------------------------- | ------------------------------------------------------------ | ----------------- |
| MAX_EXECUTION_TIME          | 쿼리의 실행 시간 제한                                        |                   |
| RESOURCE_GROUP              | 쿼리 실행의 리소스 그룹 설정                                 | 글로벌            |
| SET_VAR                     | 쿼리 실행을 위한 시스템 변수 제어                            | 글로벌            |
| SUBQUERY                    | 서브쿼리의 세미 조인 최적화 제어                             | 쿼리 블록, 테이블 |
| BKA, NO_BKA                 | BKA(Batched Key Access) 조인 사용 여부 제어                  | 쿼리 블록, 테이블 |
| BNL, NO_BNL                 | 블록 네스티드 루프 조인 사용 여부 제어                       | 쿼리 블록, 테이블 |
| HASH_JOIN, NO_HASH_JOIN     | 해시 조인 사용 여부 제어                                     | 쿼리 블록, 테이블 |
| DERIVED_CONDITION_PUSHDOWN  | 외부 쿼리의 조건을 서브쿼리로 옮기는 최적화 사용 여부        | 쿼리 블록, 테이블 |
| JOIN_FIXED_ORDER            | FROM 절에 명시된 테이블 순서대로 조인 실행                   | 쿼리 블록         |
| JOIN_ORDER                  | 힌트에 명시된 테이블 순서대로 조인 실행                      | 쿼리 블록         |
| JOIN_PREFIX                 | 힌트에 명시된 테이블을 조인의 드라이빙 테이블로 조인 실행    | 쿼리 블록         |
| JOIN_SUFFIX                 | 힌트에 명시된 테이블을 조인의 드리븐 테이블로 조인 실행      | 쿼리 블록         |
| QB_NAME                     | 쿼리 블록의 이름 설정을 위한 힌트                            | 쿼리 블록         |
| SEMIJOIN, NO_SEMIJOIN       | 서브쿼리의 세미 조인 최적화 전략 제어                        | 쿼리 블록         |
| MERGE, NO_MERGE             | FROM 질의 서브쿼리나 뷰를 외부 쿼리 블록으로 병합하는 최적화 | 테이블            |
| INDEX_MERGE, NO_INDEX_MERGE | 인덱스 병합 실행 계획 사용 여부 제어                         | 테이블, 인덱스    |
| MRR, NO_MRR                 | MRR(Multi-Range Read) 사용 여부 제어                         | 테이블, 인덱스    |
| NO_ICP                      | ICP(인덱스 컨디션 푸시다운) 최적화 전략 사용 여부 제어       | 테이블, 인덱스    |
| NO_RANGE_OPTIMIZATION       | 인덱스 레인지 액세스를 비활성화                              | 테이블, 인덱스    |
| SKIP_SCAN, NO_SKIP_SCAN     | 인덱스 스킵 스캔 사용 여부 제어                              | 테이블, 인덱스    |
| INDEX, NO_INDEX             | GROUP BY, ORDER BY, WHERE 절의 처리를 위한 인덱스 사용 여부  | 인덱스            |
| GROUP_INDEX, NO_GROUP_INDEX | GROUP BY 절의 처리를 위한 인덱스 사용 여부 제어              | 인덱스            |
| JOIN_INDEX, NO_JOIN_INDEX   | WHERE 절의 처리를 위한 인덱스 사용 여부 제어                 | 인덱스            |
| ORDER_INDEX, NO_ORDER_INDEX | ORDER BY 절의 처리를 위한 인덱스 사용 여부 제어              | 인덱스            |

모든 인덱스 수준의 힌트는 반드시 테이블명이 선행돼야 한다. 

인덱스 수준의 옵티마이저 힌트인 INDEX 힌트를 사용하는 경우 사용할 인덱스명을 사용해야 한다. 

하지만 인덱스 이름을 명시할 때는 다음 예제와 같이 반드시 그 인덱스를 가진 테이블명을 먼저 명시해야 한다.

```mysql
EXPLAIN
SELECT /*+ INDEX(employees ix_firstname) */ *
FROM employees
WHERE first name='Matt';

EXPLAIN
SELECT /*+ NO INDEX(employees ix firstname) */ *
FROM employees
WHERE first name='Matt';
```

서브쿼리 또는 외부 쿼리 블록에서 사용할수도 있다.

외부 쿼리 블록에서 사용하려면 QB_NAME 힌트를 이용해 해당 쿼리 블록에 이름을 부여해야 한다.

```mysql
EXPLAIN
SELECT /*+ JOIN_ORDER(e, s@subq1) */
	COUNT (*)
FROM employees e
WHERE e.first_name='Matt'
	AND e.emp_no IN (SELECT /*+ QB_NAME (subq1) */ 
                   s.emp_no
									FROM salaries s
									WHERE s.salary BETWEEN 50000 AND 50500);
```

### MAX_EXECUTION_TIME - 쿼리 최대 실행 시간

MAX_EXECUTION_TIME 힌트에는 밀리초 단위의 시간을 설정하는데, 쿼리가 지정된 시간을 초과하면 다음과 같이 쿼리는 실패하게 된다.

* 실행계획에 영향을 미치지 않는다.

```mysql
SELECT /** MAX_EXECUTION_TIME (100) */ * // 100 MS
FROM employees
ORDER BY last name LIMIT 1;

ERROR 3024 (HY000): Query execution was interrupted, maximum statement execution time exceeded
```

### SET_VAR - 쿼리 실행을 위한 시스템 변수 제어

SET_VAR 힌트를 제어하어 시스템 변수를 제어한다

SET_VAR 힌트는 실행 계획을 바꾸는 용도뿐만 아니라 조인 버퍼나 정렬용 버퍼(소트 버퍼)의 크기를 일 시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시키는 용도로도 사용할 수 있다.

* 이외에도 다양하게 사용가능하지만, 모든 시스템 변수를 SET_VAR 힌트로 조정할 수는 없다.

```mysql
EXPLAIN
SELECT /*+ SET_VAR(optimizer_switch='index_merge_intersection=off') */ *
FROM employees
WHERE first_name='Georgi AND emp_no BETWEEN 10000 AND 20000';
```

### SEMIJOIN & NO_SEMIJOIN

서브쿼리의 세미 조인 최적화 전략 제어한다.

| 최적화 전략        | 힌트                      |
| ------------------ | ------------------------- |
| Duplicate Weed-out | SEMIJOIN(DUPSWEEDOUT)     |
| First Match        | SEMIJOIN(FIRSTMATCH)      |
| Loose Scan         | SEMIJOIN(LOOSESCAN)       |
| Materialization    | SEMIJOIN(MATERIALIZATION) |
| Table Pull-out     | 없음                      |

세미 조인 최적화 힌트는 외부 쿼리가 아니라 서브쿼리에 명시해야 한다

```mysql
EXPLAIN
SELECT +
FROM departments d
WHERE d.dept_no IN
	(SELECT /*+ SEMIJOIN(MATERIALIZATION) */ de. dept_no
	 FROM dept_emp de);
```

다른 방법으로는 우선 서브쿼리에 쿼리 블록 이름을 정의하고 실제 세미 조인 힌트는 외부 쿼리 블록에 명시하는 방법이 있다.

```mysql
EXPLAIN
SELECT /* SEMIJOIN(@subq1 MATERIALIZATION) */ *
FROM departments d
WHERE d.dept_no IN
(SELECT /*+ QB_NAME (subq1) */ de.dept_no
FROM dept_emp de);
```

### SUBQUERY 최적화

서브쿼리 최적화는 세미 조인 최적화가 사용되지 못할 때 사용하는 최적화 방법.

| 최적화 방법     | 힌트                       |
| --------------- | -------------------------- |
| IN-to EXISTS    | SUBQUERY (INTOEXISTS)      |
| Materialization | SUBOUERY (MATERIALIZATION) |

세미 조인 최적화는 주로 IN(subquery) 형태의 쿼리에 사용될 수 있지만 안티 세미 조인(Anti Semi-Join)의 최적화에는 사용될 수 없다. 그래서 주로 안티 세미 조인 최적화에는 위의 2가지 최적화가 사용된다.

사용법은 세미조인과 같다.

추가적인 서브쿼리 최적화 방법 : https://dev.mysql.com/doc/refman/8.0/en/subquery-optimization.html

### BNL & NO_BNL & HASHJOIN & NO_HASHJOIN

* BNL 힌트와 NO_BNL 힌트는 MySQL 8.0.20부터 버전에서도 여전히 사용 가능하며 해시 조인을 유도한다
* HASHJOIN과 NO_HASHJOIN 힌트는 MySQL 8.0.18 버전에서만 유효하며, 그 이후 버전에서는 효력이 없다.

```mysql
EXPLAIN
SELECT /** BNL(e, de) */ *
FROM employees e
INNER JOIN dept_emp de ON de.emp_no = e.emp_no;
```

* MySQL 서버에서는 조인 조건이 되는 칼럼의 인데스가 적절히 준비돼 있다면 해시 조인은 거의 사용되지 않는다.
* 해시 조인 알고리즘이 사용되게 하려면 조인 조건이 되는 emp_no 칼럼의 인덱스를 empLoyees 이블과 dept_emp 테이블에서 모두 제거하거나 사용하지 못하게 해야 한다.

### JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX

옵티마이저 힌트에서는 STRAIGHT_JOIN과 동일한 힌트까지 포함해서 다음과 같이 4개의 힌트를 제공한다.

- ﻿﻿JOIN_FIXED_ORDER: STRAIGHT_JOIN 힌트와 동일하게 FROM 절의 테이블 순서대로 조인을 실행하게 하는 힌트
- ﻿﻿JOIN ORDER: FRON 절에 사용된 테이블의 순서가 아니라 히트에 명시된 테이블의 순서대로 조인을 실행하는 힌트
- ﻿﻿JOIN_PREFIX: 조인에서 드라이빙 테이블만 강제하는 힌트
- ﻿﻿JOIN_SUFFIX: 조인에서 드리븐 테이블(가장 마지막에 조인돼야 할 테이블들)만 강제하는 힌트

```mysql
-- // FROM 절에 나열된 테이블의 순서대로 조인 실행
SELECT /*+ JOIN_FIXED_ORDER() */ *
FROM employees e
INNER JOIN dept_emp de ON de. emp_no = e.emp_no
INNER JOIN departments d ON d.dept_no = de.dept_no;

-- //일부 테이블에 대해서만 조인 순서를 나열
SELECT /*+ JOIN_ORDER(d, de) */ *
FROM employees e
INNER JOIN dept_emp de ON de. emp_no = e.emp_no
INNER JOIN departments d ON d. dept_no = de.dept_no;

-- // 조인의 드라이빙 테이블에 대해서만 조인 순서를 나열
SELECT /*+ JOIN_PREFIX(e, de) */ *
FROM employees e
INNER JOIN dept_emp de ON de.emp_no = e.emp_no
INNER JOIN departments d ON d.dept_no = de.dept_no;

-- // 조인의 드리븐 테이블에 대해서만 조인 순서를 나열
SELECT /*+ JOIN_SUFFIX(de, e) */ *
FROM employees e
INNER JOIN dept_emp de ON de. emp_no=e. emp_no
INNER JOIN departments d ON d .dept_no=de.dept_no;
```

### MERGE & NO_MERGE

내부 임시 테이블(Derived table을 생성하도록 유도하는 힌트 또는 사용하지 못하게 하는 힌트

### INDEX MERGE & NO INDEX MERGE

하나의 테이블에 대해 여러 개의 인덱스를 동시에 사용하게 유도

인덱스 머지 실행 계획의 사용 여부를 제어하고자 할 때, 다음 예제와 같이 INDEX, MERGE 와 NO_INDEX_ MERGE 옵티마이저 힌트를 이용하면 된다.

```mysql
EXPLAIN
SELECT /*+ INDEX_MERGE (employees ix_firstname, PRIMARY) */ *
FROM emoloyees
WHERE first name='Georgi' AND emp_no BETWEEN 10000 AND 20000;
```

###  NO ICP

인덱스 푸시다운으로 인해 비용 계산이 잘못되어 잘못된 실행계획 수립시 사용

### SKIP_SCAN & NO_SKIP_SCAN

인덱스 스킵 스캔은 인덱스의 선행 칼럼에 대한 조건이 없어도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 매우 훌륭한 최적화 기능.

* 하지만 조건이 누락된 선행 칼럼이 가지는 유니크한 값의 개수가 많아진다면 인덱스 스킵 스캔의 성능은 오히려 더 떨어진다

### INDEX & NO_INDEX

INDEX와 NO_INDEX 옵티마이저 힌트는 예전 MySQL 서버에서 사용되던 인덱스 힌트를 대체하는 용도로 제공된다

* 표 : 인덱스 힌트를 대체하는 옵티마이저 힌트 

| 인덱스 힌트               | 옵티마이저 힌트 |
| ------------------------- | --------------- |
| USE INDEX                 | INDEX           |
| USE INDEX FOR GROUP BY    | GROUP INDEX     |
| USE INDEX FOR ORDER BY    | ORDER INDEX     |
| IGNORE INDEX              | NO_INDEX        |
| IGNORE INDEX FOR GROUP BY | NO_GROUP_INDEX  |
| IGNORE INDEX FOR ORDER BY | NO_ORDER_INDEX  |

옵티마이저 힌트에는 테이블명과 인덱스 이름을 함께 명시해야 한다.

```mysql
--// 인덱스 힌트 사용시
 EXPLAIN
SELECT *
FROM employees USE INDEX(ix_firstname)
WHERE first name='Matt';

-- // 옵티마이저 힌트를 이용한 인덱스 힌트 사용시
EXPLAIN
SELECT /*+ INDEX(employees ix_firstname) */ *
FROM employees
WHERE first name='Matt';
```

