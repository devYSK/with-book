# JVM 밑바닥까지 파헤치기

[toc]

* 자바 가상 머신 명세서 : https://docs.oracle.com/javase/specs/index.html



# 1장 자바 기술 시스템 소개



JDK : 자바 언어, JVM, 자바 클래스 라이브러리의 묶음. 자바 프로그램 개발에 필요한 최소한의 환경

* JRE를 포함함.

JRE : 자바 SE API, JVM, 배포 기술의 묶음. 실행할 수 있는 표준 환경

![image-20250321145846355](./images//image-20250321145846355.png)

### Hotspot VM

자바 프로그램을 실행할 때 사용하는 가장 대표적인 JVM 중 하나

자바 프로그램은 먼저 `.java` 파일을 `.class` 바이트코드로 컴파일하고, 이 바이트코드를 실행하는 게 바로 **JVM**이고, 그 JVM 구현체 중 하나가 **HotSpot**

HotSpot VM의 핵심 특징은 "어떤 코드가 자주 실행되는지(=hot spot)"를 **스스로 판단해서**, 그 **핫한 부분만 더 빠르게 실행**하도록 하는 기능. 이게 바로 **JIT(Just-In-Time) 컴파일러** 덕분

* 핫 코드 감지 기술

핫 코드 감지 기술은, 컴파일했을 때 가장 효과를 크게 볼 수 있는 코드 영역을 런타임에 알아내어 JIT 컴파일러에게 알려주고, JIT 컴파일러가 해당 코드를 메서드 단위로 컴파일한다.

* 런타임에 스택을 치환하는 기술을 온스택 치환이라고 함
* JIT(Just-In-Time) 컴파일러는 프로그램 실행 시점(runtime)에 코드를 기계어로 변환하여 실행 성능을 극대화하는 기술
  * 처음에는 바이트코드를 인터프리터가 한 줄씩 해석하면서 실행해요.
  * 그런데 어떤 **코드 블록이 자주 실행된다**면, JIT 컴파일러가 **그 부분을 진짜 기계어로 컴파일해서 캐시에 저장**해요.
  * 다음부터는 그 코드 블록은 기계어로 된 걸 바로 실행하니 더 빨라요!
  * **AOT 컴파일러:** 미리 전체 프로그램을 기계어로 변환하여 실행 파일을 생성합니다. 실행 전에 모든 코드가 컴파일되므로, 실행 시에는 별도의 컴파일 단계가 없지만, 실행 환경의 특성이나 데이터에 최적화된 코드를 생성하기 어렵습니다 <-> jit과 반대됌. c, c++, golang 등. 운영체제별로 따로 컴파일해서 배포해야함

Java는 모든 플랫폼에서 동작하게 하기 위해 java를 .class라는 바이트코드로 변환 후 JVM 으로 실행된다.

JIT 컴파일러는 각 플랫폼 특성을 고려하여 런타임에 최적의 기계어 코드를 생성한다. 

JIT 컴파일러는 처음에는 바이트 코드를 인터프리팅 방식으로 실행하다, 핫스팟 코드를 만나면 런타임에 기계어로 컴파일하여 캐싱해서 재사용한다. 



### 차세대 jit 컴파일러

핫스팟 vm은 jit 컴파일러를 2개 내장하고 있음

* 컴파일 속도가 빠른 대신 최적화를 적게 하는 c1 컴파일러(클라이언트)
* 컴파일 속도가 느리지만 더 많은 최적화를 하는 c2 컴파일러(서버 컴파일러)

최신 HotSpot JVM은 **티어드 컴파일** 기법을 사용하여 두 컴파일러의 장점을 결합합니다.

- 초기에는 빠른 시작을 위해 C1으로 컴파일하고,
- 실행 중 반복적으로 호출되는 핫스팟 코드가 감지되면 C2로 재컴파일하여 최적의 성능을 달성합니다.

### 프로젝트 발할라

프로젝트 발할라(Project Valhalla)**는 Java의 성능과 메모리 효율을 **획기적으로 개선하기 위한 장기 프로젝트

> Java에서 더 빠르고, 메모리 효율 좋은 데이터 구조를 만들 수 있게 해주는 프로젝트

* 성능 개선: CPU 캐시 히트율 증가, GC 부담 감소

* 메모리 절약: 객체 헤더 제거, 참조 대신 직접 메모리 배치

* 병렬 처리 효율 향상

* 앞으로의 Java 성능 진화 기반

자바의 기본 메모리 구조 (복습)

| 메모리 영역                    | 역할                                        |
| ------------------------------ | ------------------------------------------- |
| **스택(Stack)**                | 메서드 호출 시 생성되는 지역 변수 저장 공간 |
| **힙(Heap)**                   | `new`로 생성된 객체가 저장되는 공간         |
| **메서드 영역 / 메타스페이스** | 클래스 정의, static 변수 등 저장            |

Project Valhalla 도입 시: 값 타입(Value Class)

```java
value class Point {
    int x;
    int y;
}
```

이제 Point는 **identity 없는 값 객체**, 즉 기본 타입처럼 작동하게 돼요.

```java
Point p = new Point(1, 2);
```

메모리 구조 

```
[ Stack ]
p.x = 1
p.y = 2

(힙 사용 X, 객체 헤더 X)
```

> 마치 `int`나 `double`처럼 **stack에 직접 저장**됨.
>  필요시 배열 같은 곳에 들어가도 **연속된 메모리 공간**으로 저장 가능!

| 구분        | 기존 Java 객체   | Valhalla 값 타입       |
| ----------- | ---------------- | ---------------------- |
| 메모리 위치 | 힙 (heap)        | 스택 또는 인라인       |
| 메모리 구성 | 참조 + 객체 헤더 | 데이터만 존재          |
| GC 대상     | O (GC가 수집함)  | X (기본 타입처럼 취급) |
| 배열 저장   | 참조 배열        | 데이터 인라인 배열     |
| 성능        | 상대적으로 느림  | 훨씬 빠름              |

기존 java 

```
Point[] arr = new Point[3];
arr[0] = new Point(1, 2);
```

→ 힙 구조:

```
arr ─────────▶ [ref0][ref1][ref2]  ← 배열은 참조만 저장
              │     │     │
              ▼     ▼     ▼
            객체0  객체1  객체2
```

Valhalla 구조

```
Point[] arr = new Point[3];
```

→ 메모리 구조:

```
arr ─────────▶ [x0][y0][x1][y1][x2][y2]  ← 연속된 구조 (primitive처럼)
```

값 타입은 **"힙에도 저장될 수 있다"**, 하지만 **GC 대상이 아니다**

스코프가 벗어나면 사라짐. (선언한 함수라던가), 값타입을 반환하는 함수에서 반환받고, 그 함수가 종료된 경우 



GC가 해줘야 할 일이 거의 없도록 설계된 타입

스택 값은 GC가 관리할 필요 없이, **JVM이 스택 프레임 날리면서 자동 제거**

| 질문                                       | 답변                                              |
| ------------------------------------------ | ------------------------------------------------- |
| value class를 리턴하면 값 사라지지 않나요? | ❌ 절대 안 사라짐. 값이 복사되어 호출자에게 전달됨 |
| 스택에만 저장되면 함수 끝나면 날아가나요?  | 복사된 값은 호출자 쪽으로 안전하게 넘어감         |
| 참조처럼 공유되나요?                       | ❌ 공유 안 됨. 항상 **복사**                       |
| 그러면 성능 좋은가요?                      | 네. 힙 사용 없고 GC 부담도 없음                   |

메모리 구조

```
mathematica


복사편집
[Heap - 배열]
┌────────────────────────────┐
│ Point[3]                   │  ← 배열 자체는 힙에 있음
├────────────────────────────┤
│ x0=1 │ y0=2                │ ← 인라인 저장 (Point 0)
│ x1=3 │ y1=4                │ ← 인라인 저장 (Point 1)
│ x2=5 │ y2=6                │ ← 인라인 저장 (Point 2)
└────────────────────────────┘
```

- ✔️ 배열 자체는 힙에 있지만
- ✔️ 각각의 `Point`는 **별도 객체가 아니라 값 자체로 저장됨** (primitive처럼!)
- ❌ `new Point()` 객체가 힙에 올라가는 게 아님 → **GC 추적 불필요**

GC 동작 방식

| 항목       | 설명                                               |
| ---------- | -------------------------------------------------- |
| 배열       | 힙에 저장됨 → GC가 필요함                          |
| 배열의 값  | 값 타입이라 참조 없음 → GC가 따로 추적할 필요 없음 |
| `Point` 값 | 그냥 숫자 덩어리 → GC가 인식할 필요 없음           |

> 즉, **배열이 수거되면 값들도 같이 사라짐. 따로 추적은 안 함.**

반면, 같은 상황에서 `record`로 하면?

```
record Point(int x, int y) {}

Point[] points = new Point[3];
points[0] = new Point(1, 2);
```

메모리 구조

```
[Heap - 배열]                    [Heap - 객체들]
┌────────────────────────────┐   ┌─────────────┐
│ Point[3]                   │ ─▶│ Point(1,2)  │
├────────────────────────────┤   └─────────────┘
│ ref0 │ ref1 │ ref2         │
└────────────────────────────┘
```

- 배열은 힙에 존재
- 각 요소는 **Point 객체에 대한 참조(reference)**
- 각 `Point` 객체도 **힙에 따로 존재**
- 👉 GC는 배열뿐 아니라 **Point 객체도 추적해서 수거해야 함**